<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR æ˜Ÿçƒç²’å­ç³»ç»Ÿ - ç‹¬ç«‹é¢—ç²’ç‰ˆ</title>
    <style>
        :root {
            --bg-dark: #000000;
            --bg-glass: rgba(15, 15, 20, 0.72);
            --bg-glass-hover: rgba(25, 25, 35, 0.85);
            --planet-orange: #ff8c00;
            --planet-glow: rgba(255, 140, 0, 0.6);
            --ring-white: #ffffff;
            --accent-blue: #00a8ff;
            --text-dim: #888;
            --text-bright: #fff;
            
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 12px;
            --spacing-lg: 16px;
            
            --ui-scale: 0.95;
        }

        @media screen and (max-height: 800px) { :root { --ui-scale: 0.85; } }
        @media screen and (min-width: 2000px) { :root { --ui-scale: 1.1; } }
        :fullscreen { --ui-scale: 1.0; }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            color: var(--text-bright);
        }

        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* ç»ç’ƒæ‹Ÿæ€é¢æ¿ */
        .glass-panel {
            background: var(--bg-glass);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.06);
            overflow: hidden;
            box-sizing: border-box;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .glass-panel:hover {
            background: var(--bg-glass-hover);
            border-color: var(--planet-glow);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5), 0 0 20px var(--planet-glow);
        }

        .panel-hidden { 
            transform: translateX(calc(-1 * 220px)) scale(var(--ui-scale)) !important; 
            opacity: 0 !important; 
            pointer-events: none !important; 
        }

        /* å·¦ä¾§ä¿¡æ¯é¢æ¿ */
        #infoPanel {
            position: fixed;
            top: var(--spacing-lg);
            left: var(--spacing-lg);
            width: 220px;
            padding: var(--spacing-md);
            z-index: 100;
            transform: scale(var(--ui-scale));
            transform-origin: top left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #infoPanel h2 {
            color: var(--planet-orange);
            font-size: 14px;
            margin-bottom: var(--spacing-sm);
            text-align: center;
            text-shadow: 0 0 10px var(--planet-glow);
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: var(--spacing-xs) 0;
            padding: var(--spacing-xs) var(--spacing-sm);
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-sm);
            font-size: 11px;
            border-left: 3px solid var(--planet-orange);
        }

        .status-label {
            color: var(--text-dim);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            color: var(--text-bright);
            font-weight: 700;
        }

        .status-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            background: #ff0000;
            box-shadow: 0 0 4px #ff0000;
            animation: blink 1.5s ease-in-out infinite;
        }

        .status-indicator.active {
            background: #00ff00;
            box-shadow: 0 0 6px #00ff00;
            animation: none;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* å³ä¾§æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        #gestureIndicator {
            position: fixed;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            width: 160px;
            padding: var(--spacing-md);
            z-index: 100;
            transform: scale(var(--ui-scale));
            transform-origin: top right;
            text-align: center;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #gestureIndicator h3 {
            color: var(--accent-blue);
            font-size: 12px;
            margin-bottom: var(--spacing-sm);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 700;
        }

        .gesture-icon {
            font-size: 36px;
            margin: 6px 0;
            filter: drop-shadow(0 0 8px rgba(0, 168, 255, 0.6));
        }

        .gesture-name {
            color: var(--text-bright);
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
            margin-top: 4px;
        }

        /* é¡¶éƒ¨æ“ä½œæŒ‰é’® */
        #topButtons {
            position: fixed;
            top: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: var(--spacing-sm);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .top-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 140, 0, 0.3);
            color: var(--planet-orange);
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            font-size: 11px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(8px);
        }

        .top-btn:hover {
            background: rgba(255, 140, 0, 0.15);
            border-color: var(--planet-orange);
            color: var(--text-bright);
            box-shadow: 0 0 16px var(--planet-glow);
            transform: translateY(-1px);
        }

        .top-btn:active {
            transform: translateY(0);
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        #controlPanel {
            position: fixed;
            bottom: var(--spacing-lg);
            left: var(--spacing-lg);
            padding: var(--spacing-sm);
            z-index: 100;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-xs);
            width: 220px;
            transform: scale(var(--ui-scale));
            transform-origin: bottom left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .control-title {
            grid-column: span 2;
            font-size: 10px;
            color: var(--planet-orange);
            text-align: center;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            border-bottom: 1px solid rgba(255, 140, 0, 0.2);
            padding-bottom: 3px;
        }

        .control-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 140, 0, 0.3);
            color: var(--planet-orange);
            cursor: pointer;
            font-size: 10px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .control-btn:hover {
            background: rgba(255, 140, 0, 0.1);
            border-color: var(--planet-orange);
            box-shadow: 0 0 12px var(--planet-glow);
            transform: translateY(-1px);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn.active {
            background: rgba(255, 140, 0, 0.2);
            border-color: var(--planet-orange);
            color: var(--text-bright);
        }

        /* è¿›åº¦æŒ‡ç¤ºå™¨ */
        #progressIndicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 140, 0, 0.15);
            border-top: 3px solid var(--planet-orange);
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            box-shadow: 0 0 20px var(--planet-glow);
        }

        @keyframes spin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.05); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .progress-container {
            width: 320px;
            margin-top: 20px;
            display: none;
        }

        .progress-bar-bg {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 10px;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 140, 0, 0.8), var(--planet-orange));
            width: 0%;
            transition: width 0.4s ease;
            box-shadow: 0 0 16px var(--planet-glow);
            border-radius: 3px;
        }

        .progress-text {
            color: var(--planet-orange);
            font-size: 14px;
            text-align: center;
            letter-spacing: 1px;
            font-weight: 600;
            margin-top: 10px;
        }

        .progress-steps {
            color: var(--text-dim);
            font-size: 11px;
            margin-top: 8px;
            text-align: center;
        }

        .progress-step {
            margin: 3px 0;
            padding: 2px 0;
            transition: color 0.3s ease;
        }

        .progress-step.complete {
            color: #00ff88;
        }

        .progress-step.current {
            color: var(--planet-orange);
            font-weight: 700;
        }

        /* æ‹–æ‹½æ ‡é¢˜ */
        #mainTitle {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            text-align: center;
            cursor: move;
            user-select: none;
            padding: var(--spacing-sm);
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        #mainTitle:hover {
            background: rgba(0, 0, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
        }

        .title-line {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            color: var(--planet-orange);
            text-shadow: 0 0 15px var(--planet-glow);
            letter-spacing: 2px;
            white-space: nowrap;
            transition: all 0.3s ease;
        }

        .title-subline {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 4px;
            letter-spacing: 1px;
        }

        /* çŠ¶æ€æç¤º */
        #stateToast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: var(--planet-orange);
            color: #000;
            padding: 16px 32px;
            border-radius: var(--radius-lg);
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 1px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            box-shadow: 0 10px 30px var(--planet-glow);
            text-transform: uppercase;
            white-space: nowrap;
        }

        #stateToast.show {
            opacity: 1;
        }

        #stateToast.error {
            background: rgba(255, 68, 68, 0.95);
            color: #fff;
            box-shadow: 0 10px 30px rgba(255, 68, 68, 0.4);
        }

        /* ä¿¡æ¯æç¤º */
        #infoTooltip {
            position: fixed;
            bottom: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            color: var(--planet-orange);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 11px;
            letter-spacing: 0.5px;
            border: 1px solid rgba(255, 140, 0, 0.3);
            backdrop-filter: blur(8px);
            white-space: nowrap;
            text-shadow: 0 0 5px var(--planet-glow);
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* è°ƒè¯•ä¿¡æ¯ */
        #debug-info {
            position: fixed;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: #00ff00;
            font-size: 13px;
            font-weight: 600;
            font-family: 'Consolas', monospace;
            pointer-events: none;
            z-index: 999;
            text-shadow: 0 0 4px #000;
            background: rgba(0,0,0,0.4);
            padding: 6px 0;
            transition: all 0.5s ease;
            letter-spacing: 0.5px;
        }

        #debug-info.loading-center {
            bottom: auto;
            top: 55%;
            transform: translateY(-50%);
            font-size: 16px;
            background: rgba(0,0,0,0.85);
            padding: 20px 0;
            border-top: 1px solid rgba(255,140,0,0.5);
            border-bottom: 1px solid rgba(255,140,0,0.5);
            border-radius: var(--radius-sm);
            max-width: 400px;
            left: 50%;
            margin-left: -200px;
            position: absolute;
            width: 400px;
        }

        .debug-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* æ‰‹åŠ¿æç¤º */
        #gesture-hint {
            position: fixed;
            top: 16%;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-bright);
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: var(--radius-lg);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 140, 0, 0.3);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 40;
            text-shadow: 0 0 5px var(--planet-glow);
        }

        #gesture-hint.show {
            opacity: 1;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            :root { --ui-scale: 0.8; }
            #infoPanel, #controlPanel {
                width: 180px;
            }
            #gestureIndicator {
                width: 130px;
            }
            .top-btn {
                padding: 6px 12px;
                font-size: 9px;
            }
            #mainTitle .title-line {
                font-size: 20px;
            }
        }

        /* éšè—æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 3px; height: 3px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 2px; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 140, 0, 0.5); border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 140, 0, 0.8); }
    </style>
</head>
<body>
    <!-- 3Dç”»å¸ƒå®¹å™¨ -->
    <div id="canvasContainer"></div>

    <!-- æ‹–æ‹½æ ‡é¢˜ -->
    <div id="mainTitle">
        <h1 class="title-line">PLANET PARTICLES</h1>
        <div class="title-subline">ç‹¬ç«‹é¢—ç²’æ˜Ÿçƒ</div>
    </div>

    <!-- è¿›åº¦æŒ‡ç¤ºå™¨ -->
    <div id="progressIndicator">
        <div class="spinner"></div>
        <div class="progress-container" id="progress-container">
            <div class="progress-bar-bg">
                <div class="progress-bar" id="progress-bar-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">0%</div>
            <div class="progress-steps" id="progress-steps">
                <div class="progress-step" data-step="scene">â— åˆ›å»º3Dåœºæ™¯</div>
                <div class="progress-step" data-step="planet">â— ç”Ÿæˆæ ¸å¿ƒç²’å­</div>
                <div class="progress-step" data-step="rings">â— åˆ›å»ºæ˜Ÿç¯ç²’å­</div>
                <div class="progress-step" data-step="camera">â— æ‘„åƒå¤´åˆå§‹åŒ–</div>
                <div class="progress-step" data-step="gesture">â— æ‰‹åŠ¿è¯†åˆ«</div>
            </div>
        </div>
    </div>

    <!-- è°ƒè¯•ä¿¡æ¯ -->
    <div id="debug-info" class="loading-center">æ­£åœ¨åˆå§‹åŒ–æ˜Ÿçƒç³»ç»Ÿ...</div>

    <!-- æ‰‹åŠ¿æç¤º -->
    <div id="gesture-hint">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>

    <!-- å·¦ä¾§ä¿¡æ¯é¢æ¿ -->
    <div id="infoPanel" class="glass-panel">
        <h2>ğŸª æ˜ŸçƒçŠ¶æ€</h2>
        <div class="status-item">
            <span class="status-label">ç²’å­æ•°é‡</span>
            <span class="status-value" style="color: var(--planet-orange);">20,000</span>
        </div>
        <div class="status-item">
            <span class="status-label">é¢—ç²’å¤§å°</span>
            <span class="status-value">1.5-2.0</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç‰©ç†çŠ¶æ€</span>
            <span class="status-value" id="physicsStatus">ç‹¬ç«‹è¿åŠ¨</span>
        </div>
        <div class="status-item">
            <span class="status-label">å¸§ç‡</span>
            <span class="status-value" id="fpsCounter">0 FPS</span>
        </div>
        <div class="status-item">
            <span class="status-label">è¿æ¥çŠ¶æ€</span>
            <span class="status-value">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="gestureStatus">åˆå§‹åŒ–ä¸­...</span>
            </span>
        </div>
    </div>

    <!-- å³ä¾§æ‰‹åŠ¿æŒ‡ç¤ºå™¨ -->
    <div id="gestureIndicator" class="glass-panel">
        <h3>æ‰‹åŠ¿è¯†åˆ«</h3>
        <div class="gesture-icon" id="gestureIcon">âœ‹</div>
        <div class="gesture-name" id="gestureName">åˆå§‹åŒ–ä¸­...</div>
    </div>

    <!-- é¡¶éƒ¨æ“ä½œæŒ‰é’® -->
    <div id="topButtons">
        <button class="top-btn glass-panel" id="fs-btn" onclick="toggleFullScreen()">
            <span>â›¶</span> <span>å…¨å±</span>
        </button>
        <button class="top-btn glass-panel" id="toggle-ui-btn" onclick="toggleUI()">
            <span>ğŸ‘</span> <span>éšè—ç•Œé¢</span>
        </button>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶é¢æ¿ -->
    <div id="controlPanel" class="glass-panel">
        <div class="control-title">ç²’å­æ§åˆ¶</div>
        <button class="control-btn" id="btn-rotate" onclick="toggleAutoRotate()">ğŸŒ€ è‡ªåŠ¨æ—‹è½¬</button>
        <button class="control-btn active" id="btn-glow" onclick="toggleGlow()">âœ¨ é¢—ç²’å…‰æ•ˆ</button>
        <button class="control-btn" id="btn-camera" onclick="toggleCameraLock()">ğŸ”’ ç›¸æœºé”å®š</button>
        <button class="control-btn" onclick="cycleView()">ğŸ‘ï¸ åˆ‡æ¢è§†è§’</button>
        <button class="control-btn" onclick="resetCamera()">ğŸ”„ é‡ç½®ä½ç½®</button>
        <button class="control-btn" onclick="toggleParticles()" style="grid-column: span 2;">ğŸŒŸ åˆ‡æ¢ç²’å­å¯†åº¦</button>
    </div>

    <!-- ä¿¡æ¯æç¤º -->
    <div id="infoTooltip">ğŸ’¡ æ—‹è½¬:æŒ¥æ‰‹ | ç¼©æ”¾:æ¡æ‹³/å¼ æ‰‹ | ç‹¬ç«‹é¢—ç²’æ¸…æ™°å¯è§</div>

    <!-- çŠ¶æ€æç¤º -->
    <div id="stateToast"></div>

    <!-- Three.js - ä½¿ç”¨ unpkg ç¡®ä¿ç¨³å®šåŠ è½½ -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <!-- MediaPipe Hands - ä½¿ç”¨ unpkg ç¡®ä¿ç¨³å®šåŠ è½½ -->
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

    <script>
        // ==================== æ ¸å¿ƒé…ç½® ====================
        const CONFIG = {
            PARTICLE_COUNT: 20000,
            CORE_COUNT: 12000,
            RING_COUNT: 8000,
            PLANET_COLOR: 0xff8c00,
            RING_COLOR: 0xffffff,
            PARTICLE_SIZE: 0.04,  // è¿›ä¸€æ­¥å¤§èƒ†å‡å°é¢—ç²’å¤§å°ï¼Œæ›´åŠ ç»†å¾®
            PARTICLE_SIZE_VARIATION: 0.2,
            CAMERA: {
                FOV: 60,
                MIN_DISTANCE: 10,
                MAX_DISTANCE: 50,
                DEFAULT_DISTANCE: 22,
                ZOOM_SPEED: 0.4,
                ROTATION_SPEED: 0.015,
                LOCK_DISTANCE: 16
            },
            PHYSICS: {
                DAMPING: 0.96,      // é˜»å°¼ï¼Œæ§åˆ¶è¿åŠ¨è¡°å‡
                ATTRACTION: 0.01,   // æå°çš„å¸å¼•åŠ›ï¼Œé¿å…èšé›†
                MAX_VELOCITY: 4.0,  // é™åˆ¶æœ€å¤§é€Ÿåº¦
                SEPARATION: 0.28    // å¼ºåˆ†ç¦»åŠ›ï¼Œä¿æŒç²’å­ç‹¬ç«‹ä¸”åˆ†æ•£
            }
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let coreParticles, ringParticles;
        let corePositions, coreTargets, coreVelocities;
        let ringPositions, ringTargets, ringVelocities;
        
        // æ‰‹åŠ¿ç›¸å…³
        let cameraVideo, hands, handsObj;
        let handLandmarks = null;
        let prevHandPos = { x: 0, y: 0, z: 0 };
        let handVelocity = { x: 0, y: 0, z: 0 };
        let handSpeed = 0;
        let palmArea = 0;

        // ç›¸æœºæ§åˆ¶
        let cameraDistance = CONFIG.CAMERA.DEFAULT_DISTANCE;
        let targetCameraDistance = CONFIG.CAMERA.DEFAULT_DISTANCE;
        let cameraRotation = { x: 0, y: 0 };
        let targetCameraRotation = { x: 0, y: 0 };
        let cameraLocked = false;
        let autoRotateEnabled = false;
        let glowEnabled = true;
        let highDensityMode = true;

        // UIçŠ¶æ€
        let uiVisible = true;

        // æ€§èƒ½ç›‘æ§
        let lastFrameTime = 0;
        let frameCount = 0;
        let fpsUpdateTimer = 0;
        let fps = 0;

        // è¿›åº¦ç®¡ç†
        const progressManager = {
            totalSteps: 5,
            currentStep: 0,
            container: null,
            barFill: null,
            text: null,
            stepText: null,
            
            init() {
                this.container = document.getElementById('progress-container');
                this.barFill = document.getElementById('progress-bar-fill');
                this.text = document.getElementById('progress-text');
                this.stepText = document.getElementById('progress-steps');
                this.currentStep = 0;
                if(this.container) {
                    this.container.style.display = 'block';
                    this.update(0, 'å¼€å§‹åˆå§‹åŒ–...');
                }
            },
            
            update(step, message) {
                this.currentStep = step;
                const percentage = Math.round((step / this.totalSteps) * 100);
                
                if(this.barFill) this.barFill.style.width = percentage + '%';
                if(this.text) this.text.textContent = percentage + '%';
                if(this.stepText) {
                    const stepElements = this.stepText.querySelectorAll('.progress-step');
                    stepElements.forEach((el, index) => {
                        if (index < step) {
                            el.className = 'progress-step complete';
                        } else if (index === step) {
                            el.className = 'progress-step current';
                        } else {
                            el.className = 'progress-step';
                        }
                    });
                }
            },
            
            next(message) {
                this.currentStep++;
                this.update(this.currentStep, message);
            },
            
            complete() {
                if(this.container) {
                    this.update(this.totalSteps, 'åˆå§‹åŒ–å®Œæˆï¼');
                    setTimeout(() => {
                        this.container.style.display = 'none';
                        document.getElementById('progressIndicator').style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('progressIndicator').style.display = 'none';
                        }, 500);
                    }, 500);
                }
            }
        };

        // ==================== åˆå§‹åŒ–ç³»ç»Ÿ ====================
        function init() {
            document.getElementById('progressIndicator').style.display = 'flex';
            progressManager.init();
            updateDebugInfo('æ­£åœ¨åˆ›å»º3Dåœºæ™¯...', true);

            // 1. åˆ›å»ºåœºæ™¯
            createScene();
            progressManager.next('ç”Ÿæˆæ ¸å¿ƒç²’å­');
            updateDebugInfo('æ­£åœ¨ç”Ÿæˆ12,000æ ¸å¿ƒç²’å­...', true);

            // 2. åˆ›å»ºæ ¸å¿ƒç²’å­
            setTimeout(() => {
                createCoreParticles();
                progressManager.next('ç”Ÿæˆæ˜Ÿç¯ç²’å­');
                updateDebugInfo('æ­£åœ¨ç”Ÿæˆ8,000æ˜Ÿç¯ç²’å­...', true);

                // 3. åˆ›å»ºæ˜Ÿç¯ç²’å­
                setTimeout(() => {
                    createRingParticles();
                    progressManager.next('è¯·æ±‚æ‘„åƒå¤´æƒé™');
                    updateDebugInfo('æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...', true);

                    // 4. è¯·æ±‚æ‘„åƒå¤´æƒé™
                    setTimeout(() => {
                        initCameraAndHands();
                    }, 300);
                }, 300);
            }, 300);

            // 5. åˆå§‹åŒ–æ‹–æ‹½æ ‡é¢˜
            setTimeout(initDraggableTitle, 100);
        }

        // ==================== åœºæ™¯åˆ›å»º ====================
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            // ç§»é™¤é›¾æ•ˆï¼Œè®©ç²’å­æ›´æ¸…æ™°å¯è§
            // scene.fog = new THREE.FogExp2(0x000000, 0.008);

            camera = new THREE.PerspectiveCamera(
                CONFIG.CAMERA.FOV,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false,  // ä¸é€æ˜èƒŒæ™¯
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // ç§»é™¤è‰²è°ƒæ˜ å°„ï¼Œä¿æŒç²’å­é¢œè‰²çº¯å‡€
            // renderer.toneMapping = THREE.ACESFilmicToneMapping;
            // renderer.toneMappingExposure = 1.2;
            document.getElementById('canvasContainer').appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // æ·»åŠ ç‚¹å…‰æº
            const pointLight = new THREE.PointLight(0xff8c00, 1.5, 50);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
        }

        // ==================== ç²’å­ç³»ç»Ÿåˆ›å»º ====================
        function createCoreParticles() {
            const count = highDensityMode ? CONFIG.CORE_COUNT : Math.floor(CONFIG.CORE_COUNT / 2);
            const geometry = new THREE.BufferGeometry();
            
            corePositions = new Float32Array(count * 3);
            coreTargets = new Float32Array(count * 3);
            coreVelocities = new Float32Array(count * 3);

            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // çƒé¢åˆ†å¸ƒ
                const y = 1 - (i / (count - 1)) * 2;
                const radius2D = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;
                
                let x = Math.cos(theta) * radius2D;
                let z = Math.sin(theta) * radius2D;
                
                // å±‚æ¬¡ç»“æ„
                const layer = i / count;
                const baseRadius = 1.2 + Math.pow(layer, 0.6) * 3.5;
                
                // å¢åŠ ç²’å­é—´è·ï¼Œé¿å…é‡å 
                const spacing = 1.5;
                const finalX = x * baseRadius;
                const finalY = y * baseRadius;
                const finalZ = z * baseRadius;

                // åˆå§‹ä½ç½® - ä»ä¸­å¿ƒå‡åŒ€åˆ†å¸ƒ
                corePositions[i3] = finalX * 0.5;
                corePositions[i3 + 1] = finalY * 0.5;
                corePositions[i3 + 2] = finalZ * 0.5;
                
                coreTargets[i3] = finalX;
                coreTargets[i3 + 1] = finalY;
                coreTargets[i3 + 2] = finalZ;
                
                coreVelocities[i3] = (Math.random() - 0.5) * 0.1;
                coreVelocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
                coreVelocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(corePositions, 3));

            // åˆ›å»ºç‹¬ç«‹çš„ç²’å­æè´¨ - ä¸æ··åˆï¼Œæ¸…æ™°å¯è§
            const material = new THREE.PointsMaterial({
                color: CONFIG.PLANET_COLOR,
                size: CONFIG.PARTICLE_SIZE,
                transparent: true,
                opacity: 0.95,  // é«˜ä¸é€æ˜åº¦
                sizeAttenuation: true,
                blending: THREE.NormalBlending,  // æ™®é€šæ··åˆï¼Œå‡å°‘æ¨¡ç³Š
                depthWrite: true
            });

            coreParticles = new THREE.Points(geometry, material);
            scene.add(coreParticles);
        }

        function createRingParticles() {
            const count = highDensityMode ? CONFIG.RING_COUNT : Math.floor(CONFIG.RING_COUNT / 2);
            const geometry = new THREE.BufferGeometry();
            
            ringPositions = new Float32Array(count * 3);
            ringTargets = new Float32Array(count * 3);
            ringVelocities = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // åŒå±‚æ˜Ÿç¯
                const layer = Math.floor(i / (count / 2));
                const baseRadius = 6.0 + layer * 1.5;
                
                // èºæ—‹åˆ†å¸ƒï¼Œå¢åŠ é—´è·
                const angle = (i / count) * Math.PI * 4;
                const height = Math.sin(angle * 3) * 0.5;
                
                const x = Math.cos(angle) * baseRadius;
                const z = Math.sin(angle) * baseRadius;
                const y = height;

                // åˆå§‹ä½ç½®
                ringPositions[i3] = x * 0.8;
                ringPositions[i3 + 1] = y * 0.8;
                ringPositions[i3 + 2] = z * 0.8;
                
                ringTargets[i3] = x;
                ringTargets[i3 + 1] = y;
                ringTargets[i3 + 2] = z;
                
                ringVelocities[i3] = 0;
                ringVelocities[i3 + 1] = 0;
                ringVelocities[i3 + 2] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));

            const material = new THREE.PointsMaterial({
                color: CONFIG.RING_COLOR,
                size: CONFIG.PARTICLE_SIZE * 0.8,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true,
                blending: THREE.NormalBlending,
                depthWrite: true
            });

            ringParticles = new THREE.Points(geometry, material);
            scene.add(ringParticles);
        }

        // ==================== ç‰©ç†åŠ¨ç”» ====================
        function updatePhysics(deltaTime) {
            const dt = Math.min(deltaTime, 0.05);
            const time = Date.now() * 0.001;

            // æ›´æ–°æ ¸å¿ƒç²’å­
            if (coreParticles) {
                const count = coreParticles.geometry.attributes.position.count;
                const positions = coreParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    
                    // ç›®æ ‡ä½ç½® + å¾®å¼±è„‰åŠ¨ï¼ˆä¸æ”¹å˜å½¢çŠ¶ï¼Œåªå¢åŠ æ´»åŠ›ï¼‰
                    const pulse = Math.sin(time + i * 0.01) * 0.05;
                    const tx = coreTargets[i3] * (1 + pulse * 0.1);
                    const ty = coreTargets[i3 + 1] * (1 + pulse * 0.1);
                    const tz = coreTargets[i3 + 2] * (1 + pulse * 0.1);
                    
                    const cx = positions[i3];
                    const cy = positions[i3 + 1];
                    const cz = positions[i3 + 2];
                    
                    const dx = tx - cx;
                    const dy = ty - cy;
                    const dz = tz - cz;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    // ç‹¬ç«‹è¿åŠ¨ - æ¯é¢—ç²’å­æœ‰æ›´å¼ºçš„éšæœºæ€§
                    const independentForce = (Math.random() - 0.5) * 0.08;
                    coreVelocities[i3] += independentForce;
                    coreVelocities[i3 + 1] += independentForce * 0.8;
                    coreVelocities[i3 + 2] += independentForce * 0.6;
                    
                    // åˆ†ç¦»åŠ› - æ˜¾è‘—å¢åŠ ï¼Œé¿å…ç²’å­èšé›†
                    const separationForce = CONFIG.PHYSICS.SEPARATION;
                    coreVelocities[i3] += (Math.random() - 0.5) * separationForce;
                    coreVelocities[i3 + 1] += (Math.random() - 0.5) * separationForce;
                    coreVelocities[i3 + 2] += (Math.random() - 0.5) * separationForce;
                    
                    // æå¼±çš„å›å½’åŠ›ï¼Œä»…ç”¨äºä¿æŒæ•´ä½“å½¢çŠ¶
                    if (dist > 0.01) {
                        const weakAttraction = CONFIG.PHYSICS.ATTRACTION * 0.05;
                        coreVelocities[i3] += (dx / dist) * weakAttraction;
                        coreVelocities[i3 + 1] += (dy / dist) * weakAttraction;
                        coreVelocities[i3 + 2] += (dz / dist) * weakAttraction;
                    }
                    
                    // æ‰‹åŠ¿å½±å“
                    if (handLandmarks && handSpeed > 0.01) {
                        applyGestureForces(i3, positions, coreVelocities, 'core');
                    }
                    
                    // ç‰©ç†æ›´æ–°
                    coreVelocities[i3] *= CONFIG.PHYSICS.DAMPING;
                    coreVelocities[i3 + 1] *= CONFIG.PHYSICS.DAMPING;
                    coreVelocities[i3 + 2] *= CONFIG.PHYSICS.DAMPING;
                    
                    // é€Ÿåº¦é™åˆ¶
                    const vx = coreVelocities[i3], vy = coreVelocities[i3 + 1], vz = coreVelocities[i3 + 2];
                    const speed = Math.sqrt(vx*vx + vy*vy + vz*vz);
                    if (speed > CONFIG.PHYSICS.MAX_VELOCITY) {
                        const scale = CONFIG.PHYSICS.MAX_VELOCITY / speed;
                        coreVelocities[i3] *= scale;
                        coreVelocities[i3 + 1] *= scale;
                        coreVelocities[i3 + 2] *= scale;
                    }
                    
                    positions[i3] += coreVelocities[i3] * dt;
                    positions[i3 + 1] += coreVelocities[i3 + 1] * dt;
                    positions[i3 + 2] += coreVelocities[i3 + 2] * dt;
                }
                
                coreParticles.geometry.attributes.position.needsUpdate = true;
                
                // æ·»åŠ æ—‹è½¬
                if (autoRotateEnabled) {
                    coreParticles.rotation.y += 0.002;
                }
            }

            // æ›´æ–°æ˜Ÿç¯ç²’å­
            if (ringParticles) {
                const count = ringParticles.geometry.attributes.position.count;
                const positions = ringParticles.geometry.attributes.position.array;
                const ringTime = Date.now() * 0.0005;
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    
                    // èºæ—‹è¿åŠ¨ + è‡ªè½¬
                    const baseAngle = (i / count) * Math.PI * 4 + ringTime * 0.02;
                    const layer = Math.floor(i / (count / 2));
                    const baseRadius = 6.0 + layer * 1.5;
                    
                    const targetX = Math.cos(baseAngle) * baseRadius;
                    const targetZ = Math.sin(baseAngle) * baseRadius;
                    const targetY = Math.sin(baseAngle * 3) * 0.5;
                    
                    // å¹³æ»‘è¿‡æ¸¡
                    ringVelocities[i3] += (targetX - positions[i3]) * 0.08;
                    ringVelocities[i3 + 2] += (targetZ - positions[i3 + 2]) * 0.08;
                    ringVelocities[i3 + 1] += (targetY - positions[i3 + 1]) * 0.08;
                    
                    ringVelocities[i3] *= 0.96;
                    ringVelocities[i3 + 1] *= 0.96;
                    ringVelocities[i3 + 2] *= 0.96;
                    
                    // ç‹¬ç«‹æ‰°åŠ¨
                    ringVelocities[i3] += (Math.random() - 0.5) * 0.02;
                    ringVelocities[i3 + 1] += (Math.random() - 0.5) * 0.02;
                    ringVelocities[i3 + 2] += (Math.random() - 0.5) * 0.02;
                    
                    // æ‰‹åŠ¿å½±å“
                    if (handLandmarks && handSpeed > 0.01) {
                        applyGestureForces(i3, positions, ringVelocities, 'ring');
                    }
                    
                    positions[i3] += ringVelocities[i3] * dt;
                    positions[i3 + 1] += ringVelocities[i3 + 1] * dt;
                    positions[i3 + 2] += ringVelocities[i3 + 2] * dt;
                }
                
                ringParticles.geometry.attributes.position.needsUpdate = true;
                
                // æ·»åŠ æ—‹è½¬
                if (autoRotateEnabled) {
                    ringParticles.rotation.y += 0.003;
                }
            }
        }

        // ==================== æ‰‹åŠ¿äº¤äº’åŠ› ====================
        function applyGestureForces(i3, positions, velocities, type) {
            if (!handLandmarks) return;
            
            const handCenter = handLandmarks[9];
            const handX = (handCenter.x - 0.5) * 8;
            const handY = -(handCenter.y - 0.5) * 6;
            const handZ = (handCenter.z + 0.5) * 4;
            
            const cx = positions[i3];
            const cy = positions[i3 + 1];
            const cz = positions[i3 + 2];
            
            const dx = cx - handX;
            const dy = cy - handY;
            const dz = cz - handZ;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if (dist < 8.0) {
                const force = handSpeed * 0.5 * Math.max(0, 1 - dist / 8);
                if (force > 0.02) {
                    // ç›´æ¥æ¨åŠ¨ç²’å­ï¼Œå¢åŠ å†²å‡»æ„Ÿ
                    velocities[i3] += (dx / dist) * force * 2;
                    velocities[i3 + 1] += (dy / dist) * force * 2;
                    velocities[i3 + 2] += (dz / dist) * force * 2;
                }
                
                // æ·±åº¦æ¨æ‹‰
                if (palmArea > 0.03) {
                    const depthForce = (palmArea - 0.03) * 10;
                    velocities[i3 + 2] += depthForce * 0.1;
                }
            }
        }

        // ==================== ç›¸æœºæ§åˆ¶ ====================
        function updateCameraPosition() {
            cameraDistance += (targetCameraDistance - cameraDistance) * 0.1;
            cameraRotation.x += (targetCameraRotation.x - cameraRotation.x) * 0.1;
            cameraRotation.y += (targetCameraRotation.y - cameraRotation.y) * 0.1;

            if (autoRotateEnabled && !cameraLocked) {
                targetCameraRotation.y += CONFIG.CAMERA.ROTATION_SPEED;
            }

            const x = Math.sin(cameraRotation.y) * cameraDistance;
            const z = Math.cos(cameraRotation.y) * cameraDistance;
            const y = Math.sin(cameraRotation.x) * cameraDistance * 0.4;

            camera.position.set(x, y + 3, z);
            camera.lookAt(0, 0, 0);
        }

        // ==================== æ‰‹åŠ¿è¯†åˆ« ====================
        async function initCameraAndHands() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    startAutoMode('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´');
                    return;
                }

                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    startAutoMode('éœ€è¦HTTPSç¯å¢ƒ');
                    return;
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user' 
                    }
                });

                cameraVideo = document.createElement('video');
                cameraVideo.style.display = 'none';
                cameraVideo.setAttribute('playsinline', true);
                cameraVideo.muted = true;
                document.body.appendChild(cameraVideo);
                cameraVideo.srcObject = stream;

                await new Promise(resolve => {
                    cameraVideo.onloadedmetadata = resolve;
                });

                cameraVideo.play();

                progressManager.next('åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«');
                updateDebugInfo('æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...', true);

                hands = new Hands({
                    locateFile: (file) => {
                        return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    selfieMode: true
                });

                hands.onResults(onHandResults);

                handsObj = new Camera(cameraVideo, {
                    onFrame: async () => {
                        await hands.send({ image: cameraVideo });
                    },
                    width: 1280,
                    height: 720
                });

                handsObj.start();

                updateStatus('æ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª', true);
                progressManager.complete();
                updateDebugInfo('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', false);

                // æ˜¾ç¤ºæ‰‹åŠ¿æç¤º
                setTimeout(() => {
                    const hint = document.getElementById('gesture-hint');
                    if(hint) hint.classList.add('show');
                    setTimeout(() => hint.classList.remove('show'), 4000);
                }, 1000);

            } catch (error) {
                console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                startAutoMode('æ‘„åƒå¤´è®¿é—®å¤±è´¥');
            }
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks[0];
                updateHandMetrics();
                detectGesture();
            } else {
                handLandmarks = null;
                handSpeed = 0;
                palmArea = 0;
                updateGestureDisplay(null);
            }
        }

        function updateHandMetrics() {
            if (!handLandmarks) return;

            const center = handLandmarks[9];
            const currentX = (center.x - 0.5) * 8;
            const currentY = -(center.y - 0.5) * 6;
            const currentZ = (center.z + 0.5) * 4;

            if (prevHandPos.x !== 0) {
                const dx = currentX - prevHandPos.x;
                const dy = currentY - prevHandPos.y;
                const dz = currentZ - prevHandPos.z;
                
                handVelocity.x = dx;
                handVelocity.y = dy;
                handVelocity.z = dz;
                
                handSpeed = Math.sqrt(dx*dx + dy*dy + dz*dz);

                // æ—‹è½¬æ§åˆ¶
                if (handSpeed > 0.02 && !cameraLocked) {
                    targetCameraRotation.y += dx * CONFIG.CAMERA.ROTATION_SPEED * 8;
                    targetCameraRotation.x += dy * CONFIG.CAMERA.ROTATION_SPEED * 4;
                    targetCameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetCameraRotation.x));
                }
            }

            // æ‰‹æŒé¢ç§¯è®¡ç®—
            const thumbBase = handLandmarks[2];
            const pinkyBase = handLandmarks[17];
            palmArea = Math.sqrt(
                Math.pow(thumbBase.x - pinkyBase.x, 2) + 
                Math.pow(thumbBase.y - pinkyBase.y, 2)
            );

            prevHandPos.x = currentX;
            prevHandPos.y = currentY;
            prevHandPos.z = currentZ;
        }

        function detectGesture() {
            if (!handLandmarks) return;

            const landmarks = handLandmarks;
            
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];

            const dist = (p1, p2) => Math.sqrt(
                Math.pow(p1.x - p2.x, 2) + 
                Math.pow(p1.y - p2.y, 2) + 
                Math.pow(p1.z - p2.z, 2)
            );

            const thumbDist = dist(thumbTip, wrist);
            const indexDist = dist(indexTip, wrist);
            const middleDist = dist(middleTip, wrist);
            const ringDist = dist(ringTip, wrist);
            const pinkyDist = dist(pinkyTip, wrist);

            let detectedGesture = null;

            // æ¡æ‹³ - ç¼©å°
            if (thumbDist < 0.08 && indexDist < 0.08 && middleDist < 0.08 && 
                ringDist < 0.08 && pinkyDist < 0.08) {
                detectedGesture = 'fist';
                if (!cameraLocked) {
                    targetCameraDistance = Math.max(CONFIG.CAMERA.MIN_DISTANCE, targetCameraDistance - CONFIG.CAMERA.ZOOM_SPEED * 3);
                }
            }
            // å¼ æ‰‹ - æ”¾å¤§
            else if (thumbDist > 0.1 && indexDist > 0.1 && middleDist > 0.1 && 
                     ringDist > 0.1 && pinkyDist > 0.1) {
                detectedGesture = 'open';
                if (!cameraLocked) {
                    targetCameraDistance = Math.min(CONFIG.CAMERA.MAX_DISTANCE, targetCameraDistance + CONFIG.CAMERA.ZOOM_SPEED * 3);
                }
            }

            updateGestureDisplay(detectedGesture);
        }

        // ==================== è‡ªåŠ¨æ¨¡å¼ ====================
        function startAutoMode(reason) {
            console.log('å¯åŠ¨è‡ªåŠ¨æ¨¡å¼:', reason);
            updateStatus('è‡ªåŠ¨æ¨¡å¼ - ' + reason, false);
            progressManager.complete();
            updateDebugInfo('è‡ªåŠ¨æ¨¡å¼å·²å¯åŠ¨', false);

            const autoCycle = () => {
                if (handLandmarks) return;
                
                if (!cameraLocked) {
                    const randomDistance = CONFIG.CAMERA.MIN_DISTANCE + 
                        Math.random() * (CONFIG.CAMERA.MAX_DISTANCE - CONFIG.CAMERA.MIN_DISTANCE);
                    targetCameraDistance = randomDistance;
                    
                    targetCameraRotation.y += Math.random() * Math.PI * 2;
                    targetCameraRotation.x += Math.random() * 0.5 - 0.25;
                    targetCameraRotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetCameraRotation.x));
                }
            };

            setInterval(autoCycle, 8000);
            setTimeout(autoCycle, 2000);
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            if (coreParticles || ringParticles) {
                updatePhysics(deltaTime);
            }
            
            updateCameraPosition();
            renderer.render(scene, camera);
            updateFPS(now);
        }

        // ==================== UI æ›´æ–° ====================
        function updateStatus(text, active) {
            const statusEl = document.getElementById('gestureStatus');
            const indicator = document.getElementById('statusIndicator');

            if (statusEl) {
                statusEl.textContent = text;
                statusEl.style.color = active ? '#00ff00' : '#ffaa00';
            }

            if (indicator) {
                indicator.className = active ? 'status-indicator active' : 'status-indicator';
            }
        }

        function updateGestureDisplay(gesture) {
            const iconEl = document.getElementById('gestureIcon');
            const nameEl = document.getElementById('gestureName');

            if (!gesture) {
                iconEl.textContent = 'âœ‹';
                nameEl.textContent = 'ç­‰å¾…æ‰‹åŠ¿...';
                return;
            }

            const gestureInfo = {
                'fist': { icon: 'âœŠ', name: 'æ¡æ‹³ç¼©å°' },
                'open': { icon: 'âœ‹', name: 'å¼ æ‰‹æ”¾å¤§' }
            };

            const info = gestureInfo[gesture];
            if (info) {
                iconEl.textContent = info.icon;
                nameEl.textContent = info.name;
            }
        }

        function updateFPS(now) {
            frameCount++;
            
            if (now - fpsUpdateTimer >= 1000) {
                fps = Math.round((frameCount * 1000) / (now - fpsUpdateTimer));
                const fpsEl = document.getElementById('fpsCounter');
                if (fpsEl) {
                    fpsEl.textContent = `${fps} FPS`;
                    fpsEl.style.color = fps >= 50 ? '#00ff00' : fps >= 30 ? '#ffff00' : '#ff0000';
                }
                frameCount = 0;
                fpsUpdateTimer = now;
            }
        }

        function updateDebugInfo(text, showLoader) {
            const debug = document.getElementById('debug-info');
            if (debug) {
                debug.textContent = text;
                if (showLoader) {
                    debug.classList.add('loading-center');
                    debug.classList.remove('debug-hidden');
                } else {
                    debug.classList.remove('loading-center');
                    setTimeout(() => {
                        debug.classList.add('debug-hidden');
                    }, 2000);
                }
            }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('stateToast');
            toast.textContent = message;
            toast.className = isError ? 'error show' : 'show';
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // ==================== çª—å£è°ƒæ•´ ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== UI æ§åˆ¶å‡½æ•° ====================
        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    showToast('è¿›å…¥å…¨å±æ¨¡å¼');
                }).catch(() => {
                    showToast('å…¨å±è¯·æ±‚å¤±è´¥', true);
                });
            } else {
                document.exitFullscreen().then(() => {
                    showToast('é€€å‡ºå…¨å±æ¨¡å¼');
                });
            }
        };

        window.toggleUI = function() {
            uiVisible = !uiVisible;
            const elements = [
                'infoPanel', 'gestureIndicator', 'topButtons', 
                'controlPanel', 'infoTooltip', 'mainTitle'
            ];
            
            elements.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    if (!uiVisible) {
                        el.classList.add('panel-hidden');
                    } else {
                        el.classList.remove('panel-hidden');
                    }
                }
            });
            
            showToast(uiVisible ? 'UIæ˜¾ç¤º' : 'UIéšè—');
        };

        window.toggleAutoRotate = function() {
            autoRotateEnabled = !autoRotateEnabled;
            const btn = document.getElementById('btn-rotate');
            if (autoRotateEnabled) {
                btn.classList.add('active');
                showToast('è‡ªåŠ¨æ—‹è½¬å·²å¼€å¯');
            } else {
                btn.classList.remove('active');
                showToast('è‡ªåŠ¨æ—‹è½¬å·²å…³é—­');
            }
        };

        window.toggleGlow = function() {
            glowEnabled = !glowEnabled;
            const btn = document.getElementById('btn-glow');
            if (glowEnabled) {
                btn.classList.add('active');
                if (coreParticles) coreParticles.material.opacity = 0.95;
                if (ringParticles) ringParticles.material.opacity = 0.9;
                showToast('é¢—ç²’å…‰æ•ˆå·²å¢å¼º');
            } else {
                btn.classList.remove('active');
                if (coreParticles) coreParticles.material.opacity = 0.6;
                if (ringParticles) ringParticles.material.opacity = 0.5;
                showToast('é¢—ç²’å…‰æ•ˆå·²å‡å¼±');
            }
        };

        window.toggleCameraLock = function() {
            cameraLocked = !cameraLocked;
            const btn = document.getElementById('btn-camera');
            if (cameraLocked) {
                btn.classList.add('active');
                targetCameraDistance = CONFIG.CAMERA.LOCK_DISTANCE;
                showToast('ç›¸æœºå·²é”å®š');
            } else {
                btn.classList.remove('active');
                showToast('ç›¸æœºå·²è§£é”');
            }
        };

        window.resetCamera = function() {
            targetCameraDistance = CONFIG.CAMERA.DEFAULT_DISTANCE;
            targetCameraRotation = { x: 0, y: 0 };
            cameraLocked = false;
            autoRotateEnabled = false;
            document.getElementById('btn-camera').classList.remove('active');
            document.getElementById('btn-rotate').classList.remove('active');
            showToast('ä½ç½®å·²é‡ç½®');
        };

        window.cycleView = function() {
            currentView = (currentView + 1) % 4;
            const views = [
                { dist: 22, rot: { x: 0, y: 0 }, name: 'æ ‡å‡†è§†å›¾' },
                { dist: 18, rot: { x: 0, y: Math.PI / 2 }, name: 'ä¾§é¢è§†å›¾' },
                { dist: 28, rot: { x: -0.3, y: Math.PI }, name: 'é¡¶éƒ¨è§†å›¾' },
                { dist: 14, rot: { x: 0.2, y: Math.PI * 1.5 }, name: 'ç‰¹å†™è§†å›¾' }
            ];
            
            const view = views[currentView];
            targetCameraDistance = view.dist;
            targetCameraRotation = view.rot;
            showToast(view.name);
        };

        window.toggleParticles = function() {
            highDensityMode = !highDensityMode;
            const physicsStatus = document.getElementById('physicsStatus');
            
            if (highDensityMode) {
                physicsStatus.textContent = 'é«˜å¯†åº¦';
                showToast('åˆ‡æ¢ä¸ºé«˜å¯†åº¦æ¨¡å¼');
            } else {
                physicsStatus.textContent = 'æ ‡å‡†å¯†åº¦';
                showToast('åˆ‡æ¢ä¸ºæ ‡å‡†å¯†åº¦');
            }
            
            // é‡æ–°åˆ›å»ºç²’å­ç³»ç»Ÿ
            if (coreParticles) {
                scene.remove(coreParticles);
                coreParticles.geometry.dispose();
                coreParticles.material.dispose();
                coreParticles = null;
            }
            if (ringParticles) {
                scene.remove(ringParticles);
                ringParticles.geometry.dispose();
                ringParticles.material.dispose();
                ringParticles = null;
            }
            
            createCoreParticles();
            createRingParticles();
        };

        // ==================== æ‹–æ‹½æ ‡é¢˜åŠŸèƒ½ ====================
        function initDraggableTitle() {
            const title = document.getElementById('mainTitle');
            let isDragging = false;
            let offset = { x: 0, y: 0 };

            title.addEventListener('mousedown', (e) => {
                isDragging = true;
                const rect = title.getBoundingClientRect();
                offset.x = e.clientX - rect.left;
                offset.y = e.clientY - rect.top;
                title.style.cursor = 'grabbing';
                title.style.transform = 'none';
                title.style.left = rect.left + 'px';
                title.style.top = rect.top + 'px';
                e.preventDefault();
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const x = e.clientX - offset.x;
                const y = e.clientY - offset.y;
                title.style.left = x + 'px';
                title.style.top = y + 'px';
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                title.style.cursor = 'move';
            });

            // ç§»åŠ¨ç«¯æ”¯æŒ
            title.addEventListener('touchstart', (e) => {
                isDragging = true;
                const touch = e.touches[0];
                const rect = title.getBoundingClientRect();
                offset.x = touch.clientX - rect.left;
                offset.y = touch.clientY - rect.top;
                title.style.transform = 'none';
                title.style.left = rect.left + 'px';
                title.style.top = rect.top + 'px';
                e.preventDefault();
            });

            window.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const x = touch.clientX - offset.x;
                const y = touch.clientY - offset.y;
                title.style.left = x + 'px';
                title.style.top = y + 'px';
            });

            window.addEventListener('touchend', () => {
                isDragging = false;
            });
        }

        // ==================== é”®ç›˜å¿«æ·é”® ====================
        function initKeyboardShortcuts() {
            window.addEventListener('keydown', (e) => {
                // é˜²æ­¢åœ¨è¾“å…¥æ¡†ä¸­è§¦å‘
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.key.toLowerCase()) {
                    case 'f':
                        e.preventDefault();
                        toggleFullScreen();
                        break;
                    case 'h':
                        e.preventDefault();
                        toggleUI();
                        break;
                    case 'r':
                        e.preventDefault();
                        toggleAutoRotate();
                        break;
                    case 'g':
                        e.preventDefault();
                        toggleGlow();
                        break;
                    case 'c':
                        e.preventDefault();
                        toggleCameraLock();
                        break;
                    case 'v':
                        e.preventDefault();
                        cycleView();
                        break;
                    case 'p':
                        e.preventDefault();
                        toggleParticles();
                        break;
                    case ' ':
                        e.preventDefault();
                        resetCamera();
                        break;
                }
            });
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('load', () => {
            init();
            initKeyboardShortcuts();
            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            setTimeout(() => {
                animate();
            }, 100);
        });
    </script>
</body>
</html>
