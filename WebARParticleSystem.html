<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR ç²’å­äº’åŠ¨ç³»ç»Ÿ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background-color: #000;
        }
        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #infoPanel {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: cyan;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>
    <div id="infoPanel">
        <div>æ‰‹åŠ¿çŠ¶æ€: <span id="gestureStatus">åˆå§‹åŒ–ä¸­...</span></div>
        <div>ç²’å­æ•°é‡: 16000</div>
        <div>å¸§ç‡: <span id="fpsCounter">0</span> FPS</div>
    </div>
    <div id="loadingIndicator">æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...</div>

    <!-- å¼•å…¥ Three.js å’Œç›¸å…³åº“ -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- å¼•å…¥ MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1675469240/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let particles;
        let particlePositions, particleVelocities, particleAccelerations;
        let particleGeometry, particleMaterial;
        const PARTICLE_COUNT = 8000;
        const PARTICLE_SIZE = 3.0;
        
        // æ‰‹åŠ¿ç›¸å…³
        let cameraVideo = null;
        let hands = null;
        let currentGesture = 'open';
        
        // ç‰©ç†å‚æ•°
        const accelerationFactor = 0.02;
        const dampingFactor = 0.95;
        const explosionForce = 2.0;
        
        // æ‰‹éƒ¨è¿½è¸ªæ•°æ®
        let handLandmarks = null;
        let handVelocity = { x: 0, y: 0, z: 0 };
        let prevHandPosition = { x: 0, y: 0, z: 0 };
        let handSpeed = 0;
        let palmSize = 0;
        
        // å½¢çŠ¶ç›®æ ‡ç‚¹
        let targetPositions = [];
        let textShapePoints = [];
        
        // æ€§èƒ½ç›‘æ§
        let lastFrameTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // è‡ªåŠ¨å½¢çŠ¶åˆ‡æ¢
        let autoShapeTimer = 0;
        const AUTO_SHAPE_INTERVAL = 5000;
        const shapes = ['open', 'scissors', 'fist', 'point', 'thumbsUp'];
        let currentShapeIndex = 0;
        
        // åˆå§‹åŒ–å½“å‰å½¢çŠ¶ç´¢å¼•
        currentShapeIndex = shapes.indexOf(currentGesture);
        
        // FPSæ ·æœ¬
        let frameTimeSamples = [];
        const MAX_SAMPLES = 60;
        
        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvasContainer').appendChild(renderer.domElement);
            
            // åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
            initParticles();
            
            // åˆ›å»ºæ–‡å­—å½¢çŠ¶ç‚¹
            createTextShapePoints();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            window.addEventListener('resize', onWindowResize);
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // è¯·æ±‚æ‘„åƒå¤´æƒé™
            setTimeout(() => {
                requestCameraPermission();
            }, 1500);
        }
        
        // åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
        function initParticles() {
            // åˆ›å»ºå‡ ä½•ä½“
            particleGeometry = new THREE.BufferGeometry();
            
            // åˆ›å»ºç²’å­ä½ç½®ã€é€Ÿåº¦å’ŒåŠ é€Ÿåº¦æ•°ç»„
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            particleAccelerations = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            
            // åˆå§‹åŒ–ç²’å­ä½ç½®ä¸ºçƒå½¢åˆ†å¸ƒ
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // åˆå§‹ä½ç½®è®¾ä¸ºçƒå½¢åˆ†å¸ƒ
                const radius = 1.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                particlePositions[i3] = x;
                particlePositions[i3 + 1] = y;
                particlePositions[i3 + 2] = z;
                
                // ç›®æ ‡ä½ç½®åˆå§‹ä¹Ÿä¸ºçƒå½¢
                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
                
                // åˆå§‹åŒ–é€Ÿåº¦å’ŒåŠ é€Ÿåº¦ä¸º0
                particleVelocities[i3] = 0;
                particleVelocities[i3 + 1] = 0;
                particleVelocities[i3 + 2] = 0;
                particleAccelerations[i3] = 0;
                particleAccelerations[i3 + 1] = 0;
                particleAccelerations[i3 + 2] = 0;
            }
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            // åˆ›å»ºæè´¨
            particleMaterial = new THREE.PointsMaterial({
                color: 0x00FFFF, // é’è‰²
                size: PARTICLE_SIZE,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }
        
        // åˆ›å»ºæ–‡å­—å½¢çŠ¶ç‚¹ ("æˆ‘æ˜¯ Mok")
        function createTextShapePoints() {
            // è¿™é‡Œæˆ‘ä»¬æ¨¡æ‹Ÿä¸€äº›æ–‡å­—å½¢çŠ¶çš„ç‚¹
            // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥ä½¿ç”¨Canvasæµ‹é‡æ–‡å­—å¹¶è·å–ç‚¹é˜µ
            
            // ä¸ºæ¼”ç¤ºç›®çš„ï¼Œæˆ‘ä»¬åˆ›å»ºå‡ ä¸ªå­—æ¯çš„ç®€å•è¡¨ç¤º
            textShapePoints = [];
            
            // åˆ›å»º"M"å½¢çŠ¶çš„ç‚¹
            for (let i = 0; i < 3000; i++) {
                const t = i / 3000;
                const x = (t - 0.5) * 4 - 1.5;
                const y = Math.abs(Math.sin(t * Math.PI * 2)) * 2 - 1;
                const z = (Math.random() - 0.5) * 0.5;
                textShapePoints.push(x, y, z);
            }
            
            // åˆ›å»º"o"å½¢çŠ¶çš„ç‚¹
            for (let i = 0; i < 2000; i++) {
                const angle = (i / 2000) * Math.PI * 2;
                const radius = 0.5;
                const x = Math.cos(angle) + 0.5;
                const y = Math.sin(angle);
                const z = (Math.random() - 0.5) * 0.5;
                textShapePoints.push(x, y, z);
            }
            
            // åˆ›å»º"k"å½¢çŠ¶çš„ç‚¹
            for (let i = 0; i < 3000; i++) {
                const t = i / 3000;
                let x, y, z;
                
                if (i < 1500) {
                    // ç«–çº¿
                    x = 1.5;
                    y = (t * 2 - 0.5) * 2;
                    z = (Math.random() - 0.5) * 0.5;
                } else {
                    // æ–œçº¿
                    const t2 = (t - 0.5) * 2;
                    x = 1.5 + t2 * 1.5;
                    y = -t2 * 1.5;
                    z = (Math.random() - 0.5) * 0.5;
                }
                
                textShapePoints.push(x, y, z);
            }
            
            // è¡¥å……åˆ°16000ä¸ªç‚¹
            while (textShapePoints.length < PARTICLE_COUNT * 3) {
                textShapePoints.push(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 0.5
                );
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦åœ¨å®‰å…¨ä¸Šä¸‹æ–‡ä¸­è¿è¡Œï¼ˆHTTPSï¼‰
        function checkSecureContext() {
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                document.getElementById('gestureStatus').textContent = 'âš ï¸ éœ€è¦HTTPSç¯å¢ƒ';
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('loadingIndicator').innerHTML = `
                    <div style="text-align: center; max-width: 80vw;">
                        <h3>ğŸ”’ å®‰å…¨è¦æ±‚</h3>
                        <p>æ­¤åº”ç”¨éœ€è¦åœ¨HTTPSç¯å¢ƒä¸‹è¿è¡Œæ‰èƒ½è®¿é—®æ‘„åƒå¤´ã€‚</p>
                        <p>è¯·åœ¨æœ¬åœ°æœåŠ¡å™¨ä¸Šè¿è¡Œæˆ–ä½¿ç”¨HTTPSè®¿é—®ã€‚</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">ğŸ”„ åˆ·æ–°é¡µé¢</button>
                    </div>
                `;
                console.error('æ‘„åƒå¤´è®¿é—®éœ€è¦å®‰å…¨ä¸Šä¸‹æ–‡ï¼ˆHTTPSï¼‰');
                return false;
            }
            return true;
        }
        
        // æ£€æŸ¥MediaPipeåº“æ˜¯å¦å¯ç”¨
        function checkMediaPipeLibraries() {
            return (typeof window.Hands !== 'undefined') && (typeof window.Camera !== 'undefined');
        }
        
        // ç­‰å¾…MediaPipeåº“åŠ è½½å®Œæˆ
        function waitForMediaPipeLibraries() {
            return new Promise((resolve) => {
                let attempts = 0;
                const maxAttempts = 100; // æœ€å¤šç­‰å¾…10ç§’
                
                const check = () => {
                    attempts++;
                    if (checkMediaPipeLibraries() || attempts >= maxAttempts) {
                        resolve();
                    } else {
                        setTimeout(check, 100);
                    }
                };
                
                check();
            });
        }
        
        // è¯·æ±‚æ‘„åƒå¤´æƒé™
        async function requestCameraPermission() {
            // æ£€æŸ¥å®‰å…¨ä¸Šä¸‹æ–‡
            if (!checkSecureContext()) return;
            
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´åŠŸèƒ½');
                return;
            }
            
            // ç­‰å¾…MediaPipeåº“åŠ è½½
            await waitForMediaPipeLibraries();
            
            // è¯·æ±‚æ‘„åƒå¤´
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user' } 
                });
                
                document.getElementById('loadingIndicator').style.display = 'none';
                
                // å°è¯•åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
                if (checkMediaPipeLibraries()) {
                    await initHandsDetection(stream);
                    document.getElementById('gestureStatus').textContent = 'æ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª';
                } else {
                    // åŸºç¡€æ¨¡å¼
                    initBasicCameraDisplay(stream);
                    document.getElementById('gestureStatus').textContent = 'æ‘„åƒå¤´å·²è¿æ¥ï¼ˆåŸºç¡€æ¨¡å¼ï¼‰';
                }
                
            } catch (error) {
                showError('æ— æ³•è®¿é—®æ‘„åƒå¤´: ' + error.message);
            }
        }
        
        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            document.getElementById('gestureStatus').textContent = 'é”™è¯¯: ' + message;
            document.getElementById('loadingIndicator').style.display = 'block';
            document.getElementById('loadingIndicator').innerHTML = `
                <div style="text-align: center; max-width: 80vw;">
                    <h3>âš ï¸ é”™è¯¯</h3>
                    <p>${message}</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">ğŸ”„ åˆ·æ–°é¡µé¢</button>
                </div>
            `;
        }
        
        // è¯·æ±‚åŸºæœ¬æ‘„åƒå¤´è®¿é—®ï¼ˆæ— æ‰‹åŠ¿è¯†åˆ«ï¼‰
        function requestBasicCameraAccess() {
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } })
                .then(stream => {
                    document.getElementById('gestureStatus').textContent = 'æ‘„åƒå¤´å·²è¿æ¥ï¼ˆåŸºç¡€æ¨¡å¼ï¼‰';
                    document.getElementById('loadingIndicator').style.display = 'none';
                    initBasicCameraDisplay(stream);
                })
                .catch(error => {
                    showError('æ— æ³•è®¿é—®æ‘„åƒå¤´: ' + error.message);
                });
        }
        
        // åˆå§‹åŒ–åŸºæœ¬æ‘„åƒå¤´æ˜¾ç¤º
        function initBasicCameraDisplay(stream) {
            // åˆ›å»ºè§†é¢‘å…ƒç´ 
            const video = document.createElement('video');
            video.style.position = 'fixed';
            video.style.top = '0';
            video.style.left = '0';
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.objectFit = 'cover';
            video.style.zIndex = '0';
            video.setAttribute('playsinline', true);
            video.muted = true;
            document.body.appendChild(video);
            
            // ç»‘å®šè§†é¢‘æµ
            video.srcObject = stream;
            video.play();
        }
        
        // åˆå§‹åŒ–æ‰‹åŠ¿æ£€æµ‹
        async function initHandsDetection(stream) {
            // åˆ›å»ºè§†é¢‘å…ƒç´ 
            cameraVideo = document.createElement('video');
            cameraVideo.style.display = 'none';
            cameraVideo.setAttribute('playsinline', true);
            cameraVideo.muted = true;
            document.body.appendChild(cameraVideo);
            
            cameraVideo.srcObject = stream;
            
            // ç­‰å¾…è§†é¢‘å…ƒæ•°æ®åŠ è½½
            await new Promise((resolve) => {
                cameraVideo.onloadedmetadata = resolve;
            });
            
            // åˆå§‹åŒ–Hands
            const hands = new window.Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1675469240/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
                selfieMode: true
            });
            
            hands.onResults(onHandsResults);
            
            // åˆå§‹åŒ–æ‘„åƒå¤´
            const camera = new window.Camera(cameraVideo, {
                onFrame: async () => {
                    await hands.send({image: cameraVideo});
                },
                width: 1280,
                height: 720
            });
            
            camera.start();
        }
        
        // å¤„ç†æ‰‹åŠ¿æ£€æµ‹ç»“æœ
        function onHandsResults(results) {
            try {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handLandmarks = results.multiHandLandmarks[0];
                    detectGesture();
                    calculateHandMetrics();
                } else {
                    handLandmarks = null;
                    handSpeed = 0;
                    palmSize = 0;
                }
            } catch (error) {
                console.error('å¤„ç†æ‰‹åŠ¿ç»“æœæ—¶å‡ºé”™:', error);
                // å‡ºé”™æ—¶ä¿æŒä¹‹å‰çš„çŠ¶æ€
            }
        }
        
        // æ‰‹åŠ¿è¯†åˆ«
        function detectGesture() {
            if (!handLandmarks) return;
            
            // è®¡ç®—å…³é”®ç‚¹è·ç¦»ç”¨äºæ‰‹åŠ¿è¯†åˆ«
            const thumbTip = handLandmarks[4];
            const indexTip = handLandmarks[8];
            const middleTip = handLandmarks[12];
            const ringTip = handLandmarks[16];
            const pinkyTip = handLandmarks[20];
            
            const wrist = handLandmarks[0];
            
            // è®¡ç®—æ‰‹æŒ‡ä¼¸å±•ç¨‹åº¦
            const thumbDistance = distance(thumbTip, wrist);
            const indexDistance = distance(indexTip, wrist);
            const middleDistance = distance(middleTip, wrist);
            const ringDistance = distance(ringTip, wrist);
            const pinkyDistance = distance(pinkyTip, wrist);
            
            // è®¡ç®—æ‰‹æŒ‡é—´çš„è·ç¦»
            const thumbIndexDist = distance(thumbTip, indexTip);
            const indexMiddleDist = distance(indexTip, middleTip);
            
            // è¯†åˆ«æ‰‹åŠ¿
            if (thumbIndexDist > 0.1 && indexMiddleDist > 0.1 && 
                indexDistance > middleDistance && indexDistance > ringDistance && indexDistance > pinkyDistance &&
                thumbDistance > 0.3) {
                // é£ŸæŒ‡æ‰‹åŠ¿ï¼ˆå…¶ä»–æ‰‹æŒ‡å¼¯æ›²ï¼Œåªæœ‰é£ŸæŒ‡ä¼¸å‡ºï¼‰
                setGesture('point');
            } else if (thumbIndexDist < 0.08 && Math.abs(indexMiddleDist - 0.15) < 0.05) {
                // å‰ªåˆ€æ‰‹æ‰‹åŠ¿ï¼ˆé£ŸæŒ‡å’Œä¸­æŒ‡åˆ†å¼€ï¼‰
                setGesture('scissors');
            } else if (thumbDistance < 0.08 && indexDistance < 0.08 && 
                       middleDistance < 0.08 && ringDistance < 0.08 && pinkyDistance < 0.08) {
                // æ¡æ‹³æ‰‹åŠ¿ï¼ˆæ‰€æœ‰æ‰‹æŒ‡å¼¯æ›²ï¼‰
                setGesture('fist');
            } else if (thumbDistance > 0.1 && indexDistance > 0.1 && 
                       middleDistance > 0.1 && ringDistance > 0.1 && pinkyDistance > 0.1 &&
                       thumbIndexDist > 0.1) {
                // å¼ æ‰‹æ‰‹åŠ¿ï¼ˆæ‰€æœ‰æ‰‹æŒ‡ä¼¸å¼€ï¼‰
                setGesture('open');
            } else if (thumbDistance > 0.15 && indexDistance < 0.1 && 
                       middleDistance < 0.1 && ringDistance < 0.1 && pinkyDistance < 0.1) {
                // ç«–å¤§æ‹‡æŒ‡æ‰‹åŠ¿
                setGesture('thumbsUp');
            }
        }
        
        // è®¾ç½®æ‰‹åŠ¿å¹¶å¤„ç†è½¬æ¢
        function setGesture(gesture) {
            if (currentGesture !== gesture) {
                lastGesture = currentGesture;
                currentGesture = gesture;
                gestureTransitionTime = 0;
                
                // æ›´æ–°UI
                document.getElementById('gestureStatus').textContent = getGestureName(gesture);
                
                // è§¦å‘çˆ†ç‚¸æ•ˆæœ
                triggerExplosion();
            }
        }
        
        // è·å–æ‰‹åŠ¿åç§°
        function getGestureName(gesture) {
            switch(gesture) {
                case 'open': return 'å¼ æ‰‹';
                case 'scissors': return 'å‰ªåˆ€æ‰‹';
                case 'fist': return 'æ¡æ‹³';
                case 'point': return 'é£ŸæŒ‡';
                case 'thumbsUp': return 'ç«–å¤§æ‹‡æŒ‡';
                default: return gesture;
            }
        }
        
        // è§¦å‘çˆ†ç‚¸æ•ˆæœ
        function triggerExplosion() {
            if (!particleVelocities) return;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // ç»™æ¯ä¸ªç²’å­æ·»åŠ éšæœºæ–¹å‘çš„çˆ†ç‚¸åŠ›
                particleVelocities[i3] += (Math.random() - 0.5) * explosionForce;
                particleVelocities[i3 + 1] += (Math.random() - 0.5) * explosionForce;
                particleVelocities[i3 + 2] += (Math.random() - 0.5) * explosionForce;
            }
        }
        
        // è®¡ç®—æ‰‹éƒ¨æŒ‡æ ‡
        function calculateHandMetrics() {
            if (!handLandmarks) return;
            
            // è®¡ç®—æ‰‹æŒå¤§å°ï¼ˆé€šè¿‡æ‹‡æŒ‡å’Œå°æŒ‡æ ¹éƒ¨çš„è·ç¦»ï¼‰
            const thumbBase = handLandmarks[2];
            const pinkyBase = handLandmarks[17];
            palmSize = distance(thumbBase, pinkyBase);
            
            // è®¡ç®—æ‰‹éƒ¨ä¸­å¿ƒä½ç½®
            const centerX = (handLandmarks[0].x + handLandmarks[9].x) / 2;
            const centerY = (handLandmarks[0].y + handLandmarks[9].y) / 2;
            const centerZ = (handLandmarks[0].z + handLandmarks[9].z) / 2;
            
            // è®¡ç®—æ‰‹éƒ¨é€Ÿåº¦
            const deltaX = centerX - prevHandPosition.x;
            const deltaY = centerY - prevHandPosition.y;
            const deltaZ = centerZ - prevHandPosition.z;
            
            handVelocity.x = deltaX;
            handVelocity.y = deltaY;
            handVelocity.z = deltaZ;
            
            handSpeed = Math.sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);
            
            prevHandPosition.x = centerX;
            prevHandPosition.y = centerY;
            prevHandPosition.z = centerZ;
        }
        
        // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
        function distance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // æ›´æ–°ç²’å­ç›®æ ‡ä½ç½®
        function updateTargetPositions() {
            switch(currentGesture) {
                case 'open':
                    // çƒå½¢
                    updateSphereTargets();
                    break;
                case 'scissors':
                    // æ–‡å­—å½¢çŠ¶
                    updateTextTargets();
                    break;
                case 'fist':
                    // åœ†ç¯
                    updateRingTargets();
                    break;
                case 'point':
                    // æ˜Ÿå½¢
                    updateStarTargets();
                    break;
                case 'thumbsUp':
                    // çˆ±å¿ƒ
                    updateHeartTargets();
                    break;
                default:
                    // é»˜è®¤çƒå½¢
                    updateSphereTargets();
                    break;
            }
        }
        
        // æ›´æ–°çƒå½¢ç›®æ ‡
        function updateSphereTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // æ ¹æ®ç²’å­ç´¢å¼•è®¡ç®—åœ¨çƒé¢ä¸Šçš„ä½ç½®
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                
                const radius = 1.5 * (0.8 + 0.2 * Math.sin(Date.now() * 0.001 + i * 0.01));
                targetPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                targetPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                targetPositions[i3 + 2] = radius * Math.cos(phi);
            }
        }
        
        // æ›´æ–°æ–‡å­—ç›®æ ‡
        function updateTextTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                if (i * 3 < textShapePoints.length) {
                    targetPositions[i3] = textShapePoints[i3];
                    targetPositions[i3 + 1] = textShapePoints[i3 + 1];
                    targetPositions[i3 + 2] = textShapePoints[i3 + 2];
                }
            }
        }
        
        // æ›´æ–°åœ†ç¯ç›®æ ‡
        function updateRingTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                const radius = 1.2 + 0.3 * Math.sin(Date.now() * 0.002 + i * 0.02);
                
                targetPositions[i3] = Math.cos(angle) * radius;
                targetPositions[i3 + 1] = Math.sin(angle * 2) * 0.3; // æ·»åŠ æ³¢æµªæ•ˆæœ
                targetPositions[i3 + 2] = Math.sin(angle) * radius;
            }
        }
        
        // æ›´æ–°æ˜Ÿå½¢ç›®æ ‡
        function updateStarTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                // åˆ›å»ºæ˜Ÿå½¢æ•ˆæœ
                const starFactor = Math.floor((i / PARTICLE_COUNT) * 5) % 2 === 0 ? 1 : 0.5;
                const radius = 1.5 * starFactor;
                
                targetPositions[i3] = Math.cos(angle) * radius;
                targetPositions[i3 + 1] = Math.sin(angle) * radius;
                targetPositions[i3 + 2] = (Math.random() - 0.5) * 0.5;
            }
        }
        
        // æ›´æ–°çˆ±å¿ƒç›®æ ‡
        function updateHeartTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                
                // å¿ƒå½¢æ–¹ç¨‹
                const scale = 1.2;
                const x = scale * 1.5 * Math.pow(Math.sin(t), 3);
                const y = scale * (1.3 * Math.cos(t) - 0.5 * Math.cos(2*t) - 0.2 * Math.cos(3*t) - 0.1 * Math.cos(4*t));
                const z = (Math.random() - 0.5) * 0.3;
                
                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
            }
        }
        
        // åº”ç”¨æ‰‹åŠ¿äº¤äº’åŠ›
        function applyHandInteraction() {
            if (!handLandmarks || !particlePositions) return;
            
            // è·å–æ‰‹éƒ¨å±å¹•åæ ‡ï¼ˆå½’ä¸€åŒ–åˆ°-1åˆ°1ï¼‰
            const handScreenX = (handLandmarks[9].x - 0.5) * 2;
            const handScreenY = -(handLandmarks[9].y - 0.5) * 2; // ç¿»è½¬Yè½´
            
            // æ ¹æ®æ‰‹æŒå¤§å°è°ƒæ•´å½±å“èŒƒå›´
            const influenceRadius = 0.5 + palmSize * 3;
            
            // å¦‚æœæ‰‹é€Ÿå¾ˆå¿«ï¼Œäº§ç”Ÿé£å¹æ•ˆæœ
            if (handSpeed > 0.02) {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const i3 = i * 3;
                    const dx = particlePositions[i3] - handScreenX * 3;
                    const dy = particlePositions[i3 + 1] - handScreenY * 3;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < influenceRadius) {
                        // è®¡ç®—æ’æ–¥åŠ›
                        const force = (1 - distance / influenceRadius) * handSpeed * 10;
                        particleAccelerations[i3] -= handVelocity.x * force;
                        particleAccelerations[i3 + 1] -= handVelocity.y * force;
                    }
                }
            }
            
            // æ ¹æ®æ‰‹æŒå¤§å°è°ƒæ•´ç²’å­ç³»ç»Ÿç¼©æ”¾
            const scale = 0.5 + palmSize * 5;
            particles.scale.set(scale, scale, scale);
        }
        
        // æ›´æ–°ç²’å­ç‰©ç†
        function updatePhysics(deltaTime) {
            if (!particlePositions || !particleVelocities || !particleAccelerations) return;
            
            // é™åˆ¶DeltaTimeä»¥é˜²æ­¢æç«¯å€¼
            deltaTime = Math.min(deltaTime, 0.05);
            
            // æ›´æ–°ç›®æ ‡ä½ç½®
            updateTargetPositions();
            
            // åº”ç”¨æ‰‹åŠ¿äº¤äº’
            applyHandInteraction();
            
            // ä¼˜åŒ–ï¼šåªæ›´æ–°éƒ¨åˆ†ç²’å­ä»¥æé«˜æ€§èƒ½
            const updateStep = 2; // åªæ›´æ–°ä¸€åŠçš„ç²’å­
            for (let i = 0; i < PARTICLE_COUNT; i += updateStep) {
                const i3 = i * 3;
                
                // è®¡ç®—æœå‘ç›®æ ‡çš„åŠ›
                const dx = targetPositions[i3] - particlePositions[i3];
                const dy = targetPositions[i3 + 1] - particlePositions[i3 + 1];
                const dz = targetPositions[i3 + 2] - particlePositions[i3 + 2];
                
                // æ·»åŠ æœå‘ç›®æ ‡çš„åŠ é€Ÿåº¦
                particleAccelerations[i3] += dx * accelerationFactor;
                particleAccelerations[i3 + 1] += dy * accelerationFactor;
                particleAccelerations[i3 + 2] += dz * accelerationFactor;
                
                // æ›´æ–°é€Ÿåº¦ï¼ˆåŠ é€Ÿåº¦ç§¯åˆ†ï¼‰
                particleVelocities[i3] += particleAccelerations[i3] * deltaTime;
                particleVelocities[i3 + 1] += particleAccelerations[i3 + 1] * deltaTime;
                particleVelocities[i3 + 2] += particleAccelerations[i3 + 2] * deltaTime;
                
                // åº”ç”¨é˜»å°¼
                particleVelocities[i3] *= dampingFactor;
                particleVelocities[i3 + 1] *= dampingFactor;
                particleVelocities[i3 + 2] *= dampingFactor;
                
                // æ›´æ–°ä½ç½®ï¼ˆé€Ÿåº¦ç§¯åˆ†ï¼‰
                particlePositions[i3] += particleVelocities[i3] * deltaTime;
                particlePositions[i3 + 1] += particleVelocities[i3 + 1] * deltaTime;
                particlePositions[i3 + 2] += particleVelocities[i3 + 2] * deltaTime;
                
                // é‡ç½®åŠ é€Ÿåº¦
                particleAccelerations[i3] *= 0.1;
                particleAccelerations[i3 + 1] *= 0.1;
                particleAccelerations[i3 + 2] *= 0.1;
            }
            
            // æ›´æ–°å‡ ä½•ä½“é¡¶ç‚¹
            particleGeometry.attributes.position.needsUpdate = true;
        }
        
        // çª—å£å¤§å°è°ƒæ•´å¤„ç†
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // è®¡ç®—æ—¶é—´å·®
            const now = performance.now();
            let deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;
            
            // é™åˆ¶æœ€å¤§æ—¶é—´å·®ä»¥ä¿è¯ç¨³å®šæ€§
            deltaTime = Math.min(deltaTime, 0.1);
            
            // è‡ªåŠ¨å½¢çŠ¶åˆ‡æ¢ï¼ˆå½“æ²¡æœ‰æ‰‹åŠ¿è¯†åˆ«æ—¶ï¼‰
            if (!handLandmarks) {
                autoShapeTimer += deltaTime * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
                if (autoShapeTimer >= AUTO_SHAPE_INTERVAL) {
                    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    currentGesture = shapes[currentShapeIndex];
                    autoShapeTimer = 0;
                    
                    // æ›´æ–°UI
                    document.getElementById('gestureStatus').textContent = `è‡ªåŠ¨æ¨¡å¼: ${getGestureName(currentGesture)}`;
                }
            }
            
            // æ›´æ–°ç‰©ç†ç³»ç»Ÿ
            updatePhysics(deltaTime);
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
            
            // æ›´æ–°FPSè®¡æ•°å™¨
            updateFpsCounter(now);
        }
        
        // æ›´æ–°FPSè®¡æ•°å™¨
        function updateFpsCounter(now) {
            frameCount++;
            
            // è®°å½•å¸§æ—¶é—´æ ·æœ¬
            if (lastFrameTime > 0) {
                const frameTime = now - lastFrameTime;
                frameTimeSamples.push(frameTime);
                
                // ä¿æŒæ ·æœ¬æ•°é‡åœ¨é™åˆ¶èŒƒå›´å†…
                if (frameTimeSamples.length > MAX_SAMPLES) {
                    frameTimeSamples.shift();
                }
                
                // è®¡ç®—å¹³å‡å¸§æ—¶é—´
                avgFrameTime = frameTimeSamples.reduce((a, b) => a + b, 0) / frameTimeSamples.length;
            }
            
            if (now - lastFpsUpdate >= 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                const avgFrameTimeMs = avgFrameTime.toFixed(1);
                document.getElementById('fpsCounter').textContent = `${fps} FPS (${avgFrameTimeMs}ms)`;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
        
    </script>
</body>
</html>
