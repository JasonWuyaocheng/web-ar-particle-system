<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR 粒子互动系统</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            background-color: #000;
        }
        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #infoPanel {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #loadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: cyan;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>
    <div id="infoPanel">
        <div>手势状态: <span id="gestureStatus">初始化中...</span></div>
        <div>粒子数量: 16000</div>
        <div>帧率: <span id="fpsCounter">0</span> FPS</div>
    </div>
    <div id="loadingIndicator">正在请求摄像头权限...</div>

    <!-- 引入 Three.js 和相关库 -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // 添加库加载调试信息
        window.addEventListener('load', () => {
            console.log('Library load check:');
            console.log('- window.Hands:', typeof window.Hands);
            console.log('- window.Camera:', typeof window.Camera);
            console.log('- window.MediaPipeHands:', typeof window.MediaPipeHands);
            console.log('- window.MediaPipeCamera:', typeof window.MediaPipeCamera);
        });
    </script>
    
    <!-- 引入 MediaPipe 库 -->
    <script>
        // 使用现代方式加载MediaPipe库
        (function() {
            // 创建加载脚本的函数
            function loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = () => resolve(script);
                    script.onerror = (error) => reject(error);
                    document.head.appendChild(script);
                });
            }
            
            // 按顺序加载库
            async function loadMediaPipeLibraries() {
                try {
                    // 检查库是否已经加载
                    if (typeof window.Hands !== 'undefined' && typeof window.Camera !== 'undefined') {
                        console.log('MediaPipe库已预先加载');
                        return;
                    }
                    
                    console.log('开始加载MediaPipe库');
                    
                    // 加载Camera库
                    await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js');
                    console.log('Camera库加载完成');
                    
                    // 加载Hands库
                    await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1675469240/hands.js');
                    console.log('Hands库加载完成');
                    
                    console.log('MediaPipe库全部加载完成');
                } catch (error) {
                    console.error('加载MediaPipe库失败:', error);
                }
            }
            
            // 在页面加载完成后开始加载库
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', loadMediaPipeLibraries);
            } else {
                loadMediaPipeLibraries();
            }
        })();
    </script>

    <script>
        // 全局变量
        let scene, camera, renderer;
        let particles;
        let particlePositions, particleVelocities, particleAccelerations;
        let particleGeometry, particleMaterial;
        const PARTICLE_COUNT = 16000;
        const PARTICLE_SIZE = 3.0;
        
        // 库加载状态
        let mediaPipeLibrariesLoaded = false;
        
        // 手势相关
        let handsModule, cameraVideo;
        let currentGesture = 'open';
        let lastGesture = 'open';
        let gestureTransitionTime = 0;
        let gestureTransitionDuration = 0.5;
        
        // 物理参数
        const baseVelocityFactor = 0.05;
        const accelerationFactor = 0.02;
        const dampingFactor = 0.95;
        const repulsionForce = 0.2;
        const explosionForce = 2.0;
        
        // 手部追踪数据
        let handLandmarks = null;
        let handVelocity = { x: 0, y: 0, z: 0 };
        let prevHandPosition = { x: 0, y: 0, z: 0 };
        let handSpeed = 0;
        let palmSize = 0;
        
        // 形状目标点
        let targetPositions = [];
        let textShapePoints = [];
        
        // 性能监控
        let lastFrameTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // 初始化函数
        function init() {
            console.log('开始初始化WebAR粒子系统');
            
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvasContainer').appendChild(renderer.domElement);
            
            // 初始化粒子系统
            initParticles();
            
            // 创建文字形状点
            createTextShapePoints();
            
            // 设置事件监听器
            window.addEventListener('resize', onWindowResize);
            
            // 页面可见性变化监听
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    console.log('页面变为可见');
                } else {
                    console.log('页面变为不可见');
                }
            });
            
            // 开始动画循环
            animate();
            
            // 请求摄像头权限并初始化MediaPipe Hands
            // 添加一个小延迟确保DOM完全加载
            console.log('设置摄像头初始化延迟');
            setTimeout(() => {
                console.log('延迟结束，开始请求摄像头权限');
                requestCameraPermission();
            }, 1500); // 增加到1.5秒以确保库加载完成
        }
        
        // 初始化粒子系统
        function initParticles() {
            // 创建几何体
            particleGeometry = new THREE.BufferGeometry();
            
            // 创建粒子位置、速度和加速度数组
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            particleAccelerations = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);
            
            // 初始化粒子位置为球形分布
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 初始位置设为球形分布
                const radius = 1.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                particlePositions[i3] = x;
                particlePositions[i3 + 1] = y;
                particlePositions[i3 + 2] = z;
                
                // 目标位置初始也为球形
                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
                
                // 初始化速度和加速度为0
                particleVelocities[i3] = 0;
                particleVelocities[i3 + 1] = 0;
                particleVelocities[i3 + 2] = 0;
                particleAccelerations[i3] = 0;
                particleAccelerations[i3 + 1] = 0;
                particleAccelerations[i3 + 2] = 0;
            }
            
            // 设置几何体属性
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            // 创建材质
            particleMaterial = new THREE.PointsMaterial({
                color: 0x00FFFF, // 青色
                size: PARTICLE_SIZE,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            // 创建粒子系统
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }
        
        // 创建文字形状点 ("我是 Mok")
        function createTextShapePoints() {
            // 这里我们模拟一些文字形状的点
            // 在实际应用中，可以使用Canvas测量文字并获取点阵
            
            // 为演示目的，我们创建几个字母的简单表示
            textShapePoints = [];
            
            // 创建"M"形状的点
            for (let i = 0; i < 3000; i++) {
                const t = i / 3000;
                const x = (t - 0.5) * 4 - 1.5;
                const y = Math.abs(Math.sin(t * Math.PI * 2)) * 2 - 1;
                const z = (Math.random() - 0.5) * 0.5;
                textShapePoints.push(x, y, z);
            }
            
            // 创建"o"形状的点
            for (let i = 0; i < 2000; i++) {
                const angle = (i / 2000) * Math.PI * 2;
                const radius = 0.5;
                const x = Math.cos(angle) + 0.5;
                const y = Math.sin(angle);
                const z = (Math.random() - 0.5) * 0.5;
                textShapePoints.push(x, y, z);
            }
            
            // 创建"k"形状的点
            for (let i = 0; i < 3000; i++) {
                const t = i / 3000;
                let x, y, z;
                
                if (i < 1500) {
                    // 竖线
                    x = 1.5;
                    y = (t * 2 - 0.5) * 2;
                    z = (Math.random() - 0.5) * 0.5;
                } else {
                    // 斜线
                    const t2 = (t - 0.5) * 2;
                    x = 1.5 + t2 * 1.5;
                    y = -t2 * 1.5;
                    z = (Math.random() - 0.5) * 0.5;
                }
                
                textShapePoints.push(x, y, z);
            }
            
            // 补充到16000个点
            while (textShapePoints.length < PARTICLE_COUNT * 3) {
                textShapePoints.push(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 0.5
                );
            }
        }
        
        // 检查是否在安全上下文中运行（HTTPS）
        function checkSecureContext() {
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                document.getElementById('gestureStatus').textContent = '错误: 需要HTTPS环境';
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('loadingIndicator').innerHTML = '此应用需要在HTTPS环境下运行才能访问摄像头。<br>请在本地服务器上运行或使用HTTPS访问。';
                console.error('摄像头访问需要安全上下文（HTTPS）');
                return false;
            }
            return true;
        }
        
        // 初始化MediaPipe库
        function initializeMediaPipe() {
            console.log('开始初始化MediaPipe库');
            
            // 检查Hands库
            if ((typeof window.Hands === 'undefined' || typeof window.Hands !== 'function')) {
                console.error('Hands库未定义或不是函数');
                // 尝试从其他可能的位置获取
                if (typeof window.MediaPipeHands !== 'undefined') {
                    window.Hands = window.MediaPipeHands;
                    console.log('已从MediaPipeHands重新赋值');
                } else {
                    console.warn('无法找到有效的Hands库');
                    // 不抛出错误，继续尝试
                }
            }
            
            // 检查Camera库
            if ((typeof window.Camera === 'undefined' || typeof window.Camera !== 'function')) {
                console.error('Camera库未定义或不是函数');
                // 尝试从其他可能的位置获取
                if (typeof window.MediaPipeCamera !== 'undefined') {
                    window.Camera = window.MediaPipeCamera;
                    console.log('已从MediaPipeCamera重新赋值');
                } else {
                    console.warn('无法找到有效的Camera库');
                    // 不抛出错误，继续尝试
                }
            }
            
            console.log('MediaPipe库初始化完成');
        }
        
        // 检查MediaPipe库是否已加载
        function checkMediaPipeLibraries() {
            console.log('检查MediaPipe库加载状态');
            
            // 检查所有可能的构造函数
            const handsAvailable = (typeof window.Hands === 'function') || (typeof window.MediaPipeHands !== 'undefined');
            const cameraAvailable = (typeof window.Camera === 'function') || (typeof window.MediaPipeCamera !== 'undefined');
            
            console.log('Hands库可用:', handsAvailable, 'Camera库可用:', cameraAvailable);
            
            // 如果库还没有加载完成，给它们一些时间
            if (!handsAvailable || !cameraAvailable) {
                console.warn('MediaPipe库尚未完全加载，等待中...');
                console.log('当前状态 - Hands:', typeof window.Hands, 'Camera:', typeof window.Camera);
                console.log('备用状态 - MediaPipeHands:', typeof window.MediaPipeHands, 'MediaPipeCamera:', typeof window.MediaPipeCamera);
                
                // 添加更多调试信息
                if (typeof window.Hands !== 'undefined') {
                    console.log('window.Hands类型:', typeof window.Hands);
                }
                
                if (typeof window.MediaPipeHands !== 'undefined') {
                    console.log('window.MediaPipeHands类型:', typeof window.MediaPipeHands);
                }
                
                // 给库一些额外的加载时间
                return false;
            }
            
            console.log('MediaPipe库已正确加载');
            return true;
        }
        
        // 等待MediaPipe库加载完成
        function waitForMediaPipeLibraries() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50; // 最多等待5秒
                
                const check = () => {
                    attempts++;
                    
                    // 检查库是否已加载
                    const handsAvailable = (typeof window.Hands === 'function') || (typeof window.MediaPipeHands !== 'undefined');
                    const cameraAvailable = (typeof window.Camera === 'function') || (typeof window.MediaPipeCamera !== 'undefined');
                    
                    if (handsAvailable && cameraAvailable) {
                        console.log('MediaPipe库加载完成');
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        console.error('MediaPipe库加载超时');
                        reject(new Error('MediaPipe库加载超时，请检查网络连接'));  
                    } else {
                        console.log(`等待MediaPipe库加载... (${attempts}/${maxAttempts})`);
                        setTimeout(check, 100);
                    }
                };
                
                check();
            });
        }
        
        // 请求摄像头权限
        async function requestCameraPermission() {
            console.log('开始请求摄像头权限');
            
            // 检查是否在安全上下文中
            if (!checkSecureContext()) {
                return;
            }
            
            // 等待MediaPipe库加载完成
            try {
                await waitForMediaPipeLibraries();
                console.log('MediaPipe库已就绪');
            } catch (loadError) {
                console.error('MediaPipe库加载失败:', loadError);
                document.getElementById('gestureStatus').textContent = '错误: 手势识别库加载失败';
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('loadingIndicator').textContent = '手势识别库加载失败: ' + loadError.message;
                return;
            }
            
            // 初始化MediaPipe库
            try {
                initializeMediaPipe();
            } catch (initError) {
                console.error('MediaPipe库初始化失败:', initError);
                document.getElementById('gestureStatus').textContent = '错误: 手势识别库初始化失败';
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('loadingIndicator').textContent = '手势识别库初始化失败: ' + initError.message;
                return;
            }
            
            // 检查MediaPipe库是否已正确加载
            if (!checkMediaPipeLibraries()) {
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('loadingIndicator').textContent = '手势识别库加载失败，请检查网络连接后刷新页面。';
                return;
            }
            
            // 检查浏览器是否支持所需的API
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                document.getElementById('gestureStatus').textContent = '错误: 浏览器不支持';
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('loadingIndicator').textContent = '当前浏览器不支持摄像头访问功能，请更换现代浏览器。';
                console.error('浏览器不支持mediaDevices API');
                return;
            }
            
            console.log('正在请求摄像头访问权限');
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } } })
                .then(stream => {
                    // 成功获取摄像头权限
                    console.log('摄像头权限已获取，视频流:', stream);
                    document.getElementById('gestureStatus').textContent = '摄像头已连接，正在初始化手势识别...';
                    
                    // 初始化MediaPipe Hands
                    console.log('开始初始化手势检测');
                    initHandsDetection(stream);
                })
                .catch(error => {
                    // 摄像头权限被拒绝或出现错误
                    console.error('无法访问摄像头:', error);
                    console.error('错误详情:', error.name, error.message);
                    document.getElementById('gestureStatus').textContent = '错误: 无法访问摄像头';
                    document.getElementById('loadingIndicator').style.display = 'block';
                    
                    // 根据错误类型提供不同的提示信息
                    if (error.name === 'NotAllowedError') {
                        document.getElementById('loadingIndicator').innerHTML = '摄像头访问被拒绝。<br>请点击地址栏中的摄像头图标并选择"允许"，然后刷新页面。';
                    } else if (error.name === 'NotFoundError' || error.name === 'OverconstrainedError') {
                        document.getElementById('loadingIndicator').innerHTML = '未找到可用的摄像头设备。<br>请检查摄像头是否正确连接，然后刷新页面。';
                    } else {
                        document.getElementById('loadingIndicator').innerHTML = '无法访问摄像头: ' + error.message + '<br>请检查摄像头设置后刷新页面。';
                    }
                });
        }
        
        // 初始化手势检测
        function initHandsDetection(stream) {
            try {
                console.log('开始初始化手势检测');
                
                // 创建视频元素
                cameraVideo = document.createElement('video');
                cameraVideo.style.display = 'none';
                cameraVideo.setAttribute('playsinline', true); // iOS Safari兼容性
                cameraVideo.muted = true;
                document.body.appendChild(cameraVideo);
                
                console.log('视频元素已创建');
                
                // 绑定视频流
                cameraVideo.srcObject = stream;
                
                // 当视频播放结束时清理资源
                cameraVideo.onended = () => {
                    console.log('视频流已结束');
                };
                
                // 当视频元数据加载完成后再启动摄像头
                cameraVideo.onloadedmetadata = () => {
                    console.log('视频元数据已加载');
                    
                    // 使用setTimeout确保Hands模块正确初始化
                    setTimeout(() => {
                        try {
                            // 使用可用的构造函数
                            let HandsConstructor = window.Hands;
                            let CameraConstructor = window.Camera;
                            
                            // 检查备用构造函数
                            if ((typeof HandsConstructor !== 'function') && (typeof window.MediaPipeHands !== 'undefined')) {
                                HandsConstructor = window.MediaPipeHands;
                            }
                            
                            if ((typeof CameraConstructor !== 'function') && (typeof window.MediaPipeCamera !== 'undefined')) {
                                CameraConstructor = window.MediaPipeCamera;
                            }
                            
                            if (typeof HandsConstructor !== 'function') {
                                throw new Error('无法找到有效的Hands构造函数');
                            }
                            
                            if (typeof CameraConstructor !== 'function') {
                                throw new Error('无法找到有效的Camera构造函数');
                            }
                            
                            // 初始化Hands模块
                            console.log('正在初始化Hands模块');
                            const hands = new HandsConstructor({
                                locateFile: (file) => {
                                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.3.1675469240/${file}`;
                                }
                            });
                            
                            hands.setOptions({
                                maxNumHands: 1,
                                modelComplexity: 1,
                                minDetectionConfidence: 0.5,
                                minTrackingConfidence: 0.5
                            });
                            
                            hands.onResults(onHandsResults);
                            
                            console.log('Hands模块配置完成');
                            
                            // 初始化摄像头
                            console.log('正在初始化摄像头');
                            const camera = new CameraConstructor(cameraVideo, {
                                onFrame: async () => {
                                    await hands.send({image: cameraVideo});
                                },
                                width: 1280,
                                height: 720
                            });
                            
                            camera.start();
                            
                            // 更新状态显示
                            document.getElementById('gestureStatus').textContent = '手势识别已就绪';
                            console.log('手势识别系统已启动');
                            
                        } catch (error) {
                            console.error('初始化手势识别模块失败:', error);
                            console.error('详细错误信息:', error.stack);
                            document.getElementById('gestureStatus').textContent = '错误: 初始化手势识别失败 (' + error.message + ')';
                        }
                    }, 100); // 添加小延迟确保库完全初始化
                };
                
                // 错误处理
                cameraVideo.onerror = (error) => {
                    console.error('视频元素发生错误:', error);
                    document.getElementById('gestureStatus').textContent = '错误: 视频流出现问题';
                };
                
                // 视频播放开始
                cameraVideo.onplay = () => {
                    console.log('视频开始播放');
                };
                
            } catch (error) {
                console.error('初始化视频元素失败:', error);
                console.error('详细错误信息:', error.stack);
                document.getElementById('gestureStatus').textContent = '错误: 视频初始化失败';
            }
        }
        
        // 处理手势检测结果
        function onHandsResults(results) {
            try {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handLandmarks = results.multiHandLandmarks[0];
                    detectGesture();
                    calculateHandMetrics();
                } else {
                    handLandmarks = null;
                    handSpeed = 0;
                    palmSize = 0;
                }
            } catch (error) {
                console.error('处理手势结果时出错:', error);
                // 出错时保持之前的状态
            }
        }
        
        // 手势识别
        function detectGesture() {
            if (!handLandmarks) return;
            
            // 计算关键点距离用于手势识别
            const thumbTip = handLandmarks[4];
            const indexTip = handLandmarks[8];
            const middleTip = handLandmarks[12];
            const ringTip = handLandmarks[16];
            const pinkyTip = handLandmarks[20];
            
            const wrist = handLandmarks[0];
            
            // 计算手指伸展程度
            const thumbDistance = distance(thumbTip, wrist);
            const indexDistance = distance(indexTip, wrist);
            const middleDistance = distance(middleTip, wrist);
            const ringDistance = distance(ringTip, wrist);
            const pinkyDistance = distance(pinkyTip, wrist);
            
            // 计算手指间的距离
            const thumbIndexDist = distance(thumbTip, indexTip);
            const indexMiddleDist = distance(indexTip, middleTip);
            
            // 识别手势
            if (thumbIndexDist > 0.1 && indexMiddleDist > 0.1 && 
                indexDistance > middleDistance && indexDistance > ringDistance && indexDistance > pinkyDistance &&
                thumbDistance > 0.3) {
                // 食指手势（其他手指弯曲，只有食指伸出）
                setGesture('point');
            } else if (thumbIndexDist < 0.08 && Math.abs(indexMiddleDist - 0.15) < 0.05) {
                // 剪刀手手势（食指和中指分开）
                setGesture('scissors');
            } else if (thumbDistance < 0.08 && indexDistance < 0.08 && 
                       middleDistance < 0.08 && ringDistance < 0.08 && pinkyDistance < 0.08) {
                // 握拳手势（所有手指弯曲）
                setGesture('fist');
            } else if (thumbDistance > 0.1 && indexDistance > 0.1 && 
                       middleDistance > 0.1 && ringDistance > 0.1 && pinkyDistance > 0.1 &&
                       thumbIndexDist > 0.1) {
                // 张手手势（所有手指伸开）
                setGesture('open');
            } else if (thumbDistance > 0.15 && indexDistance < 0.1 && 
                       middleDistance < 0.1 && ringDistance < 0.1 && pinkyDistance < 0.1) {
                // 竖大拇指手势
                setGesture('thumbsUp');
            }
        }
        
        // 设置手势并处理转换
        function setGesture(gesture) {
            if (currentGesture !== gesture) {
                lastGesture = currentGesture;
                currentGesture = gesture;
                gestureTransitionTime = 0;
                
                // 更新UI
                document.getElementById('gestureStatus').textContent = getGestureName(gesture);
                
                // 触发爆炸效果
                triggerExplosion();
            }
        }
        
        // 获取手势名称
        function getGestureName(gesture) {
            switch(gesture) {
                case 'open': return '张手';
                case 'scissors': return '剪刀手';
                case 'fist': return '握拳';
                case 'point': return '食指';
                case 'thumbsUp': return '竖大拇指';
                default: return gesture;
            }
        }
        
        // 触发爆炸效果
        function triggerExplosion() {
            if (!particleVelocities) return;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // 给每个粒子添加随机方向的爆炸力
                particleVelocities[i3] += (Math.random() - 0.5) * explosionForce;
                particleVelocities[i3 + 1] += (Math.random() - 0.5) * explosionForce;
                particleVelocities[i3 + 2] += (Math.random() - 0.5) * explosionForce;
            }
        }
        
        // 计算手部指标
        function calculateHandMetrics() {
            if (!handLandmarks) return;
            
            // 计算手掌大小（通过拇指和小指根部的距离）
            const thumbBase = handLandmarks[2];
            const pinkyBase = handLandmarks[17];
            palmSize = distance(thumbBase, pinkyBase);
            
            // 计算手部中心位置
            const centerX = (handLandmarks[0].x + handLandmarks[9].x) / 2;
            const centerY = (handLandmarks[0].y + handLandmarks[9].y) / 2;
            const centerZ = (handLandmarks[0].z + handLandmarks[9].z) / 2;
            
            // 计算手部速度
            const deltaX = centerX - prevHandPosition.x;
            const deltaY = centerY - prevHandPosition.y;
            const deltaZ = centerZ - prevHandPosition.z;
            
            handVelocity.x = deltaX;
            handVelocity.y = deltaY;
            handVelocity.z = deltaZ;
            
            handSpeed = Math.sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);
            
            prevHandPosition.x = centerX;
            prevHandPosition.y = centerY;
            prevHandPosition.z = centerZ;
        }
        
        // 计算两点间距离
        function distance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // 更新粒子目标位置
        function updateTargetPositions() {
            switch(currentGesture) {
                case 'open':
                    // 球形
                    updateSphereTargets();
                    break;
                case 'scissors':
                    // 文字形状
                    updateTextTargets();
                    break;
                case 'fist':
                    // 圆环
                    updateRingTargets();
                    break;
                case 'point':
                    // 星形
                    updateStarTargets();
                    break;
                case 'thumbsUp':
                    // 爱心
                    updateHeartTargets();
                    break;
            }
        }
        
        // 更新球形目标
        function updateSphereTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 根据粒子索引计算在球面上的位置
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                
                const radius = 1.5 * (0.8 + 0.2 * Math.sin(Date.now() * 0.001 + i * 0.01));
                targetPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                targetPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                targetPositions[i3 + 2] = radius * Math.cos(phi);
            }
        }
        
        // 更新文字目标
        function updateTextTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                if (i * 3 < textShapePoints.length) {
                    targetPositions[i3] = textShapePoints[i3];
                    targetPositions[i3 + 1] = textShapePoints[i3 + 1];
                    targetPositions[i3 + 2] = textShapePoints[i3 + 2];
                }
            }
        }
        
        // 更新圆环目标
        function updateRingTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                const radius = 1.2 + 0.3 * Math.sin(Date.now() * 0.002 + i * 0.02);
                
                targetPositions[i3] = Math.cos(angle) * radius;
                targetPositions[i3 + 1] = Math.sin(angle * 2) * 0.3; // 添加波浪效果
                targetPositions[i3 + 2] = Math.sin(angle) * radius;
            }
        }
        
        // 更新星形目标
        function updateStarTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                // 创建星形效果
                const starFactor = Math.floor((i / PARTICLE_COUNT) * 5) % 2 === 0 ? 1 : 0.5;
                const radius = 1.5 * starFactor;
                
                targetPositions[i3] = Math.cos(angle) * radius;
                targetPositions[i3 + 1] = Math.sin(angle) * radius;
                targetPositions[i3 + 2] = (Math.random() - 0.5) * 0.5;
            }
        }
        
        // 更新爱心目标
        function updateHeartTargets() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                
                // 心形方程
                const scale = 1.2;
                const x = scale * 1.5 * Math.pow(Math.sin(t), 3);
                const y = scale * (1.3 * Math.cos(t) - 0.5 * Math.cos(2*t) - 0.2 * Math.cos(3*t) - 0.1 * Math.cos(4*t));
                const z = (Math.random() - 0.5) * 0.3;
                
                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
            }
        }
        
        // 应用手势交互力
        function applyHandInteraction() {
            if (!handLandmarks || !particlePositions) return;
            
            // 获取手部屏幕坐标（归一化到-1到1）
            const handScreenX = (handLandmarks[9].x - 0.5) * 2;
            const handScreenY = -(handLandmarks[9].y - 0.5) * 2; // 翻转Y轴
            
            // 根据手掌大小调整影响范围
            const influenceRadius = 0.5 + palmSize * 3;
            
            // 如果手速很快，产生风吹效果
            if (handSpeed > 0.02) {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const i3 = i * 3;
                    const dx = particlePositions[i3] - handScreenX * 3;
                    const dy = particlePositions[i3 + 1] - handScreenY * 3;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < influenceRadius) {
                        // 计算排斥力
                        const force = (1 - distance / influenceRadius) * handSpeed * 10;
                        particleAccelerations[i3] -= handVelocity.x * force;
                        particleAccelerations[i3 + 1] -= handVelocity.y * force;
                    }
                }
            }
            
            // 根据手掌大小调整粒子系统缩放
            const scale = 0.5 + palmSize * 5;
            particles.scale.set(scale, scale, scale);
        }
        
        // 更新粒子物理
        function updatePhysics(deltaTime) {
            if (!particlePositions || !particleVelocities || !particleAccelerations) return;
            
            // 更新目标位置
            updateTargetPositions();
            
            // 应用手势交互
            applyHandInteraction();
            
            // 更新每个粒子的物理状态
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 计算朝向目标的力
                const dx = targetPositions[i3] - particlePositions[i3];
                const dy = targetPositions[i3 + 1] - particlePositions[i3 + 1];
                const dz = targetPositions[i3 + 2] - particlePositions[i3 + 2];
                
                // 添加朝向目标的加速度
                particleAccelerations[i3] += dx * accelerationFactor;
                particleAccelerations[i3 + 1] += dy * accelerationFactor;
                particleAccelerations[i3 + 2] += dz * accelerationFactor;
                
                // 更新速度（加速度积分）
                particleVelocities[i3] += particleAccelerations[i3] * deltaTime;
                particleVelocities[i3 + 1] += particleAccelerations[i3 + 1] * deltaTime;
                particleVelocities[i3 + 2] += particleAccelerations[i3 + 2] * deltaTime;
                
                // 应用阻尼
                particleVelocities[i3] *= dampingFactor;
                particleVelocities[i3 + 1] *= dampingFactor;
                particleVelocities[i3 + 2] *= dampingFactor;
                
                // 更新位置（速度积分）
                particlePositions[i3] += particleVelocities[i3] * deltaTime;
                particlePositions[i3 + 1] += particleVelocities[i3 + 1] * deltaTime;
                particlePositions[i3 + 2] += particleVelocities[i3 + 2] * deltaTime;
                
                // 重置加速度
                particleAccelerations[i3] *= 0.1;
                particleAccelerations[i3 + 1] *= 0.1;
                particleAccelerations[i3 + 2] *= 0.1;
            }
            
            // 更新几何体顶点
            particleGeometry.attributes.position.needsUpdate = true;
        }
        
        // 窗口大小调整处理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 计算时间差
            const now = performance.now();
            let deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;
            
            // 限制最大时间差以保证稳定性
            deltaTime = Math.min(deltaTime, 0.1);
            
            // 更新物理系统
            updatePhysics(deltaTime);
            
            // 渲染场景
            renderer.render(scene, camera);
            
            // 更新FPS计数器
            updateFpsCounter(now);
        }
        
        // 更新FPS计数器
        function updateFpsCounter(now) {
            frameCount++;
            
            if (now - lastFpsUpdate >= 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fpsCounter').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
        
        // 监听MediaPipe库加载完成
        window.addEventListener('load', () => {
            // 检查库是否已加载
            const checkLibraries = () => {
                // 检查所有可能的构造函数
                const handsAvailable = (typeof window.Hands === 'function') || (typeof window.MediaPipeHands !== 'undefined');
                const cameraAvailable = (typeof window.Camera === 'function') || (typeof window.MediaPipeCamera !== 'undefined');
                
                if (handsAvailable && cameraAvailable) {
                    console.log('MediaPipe库加载完成');
                    mediaPipeLibrariesLoaded = true;
                } else {
                    console.log('等待MediaPipe库加载...');
                    console.log('Hands:', typeof window.Hands, 'Camera:', typeof window.Camera);
                    console.log('MediaPipeHands:', typeof window.MediaPipeHands, 'MediaPipeCamera:', typeof window.MediaPipeCamera);
                    setTimeout(checkLibraries, 500);
                }
            };
            
            // 开始检查
            setTimeout(checkLibraries, 1000);
        });
    </script>
</body>
</html>