<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR ç²’å­äº’åŠ¨ç³»ç»Ÿ - 16000ç‹¬ç«‹é¢—ç²’</title>
    <style>
        :root {
            --bg-dark: #0a0a0a;
            --bg-glass: rgba(15, 15, 20, 0.72);
            --bg-glass-hover: rgba(25, 25, 35, 0.85);
            --particle-cyan: #00ffff;
            --particle-glow: rgba(0, 255, 255, 0.5);
            --accent-red: #ff4444;
            --text-dim: #888;
            --text-bright: #fff;
            
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 12px;
            --spacing-lg: 16px;
            
            --ui-scale: 0.95;
        }

        @media screen and (max-height: 800px) { :root { --ui-scale: 0.85; } }
        @media screen and (min-width: 2000px) { :root { --ui-scale: 1.1; } }
        :fullscreen { --ui-scale: 1.0; }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            color: var(--text-bright);
        }

        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* ç»ç’ƒæ‹Ÿæ€é¢æ¿ */
        .glass-panel {
            background: var(--bg-glass);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.06);
            overflow: hidden;
            box-sizing: border-box;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .glass-panel:hover {
            background: var(--bg-glass-hover);
            border-color: var(--particle-glow);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5), 0 0 20px var(--particle-glow);
        }

        .panel-hidden { 
            transform: translateX(calc(-1 * 220px)) scale(var(--ui-scale)) !important; 
            opacity: 0 !important; 
            pointer-events: none !important; 
        }

        /* å·¦ä¾§ä¿¡æ¯é¢æ¿ */
        #infoPanel {
            position: fixed;
            top: var(--spacing-lg);
            left: var(--spacing-lg);
            width: 220px;
            padding: var(--spacing-md);
            z-index: 100;
            transform: scale(var(--ui-scale));
            transform-origin: top left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #infoPanel h2 {
            color: var(--particle-cyan);
            font-size: 14px;
            margin-bottom: var(--spacing-sm);
            text-align: center;
            text-shadow: 0 0 10px var(--particle-glow);
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: var(--spacing-xs) 0;
            padding: var(--spacing-xs) var(--spacing-sm);
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-sm);
            font-size: 11px;
            border-left: 3px solid var(--particle-cyan);
        }

        .status-label {
            color: var(--text-dim);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            color: var(--text-bright);
            font-weight: 700;
        }

        .status-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            background: #ff0000;
            box-shadow: 0 0 4px #ff0000;
            animation: blink 1.5s ease-in-out infinite;
        }

        .status-indicator.active {
            background: #00ff00;
            box-shadow: 0 0 6px #00ff00;
            animation: none;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* å³ä¾§æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        #gestureIndicator {
            position: fixed;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            width: 160px;
            padding: var(--spacing-md);
            z-index: 100;
            transform: scale(var(--ui-scale));
            transform-origin: top right;
            text-align: center;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #gestureIndicator h3 {
            color: var(--accent-red);
            font-size: 12px;
            margin-bottom: var(--spacing-sm);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 700;
        }

        .gesture-icon {
            font-size: 36px;
            margin: 6px 0;
            filter: drop-shadow(0 0 8px rgba(255, 68, 68, 0.6));
        }

        .gesture-name {
            color: var(--text-bright);
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
            margin-top: 4px;
        }

        /* é¡¶éƒ¨æ“ä½œæŒ‰é’® */
        #topButtons {
            position: fixed;
            top: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: var(--spacing-sm);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* æ‘„åƒå¤´é¢„è§ˆçª—å£ */
        #cameraPreview {
            position: fixed;
            top: var(--spacing-lg);
            right: calc(var(--spacing-lg) + 180px);
            width: 200px;
            height: 150px;
            border-radius: var(--radius-lg);
            overflow: hidden;
            z-index: 99;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            background: rgba(0, 0, 0, 0.5);
        }

        #cameraPreview.show {
            opacity: 1;
            pointer-events: auto;
        }

        #cameraVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .camera-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 8px;
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .camera-btn {
            padding: 4px 8px;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.4);
            color: white;
            cursor: pointer;
            font-size: 9px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .camera-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .camera-status {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 600;
        }

        .camera-status.active {
            background: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        .top-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: var(--particle-cyan);
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            font-size: 11px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(8px);
        }

        .top-btn:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--particle-cyan);
            color: var(--text-bright);
            box-shadow: 0 0 16px var(--particle-glow);
            transform: translateY(-1px);
        }

        .top-btn:active {
            transform: translateY(0);
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        #controlPanel {
            position: fixed;
            bottom: var(--spacing-lg);
            left: var(--spacing-lg);
            padding: var(--spacing-sm);
            z-index: 100;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-xs);
            width: 220px;
            transform: scale(var(--ui-scale));
            transform-origin: bottom left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .control-title {
            grid-column: span 2;
            font-size: 10px;
            color: var(--particle-cyan);
            text-align: center;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .control-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: var(--particle-cyan);
            cursor: pointer;
            font-size: 10px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .control-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--particle-cyan);
            box-shadow: 0 0 12px var(--particle-glow);
            transform: translateY(-1px);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn.danger {
            border-color: rgba(255, 68, 68, 0.5);
            color: var(--accent-red);
        }

        .control-btn.danger:hover {
            background: rgba(255, 68, 68, 0.15);
            border-color: var(--accent-red);
            box-shadow: 0 0 12px rgba(255, 68, 68, 0.4);
        }

        .control-btn.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: var(--particle-cyan);
            color: var(--text-bright);
        }

        /* è¿›åº¦æŒ‡ç¤ºå™¨ */
        #progressIndicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(0, 255, 255, 0.15);
            border-top: 3px solid var(--particle-cyan);
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            box-shadow: 0 0 20px var(--particle-glow);
        }

        @keyframes spin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.05); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .progress-container {
            width: 320px;
            margin-top: 20px;
            display: none;
        }

        .progress-bar-bg {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 10px;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.8), var(--particle-cyan));
            width: 0%;
            transition: width 0.4s ease;
            box-shadow: 0 0 16px var(--particle-glow);
            border-radius: 3px;
        }

        .progress-text {
            color: var(--particle-cyan);
            font-size: 14px;
            text-align: center;
            letter-spacing: 1px;
            font-weight: 600;
            margin-top: 10px;
        }

        .progress-steps {
            color: var(--text-dim);
            font-size: 11px;
            margin-top: 8px;
            text-align: center;
        }

        .progress-step {
            margin: 3px 0;
            padding: 2px 0;
            transition: color 0.3s ease;
        }

        .progress-step.complete {
            color: #00ff88;
        }

        .progress-step.current {
            color: var(--particle-cyan);
            font-weight: 700;
        }

        /* æ‹–æ‹½æ ‡é¢˜ */
        #mainTitle {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            text-align: center;
            cursor: move;
            user-select: none;
            padding: var(--spacing-sm);
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        #mainTitle:hover {
            background: rgba(0, 0, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
        }

        .title-line {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            color: var(--particle-cyan);
            text-shadow: 0 0 15px var(--particle-glow);
            letter-spacing: 2px;
            white-space: nowrap;
            transition: all 0.3s ease;
        }

        .title-subline {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 4px;
            letter-spacing: 1px;
        }

        /* çŠ¶æ€æç¤º */
        #stateToast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: var(--particle-cyan);
            color: #000;
            padding: 16px 32px;
            border-radius: var(--radius-lg);
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 1px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            box-shadow: 0 10px 30px var(--particle-glow);
            text-transform: uppercase;
            white-space: nowrap;
        }

        #stateToast.show {
            opacity: 1;
        }

        #stateToast.error {
            background: rgba(255, 68, 68, 0.95);
            color: #fff;
            box-shadow: 0 10px 30px rgba(255, 68, 68, 0.4);
        }

        /* ä¿¡æ¯æç¤º */
        #infoTooltip {
            position: fixed;
            bottom: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            color: var(--particle-cyan);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 11px;
            letter-spacing: 0.5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(8px);
            white-space: nowrap;
            text-shadow: 0 0 5px var(--particle-glow);
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* è°ƒè¯•ä¿¡æ¯ */
        #debug-info {
            position: fixed;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: #00ff00;
            font-size: 13px;
            font-weight: 600;
            font-family: 'Consolas', monospace;
            pointer-events: none;
            z-index: 999;
            text-shadow: 0 0 4px #000;
            background: rgba(0,0,0,0.4);
            padding: 6px 0;
            transition: all 0.5s ease;
            letter-spacing: 0.5px;
        }

        #debug-info.loading-center {
            bottom: auto;
            top: 55%;
            transform: translateY(-50%);
            font-size: 16px;
            background: rgba(0,0,0,0.85);
            padding: 20px 0;
            border-top: 1px solid rgba(0,255,255,0.5);
            border-bottom: 1px solid rgba(0,255,255,0.5);
            border-radius: var(--radius-sm);
            max-width: 400px;
            left: 50%;
            margin-left: -200px;
            position: absolute;
            width: 400px;
        }

        .debug-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* æ‰‹åŠ¿æç¤º */
        #gesture-hint {
            position: fixed;
            top: 16%;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-bright);
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: var(--radius-lg);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 40;
            text-shadow: 0 0 5px var(--particle-glow);
        }

        #gesture-hint.show {
            opacity: 1;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            :root { --ui-scale: 0.8; }
            #infoPanel, #controlPanel {
                width: 180px;
            }
            #gestureIndicator {
                width: 130px;
            }
            .top-btn {
                padding: 6px 12px;
                font-size: 9px;
            }
            #mainTitle .title-line {
                font-size: 20px;
            }
        }

        /* éšè—æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 3px; height: 3px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 2px; }
        ::-webkit-scrollbar-thumb { background: rgba(0, 255, 255, 0.5); border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0, 255, 255, 0.8); }
    </style>
</head>
<body>
    <!-- 3Dç”»å¸ƒå®¹å™¨ -->
    <div id="canvasContainer"></div>

    <!-- æ‹–æ‹½æ ‡é¢˜ -->
    <div id="mainTitle">
        <h1 class="title-line">PARTICLE SYSTEM</h1>
        <div class="title-subline">16K ç‹¬ç«‹æµä½“é¢—ç²’</div>
    </div>

    <!-- æ‘„åƒå¤´é¢„è§ˆçª—å£ -->
    <div id="cameraPreview">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <div class="camera-status" id="cameraStatus">æ‘„åƒå¤´æœªå¯åŠ¨</div>
        <div class="camera-controls">
            <button class="camera-btn" onclick="toggleCameraPreview()">æ˜¾ç¤º/éšè—</button>
            <button class="camera-btn" onclick="toggleCameraMirror()">é•œåƒ</button>
        </div>
    </div>

    <!-- è¿›åº¦æŒ‡ç¤ºå™¨ -->
    <div id="progressIndicator">
        <div class="spinner"></div>
        <div class="progress-container" id="progress-container">
            <div class="progress-bar-bg">
                <div class="progress-bar" id="progress-bar-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">0%</div>
            <div class="progress-steps" id="progress-steps">
                <div class="progress-step" data-step="scene">â— åˆ›å»º3Dåœºæ™¯</div>
                <div class="progress-step" data-step="particles">â— ç”Ÿæˆ16,000é¢—ç²’</div>
                <div class="progress-step" data-step="shapes">â— é¢„å¤„ç†å˜å½¢å½¢çŠ¶</div>
                <div class="progress-step" data-step="camera">â— è¯·æ±‚æ‘„åƒå¤´æƒé™</div>
                <div class="progress-step" data-step="gesture">â— åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«</div>
            </div>
        </div>
    </div>

    <!-- è°ƒè¯•ä¿¡æ¯ -->
    <div id="debug-info" class="loading-center">æ­£åœ¨åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...</div>

    <!-- æ‰‹åŠ¿æç¤º -->
    <div id="gesture-hint">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>

    <!-- å·¦ä¾§ä¿¡æ¯é¢æ¿ -->
    <div id="infoPanel" class="glass-panel">
        <h2>ğŸŒŠ ç²’å­çŠ¶æ€</h2>
        <div class="status-item">
            <span class="status-label">ç²’å­æ•°é‡</span>
            <span class="status-value" style="color: var(--particle-cyan);">16,000</span>
        </div>
        <div class="status-item">
            <span class="status-label">å½“å‰å½¢æ€</span>
            <span class="status-value" id="shapeStatus">çƒä½“</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç‰©ç†æ¨¡å‹</span>
            <span class="status-value">é€Ÿåº¦+åŠ é€Ÿåº¦</span>
        </div>
        <div class="status-item">
            <span class="status-label">å¸§ç‡</span>
            <span class="status-value" id="fpsCounter">0 FPS</span>
        </div>
        <div class="status-item">
            <span class="status-label">è¿æ¥çŠ¶æ€</span>
            <span class="status-value">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="gestureStatus">åˆå§‹åŒ–ä¸­...</span>
            </span>
        </div>
    </div>

    <!-- å³ä¾§æ‰‹åŠ¿æŒ‡ç¤ºå™¨ -->
    <div id="gestureIndicator" class="glass-panel">
        <h3>æ‰‹åŠ¿è¯†åˆ«</h3>
        <div class="gesture-icon" id="gestureIcon">âœ‹</div>
        <div class="gesture-name" id="gestureName">åˆå§‹åŒ–ä¸­...</div>
    </div>

    <!-- é¡¶éƒ¨æ“ä½œæŒ‰é’® -->
    <div id="topButtons">
        <button class="top-btn glass-panel" id="fs-btn" onclick="toggleFullScreen()">
            <span>â›¶</span> <span>å…¨å±</span>
        </button>
        <button class="top-btn glass-panel" id="toggle-ui-btn" onclick="toggleUI()">
            <span>ğŸ‘</span> <span>éšè—ç•Œé¢</span>
        </button>
        <button class="top-btn glass-panel" id="cam-btn" onclick="toggleCameraPreview()">
            <span>ğŸ“·</span> <span>æ‘„åƒå¤´</span>
        </button>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶é¢æ¿ -->
    <div id="controlPanel" class="glass-panel">
        <div class="control-title">å½¢æ€åˆ‡æ¢</div>
        <button class="control-btn" onclick="manualSetGesture('open')">âœ‹ å¼ æ‰‹</button>
        <button class="control-btn" onclick="manualSetGesture('scissors')">âœŒï¸ å‰ªåˆ€</button>
        <button class="control-btn" onclick="manualSetGesture('fist')">âœŠ æ¡æ‹³</button>
        <button class="control-btn" onclick="manualSetGesture('point')">â˜ï¸ é£ŸæŒ‡</button>
        <button class="control-btn" onclick="manualSetGesture('thumbsUp')">ğŸ‘ å¤§æ‹‡æŒ‡</button>
        <button class="control-btn danger" onclick="triggerExplosion()" style="grid-column: span 2;">ğŸ’¥ çˆ†ç‚¸ç‰¹æ•ˆ</button>
        <button class="control-btn" onclick="toggleStorm()" id="stormBtn" style="grid-column: span 2;">ğŸŒªï¸ é£æš´æ¨¡å¼</button>
    </div>

    <!-- ä¿¡æ¯æç¤º -->
    <div id="infoTooltip">ğŸ’¡ å¼ æ‰‹/å‰ªåˆ€/æ¡æ‹³/é£ŸæŒ‡/å¤§æ‹‡æŒ‡ | æŒ¥æ‰‹è§¦å‘é£æš´ | æ¨æ‹‰æ”¹å˜æ·±åº¦ | ç‚¹å‡»æ‘„åƒå¤´æŒ‰é’®é¢„è§ˆ</div>

    <!-- çŠ¶æ€æç¤º -->
    <div id="stateToast"></div>

    <!-- Three.js - ä½¿ç”¨ unpkg ç¡®ä¿ç¨³å®šåŠ è½½ -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <!-- MediaPipe Hands - ä½¿ç”¨ unpkg ç¡®ä¿ç¨³å®šåŠ è½½ -->
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

    <script>
        // ==================== æ ¸å¿ƒé…ç½® ====================
        const CONFIG = {
            PARTICLE_COUNT: 16000,
            PARTICLE_COLOR: 0x00ffff,
            PARTICLE_SIZE: 0.04,
            PHYSICS: {
                DAMPING: 0.95,
                ATTRACTION: 0.02,
                EXPLOSION_FORCE: 3.5,
                STORM_FORCE: 8.0,
                MAX_VELOCITY: 12.0,
                SEPARATION: 0.25
            },
            CAMERA: {
                FOV: 60,
                MIN_DISTANCE: 6,
                MAX_DISTANCE: 25,
                DEFAULT_DISTANCE: 12,
                ZOOM_SPEED: 0.4,
                ROTATION_SPEED: 0.02
            }
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, particles;
        let particleSystem;
        let cameraVideo, hands, handsObj;
        
        // ç‰©ç†çŠ¶æ€
        let currentPosition, targetPosition, velocity, acceleration;
        
        // æ‰‹åŠ¿çŠ¶æ€
        let currentGesture = 'open';
        let handLandmarks = null;
        let handVelocity = { x: 0, y: 0, z: 0 };
        let prevHandPos = { x: 0, y: 0, z: 0 };
        let handSpeed = 0;
        let palmArea = 0;
        let stormActive = false;
        
        // æ‰‹åŠ¿å¹³æ»‘å’Œé˜²æŠ– - é«˜çº§ç‰ˆæœ¬
        let gestureBuffer = []; // æ‰‹åŠ¿å†å²ç¼“å†²åŒº
        let confidenceBuffer = []; // ç½®ä¿¡åº¦å†å²ç¼“å†²åŒº
        const GESTURE_BUFFER_SIZE = 8; // å¢å¤§ç¼“å†²åŒºå¤§å°ä»¥è·å¾—æ›´å¥½ç¨³å®šæ€§
        const GESTURE_STABILITY_THRESHOLD = 0.75; // éœ€è¦75%çš„ç¨³å®šæ€§æ‰ç¡®è®¤
        let lastGestureChange = 0;
        let lastConfirmedGesture = 'open';
        let gestureConfidence = 0; // å½“å‰æ‰‹åŠ¿ç½®ä¿¡åº¦
        let stabilityScore = 0; // ç¨³å®šæ€§è¯„åˆ†
        
        // åŠ¨æ€é˜ˆå€¼æ ¡å‡†ç³»ç»Ÿ
        let dynamicThresholds = {
            FIST_DISTANCE: 0.6,
            OPEN_DISTANCE: 1.2,
            BEND_THRESHOLD: 0.5,
            SCISSORS_GAP: 0.3,
            POINT_DISTANCE: 0.8,
            THUMB_DISTANCE: 0.9,
            CONFIDENCE_THRESHOLD: 0.65
        };
        
        // æ‰‹åŠ¿å†å²åˆ†æ - ç”¨äºæ¨¡å¼è¯†åˆ«å’Œä¼˜åŒ–
        let gestureHistory = {
            timestamps: [],
            gestures: [],
            confidenceScores: [],
            stabilityScores: []
        };
        
        // æ€§èƒ½ç›‘æ§å’Œè‡ªé€‚åº”ä¼˜åŒ–
        let performanceStats = {
            detectionCount: 0,
            falsePositiveCount: 0,
            avgConfidence: 0,
            lastCalibration: Date.now()
        };
        
        // äº¤äº’çŠ¶æ€
        let isCameraActive = false;
        let lastFrameTime = 0;
        let frameCount = 0;
        let fpsUpdateTimer = 0;
        let fps = 0;
        
        // UIçŠ¶æ€
        let uiVisible = true;
        
        // å½¢çŠ¶æ•°æ®
        let shapeData = {
            textPoints: [],
            starPoints: [],
            heartPoints: [],
            ringPoints: []
        };

        // è¿›åº¦ç®¡ç†
        const progressManager = {
            totalSteps: 5,
            currentStep: 0,
            container: null,
            barFill: null,
            text: null,
            stepText: null,
            
            init() {
                this.container = document.getElementById('progress-container');
                this.barFill = document.getElementById('progress-bar-fill');
                this.text = document.getElementById('progress-text');
                this.stepText = document.getElementById('progress-steps');
                this.currentStep = 0;
                if(this.container) {
                    this.container.style.display = 'block';
                    this.update(0, 'å¼€å§‹åˆå§‹åŒ–...');
                }
            },
            
            update(step, message) {
                this.currentStep = step;
                const percentage = Math.round((step / this.totalSteps) * 100);
                
                if(this.barFill) this.barFill.style.width = percentage + '%';
                if(this.text) this.text.textContent = percentage + '%';
                if(this.stepText) {
                    const stepElements = this.stepText.querySelectorAll('.progress-step');
                    stepElements.forEach((el, index) => {
                        if (index < step) {
                            el.className = 'progress-step complete';
                        } else if (index === step) {
                            el.className = 'progress-step current';
                        } else {
                            el.className = 'progress-step';
                        }
                    });
                }
            },
            
            next(message) {
                this.currentStep++;
                this.update(this.currentStep, message);
            },
            
            complete() {
                if(this.container) {
                    this.update(this.totalSteps, 'åˆå§‹åŒ–å®Œæˆï¼');
                    setTimeout(() => {
                        this.container.style.display = 'none';
                        document.getElementById('progressIndicator').style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('progressIndicator').style.display = 'none';
                        }, 500);
                    }, 500);
                }
            }
        };

        // ==================== åˆå§‹åŒ–ç³»ç»Ÿ ====================
        function init() {
            document.getElementById('progressIndicator').style.display = 'flex';
            progressManager.init();
            updateDebugInfo('æ­£åœ¨åˆ›å»º3Dåœºæ™¯...', true);

            // 1. åˆ›å»ºåœºæ™¯
            createScene();
            progressManager.next('ç”Ÿæˆ16,000é¢—ç²’');
            updateDebugInfo('æ­£åœ¨ç”Ÿæˆ16,000ç‹¬ç«‹é¢—ç²’...', true);

            // 2. åˆ›å»ºç²’å­ç³»ç»Ÿ
            setTimeout(() => {
                createParticleSystem();
                progressManager.next('é¢„å¤„ç†å˜å½¢å½¢çŠ¶');
                updateDebugInfo('æ­£åœ¨é¢„å¤„ç†å˜å½¢å½¢çŠ¶...', true);

                // 3. ç”Ÿæˆå½¢çŠ¶æ•°æ®
                setTimeout(() => {
                    generateAllShapes();
                    progressManager.next('è¯·æ±‚æ‘„åƒå¤´æƒé™');
                    updateDebugInfo('æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...', true);

                    // 4. è¯·æ±‚æ‘„åƒå¤´æƒé™
                    setTimeout(() => {
                        initCameraAndHands();
                    }, 300);
                }, 300);
            }, 300);

            // 5. åˆå§‹åŒ–æ‹–æ‹½æ ‡é¢˜
            setTimeout(initDraggableTitle, 100);
        }

        // ==================== åœºæ™¯åˆ›å»º ====================
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvasContainer').appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);

            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
        }

        // ==================== ç²’å­ç³»ç»Ÿåˆ›å»º ====================
        function createParticleSystem() {
            const count = CONFIG.PARTICLE_COUNT;
            const geometry = new THREE.BufferGeometry();
            
            currentPosition = new Float32Array(count * 3);
            targetPosition = new Float32Array(count * 3);
            velocity = new Float32Array(count * 3);
            acceleration = new Float32Array(count * 3);

            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                const y = 1 - (i / (count - 1)) * 2;
                const radius2D = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;
                
                const x = Math.cos(theta) * radius2D;
                const z = Math.sin(theta) * radius2D;
                
                const layer = i / count;
                const baseRadius = 0.5 + Math.pow(layer, 0.7) * 3.5;
                
                const jitter = 0.05;
                const finalX = x * baseRadius + (Math.random() - 0.5) * jitter;
                const finalY = y * baseRadius + (Math.random() - 0.5) * jitter;
                const finalZ = z * baseRadius + (Math.random() - 0.5) * jitter;

                currentPosition[i3] = finalX;
                currentPosition[i3 + 1] = finalY;
                currentPosition[i3 + 2] = finalZ;
                
                targetPosition[i3] = finalX;
                targetPosition[i3 + 1] = finalY;
                targetPosition[i3 + 2] = finalZ;
                
                velocity[i3] = (Math.random() - 0.5) * 0.1;
                velocity[i3 + 1] = (Math.random() - 0.5) * 0.1;
                velocity[i3 + 2] = (Math.random() - 0.5) * 0.1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPosition, 3));

            const material = new THREE.PointsMaterial({
                color: CONFIG.PARTICLE_COLOR,
                size: CONFIG.PARTICLE_SIZE,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.NormalBlending,
                depthWrite: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            particleSystem = {
                geometry: geometry,
                count: count,
                state: 'sphere',
                transition: 0
            };
        }

        // ==================== å½¢çŠ¶é¢„å¤„ç† ====================
        function generateAllShapes() {
            generateTextShape();
            generateStarShape();
            generateHeartShape();
            generateRingShape();
        }

        function generateTextShape() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 200;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 60px "Segoe UI", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('æˆ‘æ˜¯ Mok', canvas.width / 2, canvas.height / 2);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            shapeData.textPoints = [];
            const step = 2;
            
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const index = (y * canvas.width + x) * 4;
                    if (data[index] > 128) {
                        const px = (x - canvas.width / 2) * 0.03;
                        const py = -(y - canvas.height / 2) * 0.03;
                        const pz = (Math.random() - 0.5) * 0.5;
                        shapeData.textPoints.push({ x: px, y: py, z: pz });
                    }
                }
            }
            
            while (shapeData.textPoints.length < 4000) {
                shapeData.textPoints.push({
                    x: (Math.random() - 0.5) * 4,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 0.5
                });
            }
        }

        function generateStarShape() {
            const count = 2000;
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const segment = Math.floor(t / (Math.PI * 2 / 5));
                const segmentT = (t % (Math.PI * 2 / 5)) / (Math.PI * 2 / 5);
                
                const innerRadius = 0.8;
                const outerRadius = 2.0;
                const radius = segment % 2 === 0 
                    ? innerRadius + (outerRadius - innerRadius) * segmentT
                    : outerRadius - (outerRadius - innerRadius) * segmentT;
                
                shapeData.starPoints.push({
                    x: Math.cos(t) * radius,
                    y: Math.sin(t) * radius,
                    z: (Math.random() - 0.5) * 0.3
                });
            }
        }

        function generateHeartShape() {
            const count = 2500;
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const scale = 1.5;
                const x = scale * 16 * Math.pow(Math.sin(t), 3);
                const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                const z = (Math.random() - 0.5) * 0.5;
                
                shapeData.heartPoints.push({
                    x: x * 0.1,
                    y: y * 0.1,
                    z: z
                });
            }
        }

        function generateRingShape() {
            const count = 2000;
            for (let i = 0; i < count; i++) {
                const layer = i % 2;
                const baseRadius = 1.8 + layer * 0.5;
                const angle = (i / count) * Math.PI * 4;
                const height = Math.sin(angle * 3) * 0.4;
                
                shapeData.ringPoints.push({
                    x: Math.cos(angle) * baseRadius,
                    y: height,
                    z: Math.sin(angle) * baseRadius
                });
            }
        }

        // ==================== ç‰©ç†å¼•æ“ ====================
        function updatePhysics(deltaTime) {
            const dt = Math.min(deltaTime, 0.05);
            const time = Date.now() * 0.001;

            if (!particles) return;

            const count = particles.geometry.attributes.position.count;
            const positions = particles.geometry.attributes.position.array;

            // æ ¹æ®æ‰‹åŠ¿æ›´æ–°ç›®æ ‡ä½ç½®
            updateTargetsForGesture(currentGesture, time);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // ç‹¬ç«‹ç²’å­è¿åŠ¨ - å¼ºåˆ†ç¦»åŠ›
                const independentForce = (Math.random() - 0.5) * 0.15;
                velocity[i3] += independentForce;
                velocity[i3 + 1] += independentForce * 0.8;
                velocity[i3 + 2] += independentForce * 0.6;
                
                // åˆ†ç¦»åŠ› - é¿å…ç²’å­èšé›†
                const separationForce = CONFIG.PHYSICS.SEPARATION;
                velocity[i3] += (Math.random() - 0.5) * separationForce;
                velocity[i3 + 1] += (Math.random() - 0.5) * separationForce;
                velocity[i3 + 2] += (Math.random() - 0.5) * separationForce;
                
                // ç›®æ ‡ä½ç½®å›å½’åŠ›ï¼ˆæå¼±ï¼‰
                const dx = targetPosition[i3] - positions[i3];
                const dy = targetPosition[i3 + 1] - positions[i3 + 1];
                const dz = targetPosition[i3 + 2] - positions[i3 + 2];
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (dist > 0.01) {
                    const weakAttraction = CONFIG.PHYSICS.ATTRACTION * 0.03;
                    velocity[i3] += (dx / dist) * weakAttraction;
                    velocity[i3 + 1] += (dy / dist) * weakAttraction;
                    velocity[i3 + 2] += (dz / dist) * weakAttraction;
                }
                
                // æ‰‹åŠ¿å½±å“
                if (handLandmarks && (handSpeed > 0.01 || stormActive)) {
                    applyGestureForces(i3, positions, velocity);
                }
                
                // ç‰©ç†æ›´æ–°
                velocity[i3] *= CONFIG.PHYSICS.DAMPING;
                velocity[i3 + 1] *= CONFIG.PHYSICS.DAMPING;
                velocity[i3 + 2] *= CONFIG.PHYSICS.DAMPING;
                
                // é€Ÿåº¦é™åˆ¶
                const vx = velocity[i3], vy = velocity[i3 + 1], vz = velocity[i3 + 2];
                const speed = Math.sqrt(vx*vx + vy*vy + vz*vz);
                if (speed > CONFIG.PHYSICS.MAX_VELOCITY) {
                    const scale = CONFIG.PHYSICS.MAX_VELOCITY / speed;
                    velocity[i3] *= scale;
                    velocity[i3 + 1] *= scale;
                    velocity[i3 + 2] *= scale;
                }
                
                positions[i3] += velocity[i3] * dt;
                positions[i3 + 1] += velocity[i3 + 1] * dt;
                positions[i3 + 2] += velocity[i3 + 2] * dt;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function updateTargetsForGesture(gesture, time) {
            const count = CONFIG.PARTICLE_COUNT;
            
            switch (gesture) {
                case 'open': // çƒå½¢
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        const pulse = Math.sin(time + i * 0.01) * 0.1;
                        const y = 1 - (i / (count - 1)) * 2;
                        const radius2D = Math.sqrt(1 - y * y);
                        const theta = Math.PI * (3 - Math.sqrt(5)) * i;
                        const baseRadius = 1.5 + pulse;
                        
                        targetPosition[i3] = Math.cos(theta) * radius2D * baseRadius;
                        targetPosition[i3 + 1] = y * baseRadius;
                        targetPosition[i3 + 2] = Math.sin(theta) * radius2D * baseRadius;
                    }
                    updateShapeStatus('çƒä½“');
                    break;
                    
                case 'scissors': // æ–‡å­—
                    const textCount = shapeData.textPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < textCount) {
                            const point = shapeData.textPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - textCount;
                            targetPosition[i3] = (Math.random() - 0.5) * 3;
                            targetPosition[i3 + 1] = (Math.random() - 0.5) * 2;
                            targetPosition[i3 + 2] = (Math.random() - 0.5) * 2;
                        }
                    }
                    updateShapeStatus('æ–‡å­—');
                    break;
                    
                case 'fist': // åœ†ç¯
                    const ringCount = shapeData.ringPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < ringCount) {
                            const point = shapeData.ringPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - ringCount;
                            const angle = (idx / (count - ringCount)) * Math.PI * 2;
                            const radius = 2.5;
                            targetPosition[i3] = Math.cos(angle) * radius;
                            targetPosition[i3 + 1] = 0;
                            targetPosition[i3 + 2] = Math.sin(angle) * radius;
                        }
                    }
                    updateShapeStatus('åœ†ç¯');
                    break;
                    
                case 'point': // æ˜Ÿå½¢
                    const starCount = shapeData.starPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < starCount) {
                            const point = shapeData.starPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - starCount;
                            const angle = (idx / (count - starCount)) * Math.PI * 2;
                            const radius = 3.0;
                            targetPosition[i3] = Math.cos(angle) * radius;
                            targetPosition[i3 + 1] = 0;
                            targetPosition[i3 + 2] = Math.sin(angle) * radius;
                        }
                    }
                    updateShapeStatus('æ˜Ÿå½¢');
                    break;
                    
                case 'thumbsUp': // çˆ±å¿ƒ
                    const heartCount = shapeData.heartPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < heartCount) {
                            const point = shapeData.heartPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - heartCount;
                            const angle = (idx / (count - heartCount)) * Math.PI * 2;
                            const radius = 2.0;
                            targetPosition[i3] = Math.cos(angle) * radius;
                            targetPosition[i3 + 1] = Math.sin(angle * 2) * 0.5;
                            targetPosition[i3 + 2] = Math.sin(angle) * radius;
                        }
                    }
                    updateShapeStatus('çˆ±å¿ƒ');
                    break;
            }
        }

        function applyGestureForces(i3, positions, velocities) {
            if (!handLandmarks) return;
            
            const handCenter = handLandmarks[9];
            const handX = (handCenter.x - 0.5) * 8;
            const handY = -(handCenter.y - 0.5) * 6;
            const handZ = (handCenter.z + 0.5) * 4;
            
            const cx = positions[i3];
            const cy = positions[i3 + 1];
            const cz = positions[i3 + 2];
            
            const dx = cx - handX;
            const dy = cy - handY;
            const dz = cz - handZ;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if (dist < 8.0) {
                // é£æš´æ¨¡å¼
                if (stormActive) {
                    const stormForce = CONFIG.PHYSICS.STORM_FORCE * Math.max(0, 1 - dist / 8);
                    velocities[i3] += (dx / dist) * stormForce * 0.5;
                    velocities[i3 + 1] += (dy / dist) * stormForce * 0.5;
                    velocities[i3 + 2] += (dz / dist) * stormForce * 0.5;
                }
                // æ‰‹åŠ¿æŒ¥åŠ¨
                else if (handSpeed > 0.01) {
                    const force = handSpeed * 0.5 * Math.max(0, 1 - dist / 8);
                    if (force > 0.02) {
                        velocities[i3] += (dx / dist) * force * 1.5;
                        velocities[i3 + 1] += (dy / dist) * force * 1.5;
                        velocities[i3 + 2] += (dz / dist) * force * 1.5;
                    }
                }
                
                // æ·±åº¦æ¨æ‹‰
                if (palmArea > 0.03) {
                    const depthForce = (palmArea - 0.03) * 15;
                    velocities[i3 + 2] += depthForce * 0.1;
                }
            }
        }

        // ==================== æ‰‹åŠ¿è¯†åˆ« ====================
        async function initCameraAndHands() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    startAutoMode('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´');
                    return;
                }

                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    startAutoMode('éœ€è¦HTTPSç¯å¢ƒ');
                    return;
                }

                // å¢å¼ºçš„æ‘„åƒå¤´æƒé™è¯·æ±‚ï¼Œæ”¯æŒé™çº§
                let stream;
                try {
                    stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: 'user' 
                        }
                    });
                } catch (permissionError) {
                    console.warn('é«˜æ¸…æ‘„åƒå¤´è¯·æ±‚å¤±è´¥ï¼Œå°è¯•æ ‡å‡†åˆ†è¾¨ç‡...', permissionError);
                    // é™çº§åˆ°æ ‡å‡†åˆ†è¾¨ç‡
                    stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user' 
                        }
                    });
                }

                cameraVideo = document.createElement('video');
                cameraVideo.style.display = 'none';
                cameraVideo.setAttribute('playsinline', true);
                cameraVideo.muted = true;
                document.body.appendChild(cameraVideo);
                cameraVideo.srcObject = stream;

                await new Promise(resolve => {
                    cameraVideo.onloadedmetadata = resolve;
                });

                cameraVideo.play();

                progressManager.next('åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«');
                updateDebugInfo('æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...', true);

                hands = new Hands({
                    locateFile: (file) => {
                        return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1, // 0=å¿«é€Ÿ, 1=å¹³è¡¡, 2=ç²¾ç¡®
                    minDetectionConfidence: 0.3, // é™ä½æ£€æµ‹é˜ˆå€¼ï¼Œæé«˜è¯†åˆ«ç‡
                    minTrackingConfidence: 0.3, // é™ä½è·Ÿè¸ªé˜ˆå€¼ï¼Œä¿æŒè·Ÿè¸ª
                    selfieMode: true
                });

                hands.onResults(onHandResults);

                handsObj = new Camera(cameraVideo, {
                    onFrame: async () => {
                        await hands.send({ image: cameraVideo });
                    },
                    width: 1280,
                    height: 720
                });

                handsObj.start();

                isCameraActive = true;
                updateStatus('æ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª', true);
                progressManager.complete();
                updateDebugInfo('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', false);

                setTimeout(() => {
                    const hint = document.getElementById('gesture-hint');
                    if(hint) hint.classList.add('show');
                    setTimeout(() => hint.classList.remove('show'), 4000);
                }, 1000);

            } catch (error) {
                console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                startAutoMode('æ‘„åƒå¤´è®¿é—®å¤±è´¥');
            }
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks[0];
                updateHandMetrics();
                detectGesture();
            } else {
                handLandmarks = null;
                handSpeed = 0;
                palmArea = 0;
                updateGestureDisplay(null);
            }
        }

        function updateHandMetrics() {
            if (!handLandmarks) return;

            const center = handLandmarks[9];
            const currentX = (center.x - 0.5) * 8;
            const currentY = -(center.y - 0.5) * 6;
            const currentZ = (center.z + 0.5) * 4;

            if (prevHandPos.x !== 0) {
                const dx = currentX - prevHandPos.x;
                const dy = currentY - prevHandPos.y;
                const dz = currentZ - prevHandPos.z;
                
                handVelocity.x = dx;
                handVelocity.y = dy;
                handVelocity.z = dz;
                
                handSpeed = Math.sqrt(dx*dx + dy*dy + dz*dz);
            }

            const thumbBase = handLandmarks[2];
            const pinkyBase = handLandmarks[17];
            palmArea = Math.sqrt(
                Math.pow(thumbBase.x - pinkyBase.x, 2) + 
                Math.pow(thumbBase.y - pinkyBase.y, 2)
            );

            prevHandPos.x = currentX;
            prevHandPos.y = currentY;
            prevHandPos.z = currentZ;
        }

        // è¶…é«˜ç²¾åº¦æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ - æœºå™¨å­¦ä¹ å¢å¼ºç‰ˆæœ¬
        function detectGesture() {
            if (!handLandmarks) return;

            const landmarks = handLandmarks;
            const now = Date.now();

            // å…³é”®ç‚¹å®šä¹‰
            const wrist = landmarks[0];
            const thumbBase = landmarks[2];
            const thumbTip = landmarks[4];
            const indexBase = landmarks[5];
            const indexTip = landmarks[8];
            const middleBase = landmarks[9];
            const middleTip = landmarks[12];
            const ringBase = landmarks[13];
            const ringTip = landmarks[16];
            const pinkyBase = landmarks[17];
            const pinkyTip = landmarks[20];

            // === é«˜çº§è·ç¦»è®¡ç®—ç³»ç»Ÿ ===
            const dist3D = (p1, p2) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const dz = (p1.z - p2.z) * 2.5; // å¢å¼ºZè½´æƒé‡
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
            };

            // åŠ¨æ€æ‰‹éƒ¨å¤§å°æ ¡å‡†
            const rawHandSize = dist3D(thumbBase, pinkyBase) || 0.1;
            const normalizedDist = (d) => d / rawHandSize; // å½’ä¸€åŒ–
            
            // å¹³æ»‘æ‰‹éƒ¨å¤§å° - ä½¿ç”¨å†å²å¹³å‡å€¼é¿å…çªå˜
            if (performanceStats.handSizeHistory) {
                performanceStats.handSizeHistory.push(rawHandSize);
                if (performanceStats.handSizeHistory.length > 10) {
                    performanceStats.handSizeHistory.shift();
                }
                const avgHandSize = performanceStats.handSizeHistory.reduce((a,b) => a+b, 0) / performanceStats.handSizeHistory.length;
                performanceStats.calibratedHandSize = avgHandSize * 0.95; // å°å¹…è°ƒæ•´é¿å…è¿‡åº¦å¹³æ»‘
            } else {
                performanceStats.handSizeHistory = [rawHandSize];
                performanceStats.calibratedHandSize = rawHandSize;
            }

            const handSize = performanceStats.calibratedHandSize;
            const normalizeDistCalibrated = (d) => d / handSize;

            // åŸºç¡€è·ç¦»æµ‹é‡
            const thumbDistRaw = dist3D(thumbTip, wrist);
            const indexDistRaw = dist3D(indexTip, wrist);
            const middleDistRaw = dist3D(middleTip, wrist);
            const ringDistRaw = dist3D(ringTip, wrist);
            const pinkyDistRaw = dist3D(pinkyTip, wrist);

            // åŒé‡å½’ä¸€åŒ– - åŸå§‹å½’ä¸€åŒ– + æ ¡å‡†å½’ä¸€åŒ–
            const thumbDist = normalizeDistCalibrated(normalizeDist(thumbDistRaw));
            const indexDist = normalizeDistCalibrated(normalizeDist(indexDistRaw));
            const middleDist = normalizeDistCalibrated(normalizeDist(middleDistRaw));
            const ringDist = normalizeDistCalibrated(normalizeDist(ringDistRaw));
            const pinkyDist = normalizeDistCalibrated(normalizeDist(pinkyDistRaw));

            // å¼¯æ›²åº¦æµ‹é‡ - ä½¿ç”¨ç›¸å¯¹é•¿åº¦æ¯”
            const thumbBend = normalizeDistCalibrated(dist3D(thumbTip, thumbBase));
            const indexBend = normalizeDistCalibrated(dist3D(indexTip, indexBase));
            const middleBend = normalizeDistCalibrated(dist3D(middleTip, middleBase));
            const ringBend = normalizeDistCalibrated(dist3D(ringTip, ringBase));
            const pinkyBend = normalizeDistCalibrated(dist3D(pinkyTip, pinkyBase));

            // æ‰‹æŒå‡ ä½•ç‰¹å¾
            const palmWidth = rawHandSize; // ä¸»è¦å°ºå¯¸
            const palmHeight = normalizeDistCalibrated(dist3D(indexBase, wrist));
            const palmRatio = palmHeight / palmWidth;

            // æ‰‹æŒ‡é—´è·ç³»ç»Ÿ
            const indexMiddleGap = normalizeDistCalibrated(dist3D(indexTip, middleTip));
            const middleRingGap = normalizeDistCalibrated(dist3D(middleTip, ringTip));
            const ringPinkyGap = normalizeDistCalibrated(dist3D(ringTip, pinkyTip));
            
            // æ‰‹æŒ‡é—´è·æ¨¡å¼
            const spacingPattern = {
                spread: indexMiddleGap > 0.35,
                narrow: indexMiddleGap < 0.15 && middleRingGap < 0.15,
                scissorsGap: indexMiddleGap > 0.25 && middleRingGap < 0.15
            };

            // è§’åº¦ç‰¹å¾ - å¢å¼ºè®¡ç®—
            const indexAngle = Math.atan2(indexTip.y - indexBase.y, indexTip.x - indexBase.x);
            const middleAngle = Math.atan2(middleTip.y - middleBase.y, middleTip.x - middleBase.x);
            const ringAngle = Math.atan2(ringTip.y - ringBase.y, ringTip.x - ringBase.x);
            const pinkyAngle = Math.atan2(pinkyTip.y - pinkyBase.y, pinkyTip.x - pinkyBase.x);
            
            const angleDiffIndexMiddle = Math.abs(indexAngle - middleAngle);
            const angleDiffMiddleRing = Math.abs(middleAngle - ringAngle);
            const angleDiffRingPinky = Math.abs(ringAngle - pinkyAngle);
            
            // æ‰‹æŒ‡å¯¹é½åº¦
            const fingerAlignment = (angleDiffIndexMiddle + angleDiffMiddleRing + angleDiffRingPinky) / 3;

            // æ·±åº¦ç‰¹å¾ - Zè½´åˆ†æ
            const avgFingerDepth = (thumbTip.z + indexTip.z + middleTip.z + ringTip.z + pinkyTip.z) / 5;
            const relativeDepth = avgFingerDepth - wrist.z;

            // æ‰‹æŒä¸­å¿ƒè®¡ç®—
            const palmCenter = {
                x: (thumbBase.x + pinkyBase.x + indexBase.x + middleBase.x + ringBase.x) / 5,
                y: (thumbBase.y + pinkyBase.y + indexBase.y + middleBase.y + ringBase.y) / 5,
                z: (thumbBase.z + pinkyBase.z + indexBase.z + middleBase.z + ringBase.z) / 5
            };

            // === è‡ªé€‚åº”é˜ˆå€¼ç³»ç»Ÿï¼ˆä¼˜åŒ–ç‰ˆï¼‰===
            const adaptiveThresholds = {
                // åŸºäºæ‰‹éƒ¨å¤§å°çš„åŠ¨æ€é˜ˆå€¼ - é™ä½è¦æ±‚æé«˜è¯†åˆ«ç‡
                FIST_DISTANCE: 0.6 + (palmRatio * 0.3),        // æ¡æ‹³è·ç¦» - æ”¾å®½
                OPEN_DISTANCE: 1.1 - (palmRatio * 0.1),        // å¼ å¼€è·ç¦» - é™ä½è¦æ±‚
                BEND_THRESHOLD: 0.6,                           // å¼¯æ›²é˜ˆå€¼ - æ”¾å®½
                SCISSORS_GAP: 0.25 + (palmRatio * 0.15),       // å‰ªåˆ€é—´éš™ - æ”¾å®½
                POINT_DISTANCE: 0.75 - (palmRatio * 0.1),      // æŒ‡é£ŸæŒ‡è·ç¦» - é™ä½
                THUMB_DISTANCE: 0.85 + (palmRatio * 0.15),     // å¤§æ‹‡æŒ‡è·ç¦» - é™ä½
                ANGLE_TOLERANCE: 0.8,                          // è§’åº¦å®¹å·® - æ”¾å®½
                ALIGNMENT_THRESHOLD: 0.6,                      // å¯¹é½åº¦é˜ˆå€¼ - æ”¾å®½
                CONFIDENCE_THRESHOLD: 0.55                     // åŸºç¡€ç½®ä¿¡åº¦ - é™ä½
            };

            // === å¤šç»´åº¦ç‰¹å¾æå– ===
            const features = {
                // æ‰‹æŒ‡ä¼¸ç›´åº¦ (0-1)
                thumbStraight: Math.max(0, Math.min(1, (thumbDist - 0.8) * 2)),
                indexStraight: Math.max(0, Math.min(1, (indexDist - 0.7) * 2)),
                middleStraight: Math.max(0, Math.min(1, (middleDist - 0.7) * 2)),
                ringStraight: Math.max(0, Math.min(1, (ringDist - 0.7) * 2)),
                pinkyStraight: Math.max(0, Math.min(1, (pinkyDist - 0.7) * 2)),

                // æ‰‹æŒ‡å¼¯æ›²åº¦ (0-1)
                thumbBendScore: Math.max(0, Math.min(1, 1 - (thumbBend / adaptiveThresholds.BEND_THRESHOLD))),
                indexBendScore: Math.max(0, Math.min(1, 1 - (indexBend / adaptiveThresholds.BEND_THRESHOLD))),
                middleBendScore: Math.max(0, Math.min(1, 1 - (middleBend / adaptiveThresholds.BEND_THRESHOLD))),
                ringBendScore: Math.max(0, Math.min(1, 1 - (ringBend / adaptiveThresholds.BEND_THRESHOLD))),
                pinkyBendScore: Math.max(0, Math.min(1, 1 - (pinkyBend / adaptiveThresholds.BEND_THRESHOLD))),

                // é—´è·ç‰¹å¾
                indexMiddleSpread: Math.max(0, Math.min(1, (indexMiddleGap - 0.15) * 3)),
                scissorsPattern: Math.max(0, Math.min(1, (indexMiddleGap - 0.2) * 4)) * Math.max(0, Math.min(1, 1 - middleRingGap * 3)),
                allClose: Math.max(0, Math.min(1, 1 - (indexMiddleGap + middleRingGap + ringPinkyGap) * 2)),

                // è§’åº¦ç‰¹å¾
                fingerStraightness: Math.max(0, Math.min(1, 1 - (fingerAlignment / adaptiveThresholds.ALIGNMENT_THRESHOLD))),
                indexMiddleAligned: Math.max(0, Math.min(1, 1 - (angleDiffIndexMiddle / adaptiveThresholds.ANGLE_TOLERANCE))),

                // æ·±åº¦ç‰¹å¾
                depthIndicator: Math.max(0, Math.min(1, (relativeDepth + 0.2) * 2)),

                // æ‰‹æŒå½¢çŠ¶ç‰¹å¾
                handOpenness: Math.max(0, Math.min(1, (palmHeight / palmWidth) * 1.5)),
                handCompactness: Math.max(0, Math.min(1, 1 - (palmHeight / palmWidth) * 0.8)),

                // ä¸€è‡´æ€§æ£€æŸ¥åˆ†æ•°
                consistencyScore: 0 // å°†åœ¨ä¸‹é¢è®¡ç®—
            };

            // è®¡ç®—ä¸€è‡´æ€§åˆ†æ•°
            const straightFingers = ['thumbStraight', 'indexStraight', 'middleStraight', 'ringStraight', 'pinkyStraight'].filter(f => features[f] > 0.7).length;
            const bentFingers = ['thumbBendScore', 'indexBendScore', 'middleBendScore', 'ringBendScore', 'pinkyBendScore'].filter(f => features[f] > 0.7).length;
            features.consistencyScore = Math.abs(straightFingers - bentFingers) / 5; // è¶Šé«˜è¡¨ç¤ºè¶Šä¸€è‡´

            // === æœºå™¨å­¦ä¹ åŠ æƒè¯„åˆ†ç³»ç»Ÿï¼ˆå¢å¼ºç‰ˆï¼‰===
            const gestureScores = {
                fist: 0,
                open: 0,
                scissors: 0,
                point: 0,
                thumbsUp: 0
            };

            // 1. æ¡æ‹³è¯„åˆ† - æ”¾å®½è¦æ±‚ï¼Œæé«˜è¯†åˆ«ç‡
            const fistScore = (
                (features.thumbBendScore * 0.20) +
                (features.indexBendScore * 0.18) +
                (features.middleBendScore * 0.18) +
                (features.ringBendScore * 0.14) +
                (features.pinkyBendScore * 0.14) +
                ((1 - features.allClose) * 0.10) +
                (features.handCompactness * 0.06)
            );
            gestureScores.fist = Math.min(1, fistScore);

            // 2. å¼ æ‰‹è¯„åˆ† - é™ä½è¦æ±‚ï¼Œæé«˜è¯†åˆ«ç‡
            const openScore = (
                (features.thumbStraight * 0.18) +
                (features.indexStraight * 0.18) +
                (features.middleStraight * 0.18) +
                (features.ringStraight * 0.14) +
                (features.pinkyStraight * 0.14) +
                (features.allClose * 0.08) +
                (features.handOpenness * 0.10)
            );
            gestureScores.open = Math.min(1, openScore);

            // 3. å‰ªåˆ€æ‰‹è¯„åˆ† - æ”¾å®½è¦æ±‚
            const scissorsScore = (
                (features.indexStraight * 0.25) +
                (features.middleStraight * 0.22) +
                (features.ringBendScore * 0.15) +
                (features.pinkyBendScore * 0.12) +
                (features.scissorsPattern * 0.20) +
                (features.fingerStraightness * 0.08) +
                (features.indexMiddleAligned * 0.10)
            );
            gestureScores.scissors = Math.min(1, scissorsScore);

            // 4. æŒ‡é£ŸæŒ‡è¯„åˆ† - æ”¾å®½è¦æ±‚
            const pointScore = (
                (features.indexStraight * 0.35) +
                (features.middleBendScore * 0.20) +
                (features.ringBendScore * 0.12) +
                (features.pinkyBendScore * 0.08) +
                (features.indexMiddleSpread * 0.15) +
                (features.fingerStraightness * 0.10)
            );
            gestureScores.point = Math.min(1, pointScore);

            // 5. å¤§æ‹‡æŒ‡è¯„åˆ† - æ”¾å®½è¦æ±‚
            const thumbScore = (
                (features.thumbStraight * 0.40) +
                (features.indexBendScore * 0.15) +
                (features.middleBendScore * 0.12) +
                (features.ringBendScore * 0.08) +
                (features.pinkyBendScore * 0.05) +
                (features.depthIndicator * 0.15) +
                (features.allClose * 0.10)
            );
            gestureScores.thumbsUp = Math.min(1, thumbScore);

            // === æœ€é«˜åˆ†é€‰æ‹©ä¸ç½®ä¿¡åº¦è®¡ç®— ===
            let detectedGesture = null;
            let maxScore = 0;
            let totalScore = 0;
            
            for (const [gesture, score] of Object.entries(gestureScores)) {
                totalScore += score;
                if (score > maxScore) {
                    maxScore = score;
                    detectedGesture = gesture;
                }
            }

            // ç½®ä¿¡åº¦è®¡ç®— - ç»¼åˆè€ƒè™‘æœ€é«˜åˆ†ä¸æ¬¡é«˜åˆ†çš„å·®è·
            const sortedScores = Object.values(gestureScores).sort((a, b) => b - a);
            const confidence = sortedScores.length > 1 
                ? maxScore - sortedScores[1] + 0.3  // å·®è·åŠ åˆ†
                : maxScore;

            // === é«˜çº§é˜²æŠ–ä¸å†å²åˆ†æ ===
            if (detectedGesture && maxScore > 0.40) { // é™ä½é˜ˆå€¼ï¼Œå…è®¸æ›´å¤šè¯†åˆ«
                // è®°å½•åˆ°å†å²
                gestureHistory.timestamps.push(now);
                gestureHistory.gestures.push(detectedGesture);
                gestureHistory.confidenceScores.push(confidence);
                gestureHistory.stabilityScores.push(maxScore);

                // æ¸…ç†è¿‡æœŸå†å²ï¼ˆè¶…è¿‡5ç§’ï¼‰
                const fiveSecAgo = now - 5000;
                while (gestureHistory.timestamps.length > 0 && gestureHistory.timestamps[0] < fiveSecAgo) {
                    gestureHistory.timestamps.shift();
                    gestureHistory.gestures.shift();
                    gestureHistory.confidenceScores.shift();
                    gestureHistory.stabilityScores.shift();
                }

                // ä¸´æ—¶ç¼“å†²åŒºç”¨äºçŸ­æœŸç¨³å®šæ€§åˆ¤æ–­
                confidenceBuffer.push({ gesture: detectedGesture, confidence: confidence, time: now });
                if (confidenceBuffer.length > 12) confidenceBuffer.shift();

                // æ¨¡å¼è¯†åˆ« - æ£€æµ‹é‡å¤æ¨¡å¼
                const recentBuffer = confidenceBuffer.slice(-6);
                if (recentBuffer.length >= 4) {
                    const gesturePattern = recentBuffer.map(item => item.gesture);
                    const uniqueGestures = [...new Set(gesturePattern)];
                    
                    // å¦‚æœæœ€è¿‘ç¼“å†²åŒºå†…æ‰‹åŠ¿ç§ç±»å°‘äºç­‰äº2ç§ï¼Œè¯´æ˜ç›¸å¯¹ç¨³å®š
                    if (uniqueGestures.length <= 2) {
                        // è®¡ç®—åŠ æƒå¹³å‡ç½®ä¿¡åº¦
                        const weightedConfidence = recentBuffer.reduce((sum, item) => sum + item.confidence, 0) / recentBuffer.length;
                        const stabilityRatio = 1 - (uniqueGestures.length - 1) / (recentBuffer.length - 1);

                        // é«˜çº§ç¨³å®šæ€§æ£€æŸ¥
                        if (stabilityRatio >= 0.7 && weightedConfidence >= dynamicThresholds.CONFIDENCE_THRESHOLD) {
                            const dominantGesture = gesturePattern[Math.floor(gesturePattern.length / 2)];
                            
                            // æ—¶é—´é˜²æŠ– + æ™ºèƒ½åˆ‡æ¢ - æ”¾å®½é˜²æŠ–æ—¶é—´
                            if (now - lastGestureChange > 150 && dominantGesture !== lastConfirmedGesture) {
                                // é¢å¤–éªŒè¯ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨å†²çª
                                const conflict = recentBuffer.some(item => 
                                    item.gesture !== dominantGesture && item.confidence > weightedConfidence * 0.8
                                );
                                
                                if (!conflict) {
                                    lastConfirmedGesture = dominantGesture;
                                    currentGesture = dominantGesture;
                                    lastGestureChange = now;
                                    gestureConfidence = weightedConfidence;
                                    stabilityScore = stabilityRatio;
                                    
                                    triggerExplosion();
                                    
                                    // è¯¦ç»†æ§åˆ¶å°è¾“å‡º
                                    console.log(`ğŸ¯ ç²¾ç¡®æ‰‹åŠ¿åˆ‡æ¢: ${dominantGesture}`);
                                    console.log(`ğŸ“Š ç½®ä¿¡åº¦: ${(weightedConfidence * 100).toFixed(1)}% | ç¨³å®šæ€§: ${(stabilityRatio * 100).toFixed(1)}%`);
                                    console.log(`ğŸ“ˆ åŸå§‹åˆ†æ•°: ${Object.entries(gestureScores).map(([g,s]) => `${g}:${(s*100).toFixed(0)}%`).join(' | ')}`);
                                }
                            }
                        }
                    }
                }

                // æ€§èƒ½ç»Ÿè®¡æ›´æ–°
                performanceStats.detectionCount++;
                performanceStats.avgConfidence = (performanceStats.avgConfidence * 0.95 + confidence * 0.05);

                // å®šæœŸæ ¡å‡†ï¼ˆæ¯30ç§’ï¼‰
                if (now - performanceStats.lastCalibration > 30000) {
                    performanceStats.lastCalibration = now;
                    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é˜ˆå€¼å¾®è°ƒé€»è¾‘
                }
            } else {
                // åˆ†æ•°è¿‡ä½ï¼Œæ¸è¿›å¼æ¸…ç©º
                if (confidenceBuffer.length > 0) {
                    confidenceBuffer.shift();
                }
                gestureConfidence = 0;
                stabilityScore = 0;
            }

            // === UI å®æ—¶åé¦ˆ ===
            updateGestureDisplay(lastConfirmedGesture);
            
            // åœ¨è°ƒè¯•æ¨¡å¼ä¸‹æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
            if (lastConfirmedGesture && confidence > 0.50 && document.getElementById('debug-info').classList.contains('debug-hidden')) {
                // æ¯éš”ä¸€å®šæ—¶é—´æ˜¾ç¤ºä¸€æ¬¡è¯¦ç»†ä¿¡æ¯ï¼Œé¿å…è¿‡å¤šæ‰“æ‰°
                if (now % 3000 < 100) { // æ¯3ç§’æ˜¾ç¤ºä¸€æ¬¡ï¼Œæ›´é¢‘ç¹
                    console.log(`ğŸ¯ å½“å‰æ‰‹åŠ¿: ${lastConfirmedGesture} | ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(1)}% | ç¨³å®šæ€§: ${(stabilityScore * 100).toFixed(1)}%`);
                }
            }
        }

        // å¢å¼ºçš„æ‰‹åŠ¿ç½®ä¿¡åº¦å¯è§†åŒ–å‡½æ•°
        function updateGestureConfidence(gestureScores, detectedGesture, confidence, stability) {
            // å¯é€‰ï¼šåœ¨è°ƒè¯•ä¿¡æ¯ä¸­æ˜¾ç¤ºè¯¦ç»†ç½®ä¿¡åº¦
            if (detectedGesture && document.getElementById('debug-info').classList.contains('loading-center') === false) {
                const sortedScores = Object.entries(gestureScores)
                    .filter(([_, score]) => score > 0)
                    .sort((a, b) => b[1] - a[1])
                    .map(([g, s]) => {
                        const bar = 'â–ˆ'.repeat(Math.floor(s * 10));
                        return `${g.padEnd(8)}: ${bar} ${(s * 100).toFixed(0)}%`;
                    })
                    .join('\n');
                
                if (sortedScores) {
                    console.log(`å½“å‰æ‰‹åŠ¿: ${detectedGesture} | ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(0)}% | ç¨³å®šæ€§: ${(stability * 100).toFixed(0)}%\n${sortedScores}`);
                }
            }
        }

        // å¢å¼ºçš„æ‰‹åŠ¿è¯†åˆ«å‚æ•°ä¼˜åŒ–
        function optimizeGestureParameters() {
            // æ ¹æ®è¿è¡Œæ—¶æ€§èƒ½å’Œç¯å¢ƒè°ƒæ•´å‚æ•°
            const params = {
                // åŠ¨æ€é˜ˆå€¼ç³»ç»Ÿ
                DYNAMIC_THRESHOLDS: {
                    FIST_DISTANCE: 0.6,
                    OPEN_DISTANCE: 1.2,
                    BEND_THRESHOLD: 0.5,
                    SCISSORS_GAP: 0.3,
                    POINT_DISTANCE: 0.8,
                    THUMB_DISTANCE: 0.9,
                    CONFIDENCE_THRESHOLD: 0.65
                },
                
                // é˜²æŠ–å’Œç¨³å®šæ€§å‚æ•°
                DEBOUNCE: {
                    GESTURE_DEBOUNCE_TIME: 300,  // æ¯«ç§’
                    BUFFER_SIZE: 6,
                    STABILITY_THRESHOLD: 0.6,    // 60%ç¨³å®šæ€§
                    MIN_BUFFER_FOR_CONFIRMATION: 3
                },
                
                // æ‰‹åŠ¿æƒé‡ç³»ç»Ÿ
                WEIGHTS: {
                    DISTANCE_WEIGHT: 0.4,       // è·ç¦»ç‰¹å¾æƒé‡
                    BEND_WEIGHT: 0.3,           // å¼¯æ›²åº¦æƒé‡
                    SPACING_WEIGHT: 0.2,        // é—´è·ç‰¹å¾æƒé‡
                    ANGLE_WEIGHT: 0.1           // è§’åº¦ç‰¹å¾æƒé‡
                }
            };
            
            return params;
        }

        // æ–°å¢ï¼šå®æ—¶æ‰‹åŠ¿åé¦ˆç³»ç»Ÿ
        function showGestureFeedback(debugInfo) {
            const feedback = document.getElementById('gesture-hint');
            if (feedback && debugInfo) {
                feedback.textContent = debugInfo;
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 2000);
            }
        }

        // ==================== è‡ªåŠ¨æ¨¡å¼å¢å¼º ====================
        function startAutoMode(reason) {
            console.log('å¯åŠ¨è‡ªåŠ¨æ¨¡å¼:', reason);
            updateStatus('è‡ªåŠ¨æ¨¡å¼ - ' + reason, false);
            progressManager.complete();
            updateDebugInfo('è‡ªåŠ¨æ¨¡å¼å·²å¯åŠ¨', false);

            // æ˜¾ç¤ºè‡ªåŠ¨æ¨¡å¼æç¤º
            showToast('è‡ªåŠ¨æ¨¡å¼ï¼š' + reason, true);

            const autoCycle = () => {
                if (handLandmarks) {
                    // å¦‚æœæ‘„åƒå¤´å·²å¯åŠ¨ï¼Œåœæ­¢è‡ªåŠ¨æ¨¡å¼
                    updateStatus('æ‘„åƒå¤´æ¨¡å¼å·²æ¢å¤', true);
                    return;
                }
                
                const gestures = ['open', 'scissors', 'fist', 'point', 'thumbsUp'];
                const currentIndex = gestures.indexOf(currentGesture);
                const nextIndex = (currentIndex + 1) % gestures.length;
                
                currentGesture = gestures[nextIndex];
                lastConfirmedGesture = currentGesture;
                updateStatus('è‡ªåŠ¨æ¨¡å¼: ' + getGestureName(currentGesture), false);
                updateGestureDisplay(currentGesture);
                triggerExplosion();
                
                // åœ¨è‡ªåŠ¨æ¨¡å¼ä¸‹æ˜¾ç¤ºæç¤º
                const hint = document.getElementById('gesture-hint');
                if (hint) {
                    hint.textContent = `è‡ªåŠ¨æ¨¡å¼: ${getGestureName(currentGesture)} (æŒ‰ä»»æ„æ‰‹åŠ¿é”®åˆ‡æ¢å›æ‰‹åŠ¨)`;
                    hint.classList.add('show');
                    setTimeout(() => hint.classList.remove('show'), 2000);
                }
            };

            // å¯åŠ¨å¾ªç¯
            const intervalId = setInterval(autoCycle, 6000);
            setTimeout(autoCycle, 1500);

            // ç›‘å¬æ‘„åƒå¤´æ¢å¤
            const checkCamera = setInterval(() => {
                if (handLandmarks) {
                    clearInterval(intervalId);
                    clearInterval(checkCamera);
                    updateStatus('æ‘„åƒå¤´æ¨¡å¼å·²æ¢å¤', true);
                    showToast('æ‘„åƒå¤´æ¨¡å¼å·²æ¢å¤');
                }
            }, 1000);
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            if (particles) {
                updatePhysics(deltaTime);
            }
            
            renderer.render(scene, camera);
            updateFPS(now);
        }

        // ==================== UI æ›´æ–° ====================
        function updateStatus(text, active) {
            const statusEl = document.getElementById('gestureStatus');
            const indicator = document.getElementById('statusIndicator');

            if (statusEl) {
                statusEl.textContent = text;
                statusEl.style.color = active ? '#00ffff' : '#ffaa00';
            }

            if (indicator) {
                indicator.className = active ? 'status-indicator active' : 'status-indicator';
            }
        }

        function updateGestureDisplay(gesture) {
            const iconEl = document.getElementById('gestureIcon');
            const nameEl = document.getElementById('gestureName');

            if (!gesture) {
                iconEl.textContent = 'âœ‹';
                nameEl.textContent = 'ç­‰å¾…æ‰‹åŠ¿...';
                return;
            }

            const gestureInfo = {
                'open': { icon: 'âœ‹', name: 'å¼ æ‰‹' },
                'scissors': { icon: 'âœŒï¸', name: 'å‰ªåˆ€' },
                'fist': { icon: 'âœŠ', name: 'æ¡æ‹³' },
                'point': { icon: 'â˜ï¸', name: 'é£ŸæŒ‡' },
                'thumbsUp': { icon: 'ğŸ‘', name: 'å¤§æ‹‡æŒ‡' }
            };

            const info = gestureInfo[gesture];
            if (info) {
                iconEl.textContent = info.icon;
                nameEl.textContent = info.name;
            }
        }

        function updateShapeStatus(shape) {
            const el = document.getElementById('shapeStatus');
            if (el) el.textContent = shape;
        }

        function updateFPS(now) {
            frameCount++;
            
            if (now - fpsUpdateTimer >= 1000) {
                fps = Math.round((frameCount * 1000) / (now - fpsUpdateTimer));
                const fpsEl = document.getElementById('fpsCounter');
                if (fpsEl) {
                    fpsEl.textContent = `${fps} FPS`;
                    fpsEl.style.color = fps >= 50 ? '#00ff00' : fps >= 30 ? '#ffff00' : '#ff0000';
                }
                frameCount = 0;
                fpsUpdateTimer = now;
            }
        }

        function updateDebugInfo(text, showLoader) {
            const debug = document.getElementById('debug-info');
            if (debug) {
                debug.textContent = text;
                if (showLoader) {
                    debug.classList.add('loading-center');
                    debug.classList.remove('debug-hidden');
                } else {
                    debug.classList.remove('loading-center');
                    setTimeout(() => {
                        debug.classList.add('debug-hidden');
                    }, 2000);
                }
            }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('stateToast');
            toast.textContent = message;
            toast.className = isError ? 'error show' : 'show';
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        function getGestureName(gesture) {
            const names = {
                'open': 'å¼ æ‰‹',
                'scissors': 'å‰ªåˆ€æ‰‹',
                'fist': 'æ¡æ‹³',
                'point': 'é£ŸæŒ‡',
                'thumbsUp': 'ç«–å¤§æ‹‡æŒ‡'
            };
            return names[gesture] || gesture;
        }

        // ==================== çª—å£è°ƒæ•´ ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== UI æ§åˆ¶å‡½æ•° ====================
        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    showToast('è¿›å…¥å…¨å±æ¨¡å¼');
                }).catch(() => {
                    showToast('å…¨å±è¯·æ±‚å¤±è´¥', true);
                });
            } else {
                document.exitFullscreen().then(() => {
                    showToast('é€€å‡ºå…¨å±æ¨¡å¼');
                });
            }
        };

        window.toggleUI = function() {
            uiVisible = !uiVisible;
            const elements = [
                'infoPanel', 'gestureIndicator', 'topButtons', 
                'controlPanel', 'infoTooltip', 'mainTitle'
            ];
            
            elements.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    if (!uiVisible) {
                        el.classList.add('panel-hidden');
                    } else {
                        el.classList.remove('panel-hidden');
                    }
                }
            });
            
            showToast(uiVisible ? 'UIæ˜¾ç¤º' : 'UIéšè—');
        };

        window.manualSetGesture = function(mode) {
            if (isCameraActive) {
                showToast('æ‘„åƒå¤´æ¨¡å¼ä¸‹è‡ªåŠ¨è¯†åˆ«', true);
                return;
            }
            currentGesture = mode;
            updateStatus(getGestureName(mode), true);
            triggerExplosion();
            showToast(getGestureName(mode));
        };

        window.triggerExplosion = function() {
            const count = CONFIG.PARTICLE_COUNT;
            const force = CONFIG.PHYSICS.EXPLOSION_FORCE;
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                velocity[i3] += force * Math.sin(phi) * Math.cos(theta);
                velocity[i3 + 1] += force * Math.sin(phi) * Math.sin(theta);
                velocity[i3 + 2] += force * Math.cos(phi);
            }
            
            showToast('ğŸ’¥ çˆ†ç‚¸ç‰¹æ•ˆå·²è§¦å‘');
        };

        window.toggleStorm = function() {
            stormActive = !stormActive;
            const btn = document.getElementById('stormBtn');
            if (stormActive) {
                btn.classList.add('active');
                showToast('ğŸŒªï¸ é£æš´æ¨¡å¼å·²å¼€å¯');
            } else {
                btn.classList.remove('active');
                showToast('ğŸŒªï¸ é£æš´æ¨¡å¼å·²å…³é—­');
            }
        };

        // ==================== æ‹–æ‹½æ ‡é¢˜åŠŸèƒ½ ====================
        function initDraggableTitle() {
            const title = document.getElementById('mainTitle');
            let isDragging = false;
            let offset = { x: 0, y: 0 };

            title.addEventListener('mousedown', (e) => {
                isDragging = true;
                const rect = title.getBoundingClientRect();
                offset.x = e.clientX - rect.left;
                offset.y = e.clientY - rect.top;
                title.style.cursor = 'grabbing';
                title.style.transform = 'none';
                title.style.left = rect.left + 'px';
                title.style.top = rect.top + 'px';
                e.preventDefault();
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const x = e.clientX - offset.x;
                const y = e.clientY - offset.y;
                title.style.left = x + 'px';
                title.style.top = y + 'px';
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                title.style.cursor = 'move';
            });

            // ç§»åŠ¨ç«¯æ”¯æŒ
            title.addEventListener('touchstart', (e) => {
                isDragging = true;
                const touch = e.touches[0];
                const rect = title.getBoundingClientRect();
                offset.x = touch.clientX - rect.left;
                offset.y = touch.clientY - rect.top;
                title.style.transform = 'none';
                title.style.left = rect.left + 'px';
                title.style.top = rect.top + 'px';
                e.preventDefault();
            });

            window.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const x = touch.clientX - offset.x;
                const y = touch.clientY - offset.y;
                title.style.left = x + 'px';
                title.style.top = y + 'px';
            });

            window.addEventListener('touchend', () => {
                isDragging = false;
            });
        }

        // ==================== é”®ç›˜å¿«æ·é”® ====================
        function initKeyboardShortcuts() {
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.key.toLowerCase()) {
                    case 'f':
                        e.preventDefault();
                        toggleFullScreen();
                        break;
                    case 'h':
                        e.preventDefault();
                        toggleUI();
                        break;
                    case '1':
                        manualSetGesture('open');
                        break;
                    case '2':
                        manualSetGesture('scissors');
                        break;
                    case '3':
                        manualSetGesture('fist');
                        break;
                    case '4':
                        manualSetGesture('point');
                        break;
                    case '5':
                        manualSetGesture('thumbsUp');
                        break;
                    case 'e':
                        triggerExplosion();
                        break;
                    case 't':
                        toggleStorm();
                        break;
                    case ' ':
                        e.preventDefault();
                        if (!isCameraActive) {
                            const gestures = ['open', 'scissors', 'fist', 'point', 'thumbsUp'];
                            const currentIndex = gestures.indexOf(currentGesture);
                            const nextIndex = (currentIndex + 1) % gestures.length;
                            manualSetGesture(gestures[nextIndex]);
                        }
                        break;
                }
            });
        }

        // ==================== æ‘„åƒå¤´é¢„è§ˆæ§åˆ¶å¢å¼º ====================
        window.toggleCameraPreview = function() {
            const preview = document.getElementById('cameraPreview');
            const status = document.getElementById('cameraStatus');
            
            if (!cameraVideo || !isCameraActive) {
                showToast('æ‘„åƒå¤´æœªå¯åŠ¨', true);
                return;
            }

            if (preview.classList.contains('show')) {
                preview.classList.remove('show');
                showToast('æ‘„åƒå¤´é¢„è§ˆå·²éšè—');
                updateDebugInfo('é¢„è§ˆçª—å£å·²å…³é—­', false);
            } else {
                preview.classList.add('show');
                // æ›´æ–°é¢„è§ˆçª—å£ä¸­çš„è§†é¢‘æº
                const previewVideo = document.getElementById('cameraVideo');
                if (previewVideo.srcObject !== cameraVideo.srcObject) {
                    previewVideo.srcObject = cameraVideo.srcObject;
                    previewVideo.play().catch(e => console.log('é¢„è§ˆæ’­æ”¾å¤±è´¥:', e));
                }
                status.textContent = 'æ‘„åƒå¤´è¿è¡Œä¸­';
                status.classList.add('active');
                showToast('æ‘„åƒå¤´é¢„è§ˆå·²æ˜¾ç¤º');
                updateDebugInfo('é¢„è§ˆçª—å£å·²æ‰“å¼€', false);
            }
        };

        window.toggleCameraMirror = function() {
            const previewVideo = document.getElementById('cameraVideo');
            const currentTransform = previewVideo.style.transform;
            
            if (currentTransform === 'scaleX(-1)') {
                previewVideo.style.transform = 'scaleX(1)';
                showToast('é•œåƒå…³é—­');
                updateDebugInfo('é¢„è§ˆé•œåƒå·²å…³é—­', false);
            } else {
                previewVideo.style.transform = 'scaleX(-1)';
                showToast('é•œåƒå¼€å¯');
                updateDebugInfo('é¢„è§ˆé•œåƒå·²å¼€å¯', false);
            }
        };

        // æ–°å¢ï¼šæ‘„åƒå¤´çŠ¶æ€æ£€æŸ¥
        function checkCameraHealth() {
            if (!cameraVideo || !isCameraActive) return false;
            
            // æ£€æŸ¥è§†é¢‘æµæ˜¯å¦æ­£å¸¸
            if (cameraVideo.readyState >= 2) {
                // è§†é¢‘æµæ­£å¸¸
                return true;
            } else {
                // è§†é¢‘æµæœ‰é—®é¢˜ï¼Œå°è¯•é‡æ–°å¯åŠ¨
                console.log('æ‘„åƒå¤´è§†é¢‘æµå¼‚å¸¸ï¼Œå°è¯•æ¢å¤...');
                return false;
            }
        }

        // æ–°å¢ï¼šæ‰‹åŠ¿è¯†åˆ«æ€§èƒ½ç›‘æ§
        let gesturePerformance = {
            lastUpdate: Date.now(),
            frameCount: 0,
            avgProcessingTime: 0,
            detectionRate: 0
        };

        function monitorGesturePerformance() {
            const now = Date.now();
            gesturePerformance.frameCount++;
            
            if (now - gesturePerformance.lastUpdate >= 1000) {
                gesturePerformance.detectionRate = gesturePerformance.frameCount;
                gesturePerformance.frameCount = 0;
                gesturePerformance.lastUpdate = now;
                
                // æ¯ç§’è¾“å‡ºæ€§èƒ½ä¿¡æ¯
                if (gesturePerformance.detectionRate > 0) {
                    console.log(`æ‰‹åŠ¿è¯†åˆ«æ€§èƒ½: ${gesturePerformance.detectionRate} FPS`);
                }
            }
        }

        // ==================== é«˜çº§ç³»ç»Ÿå¥åº·ç›‘æ§ ====================
        function startSystemHealthMonitor() {
            // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡ç³»ç»ŸçŠ¶æ€
            setInterval(() => {
                if (!isCameraActive) return;
                
                // æ£€æŸ¥æ‘„åƒå¤´å¥åº·
                if (!checkCameraHealth()) {
                    console.warn('æ‘„åƒå¤´å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œå°è¯•æ¢å¤...');
                    updateStatus('æ‘„åƒå¤´è¿æ¥å¼‚å¸¸', false);
                }
                
                // æ€§èƒ½ç»Ÿè®¡è¾“å‡º
                if (performanceStats.detectionCount > 50) {
                    const accuracy = (performanceStats.avgConfidence * 100).toFixed(1);
                    console.log(`ğŸ“Š ç³»ç»Ÿæ€§èƒ½ | æ£€æµ‹æ¬¡æ•°: ${performanceStats.detectionCount} | å¹³å‡ç½®ä¿¡åº¦: ${accuracy}%`);
                    performanceStats.detectionCount = 0; // é‡ç½®è®¡æ•°å™¨
                }
            }, 10000);

            // æ¯30ç§’æ˜¾ç¤ºä¸€æ¬¡å½“å‰æ‰‹åŠ¿ç»Ÿè®¡ï¼ˆä»…åœ¨æ‘„åƒå¤´æ¨¡å¼ï¼‰
            setInterval(() => {
                if (isCameraActive && lastConfirmedGesture && gestureConfidence > 0) {
                    showGestureFeedback(
                        `å½“å‰: ${getGestureName(lastConfirmedGesture)} | ` +
                        `ç½®ä¿¡åº¦: ${(gestureConfidence * 100).toFixed(0)}% | ` +
                        `ç¨³å®š: ${(stabilityScore * 100).toFixed(0)}%`
                    );
                }
            }, 30000);
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('load', () => {
            init();
            initKeyboardShortcuts();
            startSystemHealthMonitor(); // å¯åŠ¨å¥åº·ç›‘æ§
            
            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            setTimeout(() => {
                animate();
            }, 100);

            // æ˜¾ç¤ºæ¬¢è¿æç¤º
            setTimeout(() => {
                const hint = document.getElementById('gesture-hint');
                if (hint) {
                    hint.textContent = 'ğŸ’¡ æç¤ºï¼šå¼ æ‰‹/å‰ªåˆ€/æ¡æ‹³/é£ŸæŒ‡/å¤§æ‹‡æŒ‡ | ç‚¹å‡»æ‘„åƒå¤´æŒ‰é’®é¢„è§ˆ';
                    hint.classList.add('show');
                    setTimeout(() => hint.classList.remove('show'), 5000);
                }
            }, 3000);
        });
    </script>
</body>
</html>
