<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR ç²’å­äº’åŠ¨ç³»ç»Ÿ - 16000ç‹¬ç«‹é¢—ç²’</title>
    <style>
        :root {
            --bg-dark: #0a0a0a;
            --bg-glass: rgba(15, 15, 20, 0.72);
            --bg-glass-hover: rgba(25, 25, 35, 0.85);
            --particle-cyan: #00ffff;
            --particle-glow: rgba(0, 255, 255, 0.5);
            --accent-red: #ff4444;
            --text-dim: #888;
            --text-bright: #fff;
            
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 12px;
            --spacing-lg: 16px;
            
            --ui-scale: 0.95;
        }

        @media screen and (max-height: 800px) { :root { --ui-scale: 0.85; } }
        @media screen and (min-width: 2000px) { :root { --ui-scale: 1.1; } }
        :fullscreen { --ui-scale: 1.0; }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            color: var(--text-bright);
        }

        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* ç»ç’ƒæ‹Ÿæ€é¢æ¿ */
        .glass-panel {
            background: var(--bg-glass);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.06);
            overflow: hidden;
            box-sizing: border-box;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .glass-panel:hover {
            background: var(--bg-glass-hover);
            border-color: var(--particle-glow);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5), 0 0 20px var(--particle-glow);
        }

        .panel-hidden { 
            transform: translateX(calc(-1 * 220px)) scale(var(--ui-scale)) !important; 
            opacity: 0 !important; 
            pointer-events: none !important; 
        }

        /* å·¦ä¾§ä¿¡æ¯é¢æ¿ */
        #infoPanel {
            position: fixed;
            top: var(--spacing-lg);
            left: var(--spacing-lg);
            width: 220px;
            padding: var(--spacing-md);
            z-index: 100;
            transform: scale(var(--ui-scale));
            transform-origin: top left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #infoPanel h2 {
            color: var(--particle-cyan);
            font-size: 14px;
            margin-bottom: var(--spacing-sm);
            text-align: center;
            text-shadow: 0 0 10px var(--particle-glow);
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: var(--spacing-xs) 0;
            padding: var(--spacing-xs) var(--spacing-sm);
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-sm);
            font-size: 11px;
            border-left: 3px solid var(--particle-cyan);
        }

        .status-label {
            color: var(--text-dim);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            color: var(--text-bright);
            font-weight: 700;
        }

        .status-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            background: #ff0000;
            box-shadow: 0 0 4px #ff0000;
            animation: blink 1.5s ease-in-out infinite;
        }

        .status-indicator.active {
            background: #00ff00;
            box-shadow: 0 0 6px #00ff00;
            animation: none;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* å³ä¾§æ‰‹åŠ¿æŒ‡ç¤ºå™¨ */
        #gestureIndicator {
            position: fixed;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            width: 160px;
            padding: var(--spacing-md);
            z-index: 100;
            transform: scale(var(--ui-scale));
            transform-origin: top right;
            text-align: center;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #gestureIndicator h3 {
            color: var(--accent-red);
            font-size: 12px;
            margin-bottom: var(--spacing-sm);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 700;
        }

        .gesture-icon {
            font-size: 36px;
            margin: 6px 0;
            filter: drop-shadow(0 0 8px rgba(255, 68, 68, 0.6));
        }

        .gesture-name {
            color: var(--text-bright);
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
            margin-top: 4px;
        }

        /* é¡¶éƒ¨æ“ä½œæŒ‰é’® */
        #topButtons {
            position: fixed;
            top: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: var(--spacing-sm);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* æ‘„åƒå¤´é¢„è§ˆçª—å£ */
        #cameraPreview {
            position: fixed;
            top: var(--spacing-lg);
            right: calc(var(--spacing-lg) + 180px);
            width: 200px;
            height: 150px;
            border-radius: var(--radius-lg);
            overflow: hidden;
            z-index: 99;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            background: rgba(0, 0, 0, 0.5);
        }

        #cameraPreview.show {
            opacity: 1;
            pointer-events: auto;
        }

        #cameraVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .camera-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 8px;
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .camera-btn {
            padding: 4px 8px;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.4);
            color: white;
            cursor: pointer;
            font-size: 9px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .camera-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .camera-status {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 600;
        }

        .camera-status.active {
            background: rgba(0, 255, 0, 0.3);
            color: #00ff00;
        }

        .top-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: var(--particle-cyan);
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            font-size: 11px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(8px);
        }

        .top-btn:hover {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--particle-cyan);
            color: var(--text-bright);
            box-shadow: 0 0 16px var(--particle-glow);
            transform: translateY(-1px);
        }

        .top-btn:active {
            transform: translateY(0);
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        #controlPanel {
            position: fixed;
            bottom: var(--spacing-lg);
            left: var(--spacing-lg);
            padding: var(--spacing-sm);
            z-index: 100;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-xs);
            width: 220px;
            transform: scale(var(--ui-scale));
            transform-origin: bottom left;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .control-title {
            grid-column: span 2;
            font-size: 10px;
            color: var(--particle-cyan);
            text-align: center;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 700;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .control-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: var(--particle-cyan);
            cursor: pointer;
            font-size: 10px;
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .control-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--particle-cyan);
            box-shadow: 0 0 12px var(--particle-glow);
            transform: translateY(-1px);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn.danger {
            border-color: rgba(255, 68, 68, 0.5);
            color: var(--accent-red);
        }

        .control-btn.danger:hover {
            background: rgba(255, 68, 68, 0.15);
            border-color: var(--accent-red);
            box-shadow: 0 0 12px rgba(255, 68, 68, 0.4);
        }

        .control-btn.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: var(--particle-cyan);
            color: var(--text-bright);
        }

        /* è¿›åº¦æŒ‡ç¤ºå™¨ */
        #progressIndicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(0, 255, 255, 0.15);
            border-top: 3px solid var(--particle-cyan);
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            box-shadow: 0 0 20px var(--particle-glow);
        }

        @keyframes spin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.05); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .progress-container {
            width: 320px;
            margin-top: 20px;
            display: none;
        }

        .progress-bar-bg {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 10px;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.8), var(--particle-cyan));
            width: 0%;
            transition: width 0.4s ease;
            box-shadow: 0 0 16px var(--particle-glow);
            border-radius: 3px;
        }

        .progress-text {
            color: var(--particle-cyan);
            font-size: 14px;
            text-align: center;
            letter-spacing: 1px;
            font-weight: 600;
            margin-top: 10px;
        }

        .progress-steps {
            color: var(--text-dim);
            font-size: 11px;
            margin-top: 8px;
            text-align: center;
        }

        .progress-step {
            margin: 3px 0;
            padding: 2px 0;
            transition: color 0.3s ease;
        }

        .progress-step.complete {
            color: #00ff88;
        }

        .progress-step.current {
            color: var(--particle-cyan);
            font-weight: 700;
        }

        /* æ‹–æ‹½æ ‡é¢˜ */
        #mainTitle {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            text-align: center;
            cursor: move;
            user-select: none;
            padding: var(--spacing-sm);
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        #mainTitle:hover {
            background: rgba(0, 0, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-lg);
        }

        .title-line {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            color: var(--particle-cyan);
            text-shadow: 0 0 15px var(--particle-glow);
            letter-spacing: 2px;
            white-space: nowrap;
            transition: all 0.3s ease;
        }

        .title-subline {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 4px;
            letter-spacing: 1px;
        }

        /* çŠ¶æ€æç¤º */
        #stateToast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: var(--particle-cyan);
            color: #000;
            padding: 16px 32px;
            border-radius: var(--radius-lg);
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 1px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            box-shadow: 0 10px 30px var(--particle-glow);
            text-transform: uppercase;
            white-space: nowrap;
        }

        #stateToast.show {
            opacity: 1;
        }

        #stateToast.error {
            background: rgba(255, 68, 68, 0.95);
            color: #fff;
            box-shadow: 0 10px 30px rgba(255, 68, 68, 0.4);
        }

        /* ä¿¡æ¯æç¤º */
        #infoTooltip {
            position: fixed;
            bottom: var(--spacing-lg);
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            color: var(--particle-cyan);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 11px;
            letter-spacing: 0.5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(8px);
            white-space: nowrap;
            text-shadow: 0 0 5px var(--particle-glow);
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* è°ƒè¯•ä¿¡æ¯ */
        #debug-info {
            position: fixed;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: #00ff00;
            font-size: 13px;
            font-weight: 600;
            font-family: 'Consolas', monospace;
            pointer-events: none;
            z-index: 999;
            text-shadow: 0 0 4px #000;
            background: rgba(0,0,0,0.4);
            padding: 6px 0;
            transition: all 0.5s ease;
            letter-spacing: 0.5px;
        }

        #debug-info.loading-center {
            bottom: auto;
            top: 55%;
            transform: translateY(-50%);
            font-size: 16px;
            background: rgba(0,0,0,0.85);
            padding: 20px 0;
            border-top: 1px solid rgba(0,255,255,0.5);
            border-bottom: 1px solid rgba(0,255,255,0.5);
            border-radius: var(--radius-sm);
            max-width: 400px;
            left: 50%;
            margin-left: -200px;
            position: absolute;
            width: 400px;
        }

        .debug-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* æ‰‹åŠ¿æç¤º */
        #gesture-hint {
            position: fixed;
            top: 16%;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-bright);
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: var(--radius-lg);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 40;
            text-shadow: 0 0 5px var(--particle-glow);
        }

        #gesture-hint.show {
            opacity: 1;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            :root { --ui-scale: 0.8; }
            #infoPanel, #controlPanel {
                width: 180px;
            }
            #gestureIndicator {
                width: 130px;
            }
            .top-btn {
                padding: 6px 12px;
                font-size: 9px;
            }
            #mainTitle .title-line {
                font-size: 20px;
            }
        }

        /* éšè—æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 3px; height: 3px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 2px; }
        ::-webkit-scrollbar-thumb { background: rgba(0, 255, 255, 0.5); border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0, 255, 255, 0.8); }
    </style>
</head>
<body>
    <!-- 3Dç”»å¸ƒå®¹å™¨ -->
    <div id="canvasContainer"></div>

    <!-- æ‹–æ‹½æ ‡é¢˜ -->
    <div id="mainTitle">
        <h1 class="title-line">PARTICLE SYSTEM</h1>
        <div class="title-subline">16K ç‹¬ç«‹æµä½“é¢—ç²’</div>
    </div>

    <!-- æ‘„åƒå¤´é¢„è§ˆçª—å£ -->
    <div id="cameraPreview">
        <video id="cameraVideo" autoplay playsinline muted></video>
        <div class="camera-status" id="cameraStatus">æ‘„åƒå¤´æœªå¯åŠ¨</div>
        <div class="camera-controls">
            <button class="camera-btn" onclick="toggleCameraPreview()">æ˜¾ç¤º/éšè—</button>
            <button class="camera-btn" onclick="toggleCameraMirror()">é•œåƒ</button>
        </div>
    </div>

    <!-- è¿›åº¦æŒ‡ç¤ºå™¨ -->
    <div id="progressIndicator">
        <div class="spinner"></div>
        <div class="progress-container" id="progress-container">
            <div class="progress-bar-bg">
                <div class="progress-bar" id="progress-bar-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">0%</div>
            <div class="progress-steps" id="progress-steps">
                <div class="progress-step" data-step="scene">â— åˆ›å»º3Dåœºæ™¯</div>
                <div class="progress-step" data-step="particles">â— ç”Ÿæˆ16,000é¢—ç²’</div>
                <div class="progress-step" data-step="shapes">â— é¢„å¤„ç†å˜å½¢å½¢çŠ¶</div>
                <div class="progress-step" data-step="camera">â— è¯·æ±‚æ‘„åƒå¤´æƒé™</div>
                <div class="progress-step" data-step="gesture">â— åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«</div>
            </div>
        </div>
    </div>

    <!-- è°ƒè¯•ä¿¡æ¯ -->
    <div id="debug-info" class="loading-center">æ­£åœ¨åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...</div>

    <!-- æ‰‹åŠ¿æç¤º -->
    <div id="gesture-hint">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</div>

    <!-- å·¦ä¾§ä¿¡æ¯é¢æ¿ -->
    <div id="infoPanel" class="glass-panel">
        <h2>ğŸŒŠ ç²’å­çŠ¶æ€</h2>
        <div class="status-item">
            <span class="status-label">ç²’å­æ•°é‡</span>
            <span class="status-value" style="color: var(--particle-cyan);">16,000</span>
        </div>
        <div class="status-item">
            <span class="status-label">å½“å‰å½¢æ€</span>
            <span class="status-value" id="shapeStatus">çƒä½“</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç‰©ç†æ¨¡å‹</span>
            <span class="status-value">é€Ÿåº¦+åŠ é€Ÿåº¦</span>
        </div>
        <div class="status-item">
            <span class="status-label">å¸§ç‡</span>
            <span class="status-value" id="fpsCounter">0 FPS</span>
        </div>
        <div class="status-item">
            <span class="status-label">è¿æ¥çŠ¶æ€</span>
            <span class="status-value">
                <span class="status-indicator" id="statusIndicator"></span>
                <span id="gestureStatus">åˆå§‹åŒ–ä¸­...</span>
            </span>
        </div>
    </div>

    <!-- å³ä¾§æ‰‹åŠ¿æŒ‡ç¤ºå™¨ -->
    <div id="gestureIndicator" class="glass-panel">
        <h3>æ‰‹åŠ¿è¯†åˆ«</h3>
        <div class="gesture-icon" id="gestureIcon">âœ‹</div>
        <div class="gesture-name" id="gestureName">åˆå§‹åŒ–ä¸­...</div>
    </div>

    <!-- é¡¶éƒ¨æ“ä½œæŒ‰é’® -->
    <div id="topButtons">
        <button class="top-btn glass-panel" id="fs-btn" onclick="toggleFullScreen()">
            <span>â›¶</span> <span>å…¨å±</span>
        </button>
        <button class="top-btn glass-panel" id="toggle-ui-btn" onclick="toggleUI()">
            <span>ğŸ‘</span> <span>éšè—ç•Œé¢</span>
        </button>
        <button class="top-btn glass-panel" id="cam-btn" onclick="toggleCameraPreview()">
            <span>ğŸ“·</span> <span>æ‘„åƒå¤´</span>
        </button>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶é¢æ¿ -->
    <div id="controlPanel" class="glass-panel">
        <div class="control-title">å½¢æ€åˆ‡æ¢</div>
        <button class="control-btn" onclick="manualSetGesture('open')">âœ‹ å¼ æ‰‹</button>
        <button class="control-btn" onclick="manualSetGesture('scissors')">âœŒï¸ å‰ªåˆ€</button>
        <button class="control-btn" onclick="manualSetGesture('fist')">âœŠ æ¡æ‹³</button>
        <button class="control-btn" onclick="manualSetGesture('point')">â˜ï¸ é£ŸæŒ‡</button>
        <button class="control-btn" onclick="manualSetGesture('thumbsUp')">ğŸ‘ å¤§æ‹‡æŒ‡</button>
        <button class="control-btn danger" onclick="triggerExplosion()" style="grid-column: span 2;">ğŸ’¥ çˆ†ç‚¸ç‰¹æ•ˆ</button>
        <button class="control-btn" onclick="toggleStorm()" id="stormBtn" style="grid-column: span 2;">ğŸŒªï¸ é£æš´æ¨¡å¼</button>
    </div>

    <!-- ä¿¡æ¯æç¤º -->
    <div id="infoTooltip">ğŸ’¡ å¼ æ‰‹/å‰ªåˆ€/æ¡æ‹³/é£ŸæŒ‡/å¤§æ‹‡æŒ‡ | æŒ¥æ‰‹è§¦å‘é£æš´ | æ¨æ‹‰æ”¹å˜æ·±åº¦ | ç‚¹å‡»æ‘„åƒå¤´æŒ‰é’®é¢„è§ˆ</div>

    <!-- çŠ¶æ€æç¤º -->
    <div id="stateToast"></div>

    <!-- Three.js - ä½¿ç”¨ unpkg ç¡®ä¿ç¨³å®šåŠ è½½ -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <!-- MediaPipe Hands - ä½¿ç”¨ unpkg ç¡®ä¿ç¨³å®šåŠ è½½ -->
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

    <script>
        // ==================== æ ¸å¿ƒé…ç½® ====================
        const CONFIG = {
            PARTICLE_COUNT: 16000,
            PARTICLE_COLOR: 0x00ffff,
            PARTICLE_SIZE: 0.04,
            PHYSICS: {
                DAMPING: 0.95,
                ATTRACTION: 0.02,
                EXPLOSION_FORCE: 3.5,
                STORM_FORCE: 8.0,
                MAX_VELOCITY: 12.0,
                SEPARATION: 0.25
            },
            CAMERA: {
                FOV: 60,
                MIN_DISTANCE: 6,
                MAX_DISTANCE: 25,
                DEFAULT_DISTANCE: 12,
                ZOOM_SPEED: 0.4,
                ROTATION_SPEED: 0.02
            }
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, particles;
        let particleSystem;
        let cameraVideo, hands, handsObj;
        
        // ç‰©ç†çŠ¶æ€
        let currentPosition, targetPosition, velocity, acceleration;
        
        // æ‰‹åŠ¿çŠ¶æ€
        let currentGesture = 'open';
        let handLandmarks = null;
        let handVelocity = { x: 0, y: 0, z: 0 };
        let prevHandPos = { x: 0, y: 0, z: 0 };
        let handSpeed = 0;
        let palmArea = 0;
        let stormActive = false;
        
        // æ‰‹åŠ¿å¹³æ»‘å’Œé˜²æŠ–
        let gestureBuffer = []; // æ‰‹åŠ¿å†å²ç¼“å†²åŒº
        const GESTURE_BUFFER_SIZE = 6; // ç¼“å†²åŒºå¤§å°
        const GESTURE_STABILITY_THRESHOLD = 4; // éœ€è¦å¤šå°‘æ¬¡ç›¸åŒæ£€æµ‹æ‰ç¡®è®¤
        let lastGestureChange = 0;
        let lastConfirmedGesture = 'open';
        
        // äº¤äº’çŠ¶æ€
        let isCameraActive = false;
        let lastFrameTime = 0;
        let frameCount = 0;
        let fpsUpdateTimer = 0;
        let fps = 0;
        
        // UIçŠ¶æ€
        let uiVisible = true;
        
        // å½¢çŠ¶æ•°æ®
        let shapeData = {
            textPoints: [],
            starPoints: [],
            heartPoints: [],
            ringPoints: []
        };

        // è¿›åº¦ç®¡ç†
        const progressManager = {
            totalSteps: 5,
            currentStep: 0,
            container: null,
            barFill: null,
            text: null,
            stepText: null,
            
            init() {
                this.container = document.getElementById('progress-container');
                this.barFill = document.getElementById('progress-bar-fill');
                this.text = document.getElementById('progress-text');
                this.stepText = document.getElementById('progress-steps');
                this.currentStep = 0;
                if(this.container) {
                    this.container.style.display = 'block';
                    this.update(0, 'å¼€å§‹åˆå§‹åŒ–...');
                }
            },
            
            update(step, message) {
                this.currentStep = step;
                const percentage = Math.round((step / this.totalSteps) * 100);
                
                if(this.barFill) this.barFill.style.width = percentage + '%';
                if(this.text) this.text.textContent = percentage + '%';
                if(this.stepText) {
                    const stepElements = this.stepText.querySelectorAll('.progress-step');
                    stepElements.forEach((el, index) => {
                        if (index < step) {
                            el.className = 'progress-step complete';
                        } else if (index === step) {
                            el.className = 'progress-step current';
                        } else {
                            el.className = 'progress-step';
                        }
                    });
                }
            },
            
            next(message) {
                this.currentStep++;
                this.update(this.currentStep, message);
            },
            
            complete() {
                if(this.container) {
                    this.update(this.totalSteps, 'åˆå§‹åŒ–å®Œæˆï¼');
                    setTimeout(() => {
                        this.container.style.display = 'none';
                        document.getElementById('progressIndicator').style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('progressIndicator').style.display = 'none';
                        }, 500);
                    }, 500);
                }
            }
        };

        // ==================== åˆå§‹åŒ–ç³»ç»Ÿ ====================
        function init() {
            document.getElementById('progressIndicator').style.display = 'flex';
            progressManager.init();
            updateDebugInfo('æ­£åœ¨åˆ›å»º3Dåœºæ™¯...', true);

            // 1. åˆ›å»ºåœºæ™¯
            createScene();
            progressManager.next('ç”Ÿæˆ16,000é¢—ç²’');
            updateDebugInfo('æ­£åœ¨ç”Ÿæˆ16,000ç‹¬ç«‹é¢—ç²’...', true);

            // 2. åˆ›å»ºç²’å­ç³»ç»Ÿ
            setTimeout(() => {
                createParticleSystem();
                progressManager.next('é¢„å¤„ç†å˜å½¢å½¢çŠ¶');
                updateDebugInfo('æ­£åœ¨é¢„å¤„ç†å˜å½¢å½¢çŠ¶...', true);

                // 3. ç”Ÿæˆå½¢çŠ¶æ•°æ®
                setTimeout(() => {
                    generateAllShapes();
                    progressManager.next('è¯·æ±‚æ‘„åƒå¤´æƒé™');
                    updateDebugInfo('æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...', true);

                    // 4. è¯·æ±‚æ‘„åƒå¤´æƒé™
                    setTimeout(() => {
                        initCameraAndHands();
                    }, 300);
                }, 300);
            }, 300);

            // 5. åˆå§‹åŒ–æ‹–æ‹½æ ‡é¢˜
            setTimeout(initDraggableTitle, 100);
        }

        // ==================== åœºæ™¯åˆ›å»º ====================
        function createScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvasContainer').appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);

            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
        }

        // ==================== ç²’å­ç³»ç»Ÿåˆ›å»º ====================
        function createParticleSystem() {
            const count = CONFIG.PARTICLE_COUNT;
            const geometry = new THREE.BufferGeometry();
            
            currentPosition = new Float32Array(count * 3);
            targetPosition = new Float32Array(count * 3);
            velocity = new Float32Array(count * 3);
            acceleration = new Float32Array(count * 3);

            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                const y = 1 - (i / (count - 1)) * 2;
                const radius2D = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;
                
                const x = Math.cos(theta) * radius2D;
                const z = Math.sin(theta) * radius2D;
                
                const layer = i / count;
                const baseRadius = 0.5 + Math.pow(layer, 0.7) * 3.5;
                
                const jitter = 0.05;
                const finalX = x * baseRadius + (Math.random() - 0.5) * jitter;
                const finalY = y * baseRadius + (Math.random() - 0.5) * jitter;
                const finalZ = z * baseRadius + (Math.random() - 0.5) * jitter;

                currentPosition[i3] = finalX;
                currentPosition[i3 + 1] = finalY;
                currentPosition[i3 + 2] = finalZ;
                
                targetPosition[i3] = finalX;
                targetPosition[i3 + 1] = finalY;
                targetPosition[i3 + 2] = finalZ;
                
                velocity[i3] = (Math.random() - 0.5) * 0.1;
                velocity[i3 + 1] = (Math.random() - 0.5) * 0.1;
                velocity[i3 + 2] = (Math.random() - 0.5) * 0.1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPosition, 3));

            const material = new THREE.PointsMaterial({
                color: CONFIG.PARTICLE_COLOR,
                size: CONFIG.PARTICLE_SIZE,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true,
                blending: THREE.NormalBlending,
                depthWrite: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            particleSystem = {
                geometry: geometry,
                count: count,
                state: 'sphere',
                transition: 0
            };
        }

        // ==================== å½¢çŠ¶é¢„å¤„ç† ====================
        function generateAllShapes() {
            generateTextShape();
            generateStarShape();
            generateHeartShape();
            generateRingShape();
        }

        function generateTextShape() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 200;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 60px "Segoe UI", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('æˆ‘æ˜¯ Mok', canvas.width / 2, canvas.height / 2);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            shapeData.textPoints = [];
            const step = 2;
            
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const index = (y * canvas.width + x) * 4;
                    if (data[index] > 128) {
                        const px = (x - canvas.width / 2) * 0.03;
                        const py = -(y - canvas.height / 2) * 0.03;
                        const pz = (Math.random() - 0.5) * 0.5;
                        shapeData.textPoints.push({ x: px, y: py, z: pz });
                    }
                }
            }
            
            while (shapeData.textPoints.length < 4000) {
                shapeData.textPoints.push({
                    x: (Math.random() - 0.5) * 4,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 0.5
                });
            }
        }

        function generateStarShape() {
            const count = 2000;
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const segment = Math.floor(t / (Math.PI * 2 / 5));
                const segmentT = (t % (Math.PI * 2 / 5)) / (Math.PI * 2 / 5);
                
                const innerRadius = 0.8;
                const outerRadius = 2.0;
                const radius = segment % 2 === 0 
                    ? innerRadius + (outerRadius - innerRadius) * segmentT
                    : outerRadius - (outerRadius - innerRadius) * segmentT;
                
                shapeData.starPoints.push({
                    x: Math.cos(t) * radius,
                    y: Math.sin(t) * radius,
                    z: (Math.random() - 0.5) * 0.3
                });
            }
        }

        function generateHeartShape() {
            const count = 2500;
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const scale = 1.5;
                const x = scale * 16 * Math.pow(Math.sin(t), 3);
                const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                const z = (Math.random() - 0.5) * 0.5;
                
                shapeData.heartPoints.push({
                    x: x * 0.1,
                    y: y * 0.1,
                    z: z
                });
            }
        }

        function generateRingShape() {
            const count = 2000;
            for (let i = 0; i < count; i++) {
                const layer = i % 2;
                const baseRadius = 1.8 + layer * 0.5;
                const angle = (i / count) * Math.PI * 4;
                const height = Math.sin(angle * 3) * 0.4;
                
                shapeData.ringPoints.push({
                    x: Math.cos(angle) * baseRadius,
                    y: height,
                    z: Math.sin(angle) * baseRadius
                });
            }
        }

        // ==================== ç‰©ç†å¼•æ“ ====================
        function updatePhysics(deltaTime) {
            const dt = Math.min(deltaTime, 0.05);
            const time = Date.now() * 0.001;

            if (!particles) return;

            const count = particles.geometry.attributes.position.count;
            const positions = particles.geometry.attributes.position.array;

            // æ ¹æ®æ‰‹åŠ¿æ›´æ–°ç›®æ ‡ä½ç½®
            updateTargetsForGesture(currentGesture, time);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // ç‹¬ç«‹ç²’å­è¿åŠ¨ - å¼ºåˆ†ç¦»åŠ›
                const independentForce = (Math.random() - 0.5) * 0.15;
                velocity[i3] += independentForce;
                velocity[i3 + 1] += independentForce * 0.8;
                velocity[i3 + 2] += independentForce * 0.6;
                
                // åˆ†ç¦»åŠ› - é¿å…ç²’å­èšé›†
                const separationForce = CONFIG.PHYSICS.SEPARATION;
                velocity[i3] += (Math.random() - 0.5) * separationForce;
                velocity[i3 + 1] += (Math.random() - 0.5) * separationForce;
                velocity[i3 + 2] += (Math.random() - 0.5) * separationForce;
                
                // ç›®æ ‡ä½ç½®å›å½’åŠ›ï¼ˆæå¼±ï¼‰
                const dx = targetPosition[i3] - positions[i3];
                const dy = targetPosition[i3 + 1] - positions[i3 + 1];
                const dz = targetPosition[i3 + 2] - positions[i3 + 2];
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                if (dist > 0.01) {
                    const weakAttraction = CONFIG.PHYSICS.ATTRACTION * 0.03;
                    velocity[i3] += (dx / dist) * weakAttraction;
                    velocity[i3 + 1] += (dy / dist) * weakAttraction;
                    velocity[i3 + 2] += (dz / dist) * weakAttraction;
                }
                
                // æ‰‹åŠ¿å½±å“
                if (handLandmarks && (handSpeed > 0.01 || stormActive)) {
                    applyGestureForces(i3, positions, velocity);
                }
                
                // ç‰©ç†æ›´æ–°
                velocity[i3] *= CONFIG.PHYSICS.DAMPING;
                velocity[i3 + 1] *= CONFIG.PHYSICS.DAMPING;
                velocity[i3 + 2] *= CONFIG.PHYSICS.DAMPING;
                
                // é€Ÿåº¦é™åˆ¶
                const vx = velocity[i3], vy = velocity[i3 + 1], vz = velocity[i3 + 2];
                const speed = Math.sqrt(vx*vx + vy*vy + vz*vz);
                if (speed > CONFIG.PHYSICS.MAX_VELOCITY) {
                    const scale = CONFIG.PHYSICS.MAX_VELOCITY / speed;
                    velocity[i3] *= scale;
                    velocity[i3 + 1] *= scale;
                    velocity[i3 + 2] *= scale;
                }
                
                positions[i3] += velocity[i3] * dt;
                positions[i3 + 1] += velocity[i3 + 1] * dt;
                positions[i3 + 2] += velocity[i3 + 2] * dt;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function updateTargetsForGesture(gesture, time) {
            const count = CONFIG.PARTICLE_COUNT;
            
            switch (gesture) {
                case 'open': // çƒå½¢
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        const pulse = Math.sin(time + i * 0.01) * 0.1;
                        const y = 1 - (i / (count - 1)) * 2;
                        const radius2D = Math.sqrt(1 - y * y);
                        const theta = Math.PI * (3 - Math.sqrt(5)) * i;
                        const baseRadius = 1.5 + pulse;
                        
                        targetPosition[i3] = Math.cos(theta) * radius2D * baseRadius;
                        targetPosition[i3 + 1] = y * baseRadius;
                        targetPosition[i3 + 2] = Math.sin(theta) * radius2D * baseRadius;
                    }
                    updateShapeStatus('çƒä½“');
                    break;
                    
                case 'scissors': // æ–‡å­—
                    const textCount = shapeData.textPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < textCount) {
                            const point = shapeData.textPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - textCount;
                            targetPosition[i3] = (Math.random() - 0.5) * 3;
                            targetPosition[i3 + 1] = (Math.random() - 0.5) * 2;
                            targetPosition[i3 + 2] = (Math.random() - 0.5) * 2;
                        }
                    }
                    updateShapeStatus('æ–‡å­—');
                    break;
                    
                case 'fist': // åœ†ç¯
                    const ringCount = shapeData.ringPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < ringCount) {
                            const point = shapeData.ringPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - ringCount;
                            const angle = (idx / (count - ringCount)) * Math.PI * 2;
                            const radius = 2.5;
                            targetPosition[i3] = Math.cos(angle) * radius;
                            targetPosition[i3 + 1] = 0;
                            targetPosition[i3 + 2] = Math.sin(angle) * radius;
                        }
                    }
                    updateShapeStatus('åœ†ç¯');
                    break;
                    
                case 'point': // æ˜Ÿå½¢
                    const starCount = shapeData.starPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < starCount) {
                            const point = shapeData.starPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - starCount;
                            const angle = (idx / (count - starCount)) * Math.PI * 2;
                            const radius = 3.0;
                            targetPosition[i3] = Math.cos(angle) * radius;
                            targetPosition[i3 + 1] = 0;
                            targetPosition[i3 + 2] = Math.sin(angle) * radius;
                        }
                    }
                    updateShapeStatus('æ˜Ÿå½¢');
                    break;
                    
                case 'thumbsUp': // çˆ±å¿ƒ
                    const heartCount = shapeData.heartPoints.length;
                    for (let i = 0; i < count; i++) {
                        const i3 = i * 3;
                        if (i < heartCount) {
                            const point = shapeData.heartPoints[i];
                            targetPosition[i3] = point.x;
                            targetPosition[i3 + 1] = point.y;
                            targetPosition[i3 + 2] = point.z;
                        } else {
                            const idx = i - heartCount;
                            const angle = (idx / (count - heartCount)) * Math.PI * 2;
                            const radius = 2.0;
                            targetPosition[i3] = Math.cos(angle) * radius;
                            targetPosition[i3 + 1] = Math.sin(angle * 2) * 0.5;
                            targetPosition[i3 + 2] = Math.sin(angle) * radius;
                        }
                    }
                    updateShapeStatus('çˆ±å¿ƒ');
                    break;
            }
        }

        function applyGestureForces(i3, positions, velocities) {
            if (!handLandmarks) return;
            
            const handCenter = handLandmarks[9];
            const handX = (handCenter.x - 0.5) * 8;
            const handY = -(handCenter.y - 0.5) * 6;
            const handZ = (handCenter.z + 0.5) * 4;
            
            const cx = positions[i3];
            const cy = positions[i3 + 1];
            const cz = positions[i3 + 2];
            
            const dx = cx - handX;
            const dy = cy - handY;
            const dz = cz - handZ;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if (dist < 8.0) {
                // é£æš´æ¨¡å¼
                if (stormActive) {
                    const stormForce = CONFIG.PHYSICS.STORM_FORCE * Math.max(0, 1 - dist / 8);
                    velocities[i3] += (dx / dist) * stormForce * 0.5;
                    velocities[i3 + 1] += (dy / dist) * stormForce * 0.5;
                    velocities[i3 + 2] += (dz / dist) * stormForce * 0.5;
                }
                // æ‰‹åŠ¿æŒ¥åŠ¨
                else if (handSpeed > 0.01) {
                    const force = handSpeed * 0.5 * Math.max(0, 1 - dist / 8);
                    if (force > 0.02) {
                        velocities[i3] += (dx / dist) * force * 1.5;
                        velocities[i3 + 1] += (dy / dist) * force * 1.5;
                        velocities[i3 + 2] += (dz / dist) * force * 1.5;
                    }
                }
                
                // æ·±åº¦æ¨æ‹‰
                if (palmArea > 0.03) {
                    const depthForce = (palmArea - 0.03) * 15;
                    velocities[i3 + 2] += depthForce * 0.1;
                }
            }
        }

        // ==================== æ‰‹åŠ¿è¯†åˆ« ====================
        async function initCameraAndHands() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    startAutoMode('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´');
                    return;
                }

                if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                    startAutoMode('éœ€è¦HTTPSç¯å¢ƒ');
                    return;
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user' 
                    }
                });

                cameraVideo = document.createElement('video');
                cameraVideo.style.display = 'none';
                cameraVideo.setAttribute('playsinline', true);
                cameraVideo.muted = true;
                document.body.appendChild(cameraVideo);
                cameraVideo.srcObject = stream;

                await new Promise(resolve => {
                    cameraVideo.onloadedmetadata = resolve;
                });

                cameraVideo.play();

                progressManager.next('åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«');
                updateDebugInfo('æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«...', true);

                hands = new Hands({
                    locateFile: (file) => {
                        return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    selfieMode: true
                });

                hands.onResults(onHandResults);

                handsObj = new Camera(cameraVideo, {
                    onFrame: async () => {
                        await hands.send({ image: cameraVideo });
                    },
                    width: 1280,
                    height: 720
                });

                handsObj.start();

                isCameraActive = true;
                updateStatus('æ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª', true);
                progressManager.complete();
                updateDebugInfo('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ', false);

                setTimeout(() => {
                    const hint = document.getElementById('gesture-hint');
                    if(hint) hint.classList.add('show');
                    setTimeout(() => hint.classList.remove('show'), 4000);
                }, 1000);

            } catch (error) {
                console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                startAutoMode('æ‘„åƒå¤´è®¿é—®å¤±è´¥');
            }
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks[0];
                updateHandMetrics();
                detectGesture();
            } else {
                handLandmarks = null;
                handSpeed = 0;
                palmArea = 0;
                updateGestureDisplay(null);
            }
        }

        function updateHandMetrics() {
            if (!handLandmarks) return;

            const center = handLandmarks[9];
            const currentX = (center.x - 0.5) * 8;
            const currentY = -(center.y - 0.5) * 6;
            const currentZ = (center.z + 0.5) * 4;

            if (prevHandPos.x !== 0) {
                const dx = currentX - prevHandPos.x;
                const dy = currentY - prevHandPos.y;
                const dz = currentZ - prevHandPos.z;
                
                handVelocity.x = dx;
                handVelocity.y = dy;
                handVelocity.z = dz;
                
                handSpeed = Math.sqrt(dx*dx + dy*dy + dz*dz);
            }

            const thumbBase = handLandmarks[2];
            const pinkyBase = handLandmarks[17];
            palmArea = Math.sqrt(
                Math.pow(thumbBase.x - pinkyBase.x, 2) + 
                Math.pow(thumbBase.y - pinkyBase.y, 2)
            );

            prevHandPos.x = currentX;
            prevHandPos.y = currentY;
            prevHandPos.z = currentZ;
        }

        // å¢å¼ºçš„æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ - å¤šç»´åº¦ç‰¹å¾èåˆ + æ™ºèƒ½å¹³æ»‘
        function detectGesture() {
            if (!handLandmarks) return;

            const landmarks = handLandmarks;
            
            // å…³é”®ç‚¹å®šä¹‰
            const wrist = landmarks[0];
            const thumbBase = landmarks[2];
            const thumbTip = landmarks[4];
            const indexBase = landmarks[5];
            const indexTip = landmarks[8];
            const middleBase = landmarks[9];
            const middleTip = landmarks[12];
            const ringBase = landmarks[13];
            const ringTip = landmarks[16];
            const pinkyBase = landmarks[17];
            const pinkyTip = landmarks[20];

            // è®¡ç®—è·ç¦»çš„è¾…åŠ©å‡½æ•° - ä½¿ç”¨æ›´ç²¾ç¡®çš„3Dè·ç¦»è®¡ç®—
            const dist = (p1, p2) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const dz = (p1.z - p2.z) * 2; // å¢åŠ Zè½´æƒé‡ï¼Œæé«˜æ·±åº¦æ„ŸçŸ¥
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
            };

            // è®¡ç®—æ‰‹æŒ‡åˆ°æ‰‹è…•çš„å½’ä¸€åŒ–è·ç¦»ï¼ˆè€ƒè™‘æ‰‹çš„å¤§å°ï¼‰
            const handSize = dist(thumbBase, pinkyBase) || 0.1; // é¿å…é™¤é›¶
            const normalizeDist = (d) => d / handSize; // å½’ä¸€åŒ–åˆ°æ‰‹æŒå¤§å°å•ä½

            const thumbDist = normalizeDist(dist(thumbTip, wrist));
            const indexDist = normalizeDist(dist(indexTip, wrist));
            const middleDist = normalizeDist(dist(middleTip, wrist));
            const ringDist = normalizeDist(dist(ringTip, wrist));
            const pinkyDist = normalizeDist(dist(pinkyTip, wrist));

            // è®¡ç®—æ‰‹æŒ‡å¼¯æ›²åº¦ï¼ˆä½¿ç”¨ç›¸å¯¹é•¿åº¦æ¯”ï¼‰
            const thumbBend = normalizeDist(dist(thumbTip, thumbBase));
            const indexBend = normalizeDist(dist(indexTip, indexBase));
            const middleBend = normalizeDist(dist(middleTip, middleBase));
            const ringBend = normalizeDist(dist(ringTip, ringBase));
            const pinkyBend = normalizeDist(dist(pinkyTip, pinkyBase));

            // æ‰‹æŒå½¢çŠ¶ç‰¹å¾
            const palmWidth = handSize;
            const palmHeight = normalizeDist(dist(indexBase, wrist));
            
            // æ‰‹æŒ‡é—´è·ç‰¹å¾
            const indexMiddleGap = normalizeDist(dist(indexTip, middleTip));
            const middleRingGap = normalizeDist(dist(middleTip, ringTip));
            const ringPinkyGap = normalizeDist(dist(ringTip, pinkyTip));

            // æ‰‹æŒ‡è§’åº¦ç‰¹å¾ï¼ˆç”¨äºåŒºåˆ†ç›¸ä¼¼æ‰‹åŠ¿ï¼‰
            const indexAngle = Math.atan2(indexTip.y - indexBase.y, indexTip.x - indexBase.x);
            const middleAngle = Math.atan2(middleTip.y - middleBase.y, middleTip.x - middleBase.x);
            const angleDiff = Math.abs(indexAngle - middleAngle);

            // æ‰‹æŒä¸­å¿ƒç‚¹ï¼ˆç”¨äºæ·±åº¦äº¤äº’ï¼‰
            const palmCenter = {
                x: (thumbBase.x + pinkyBase.x + indexBase.x + middleBase.x + ringBase.x) / 5,
                y: (thumbBase.y + pinkyBase.y + indexBase.y + middleBase.y + ringBase.y) / 5,
                z: (thumbBase.z + pinkyBase.z + indexBase.z + middleBase.z + ringBase.z) / 5
            };

            // ==================== æ™ºèƒ½é˜ˆå€¼ç³»ç»Ÿ ====================
            const THRESHOLDS = {
                // åŠ¨æ€é˜ˆå€¼ - æ ¹æ®æ‰‹çš„å¤§å°è°ƒæ•´
                FIST_DISTANCE: 0.6,        // æ¡æ‹³ï¼šæ‰‹æŒ‡åˆ°æ‰‹è…•è·ç¦» < 0.6å€æ‰‹æŒå¤§å°
                OPEN_DISTANCE: 1.2,        // å¼ æ‰‹ï¼šæ‰€æœ‰æ‰‹æŒ‡è·ç¦» > 1.2å€æ‰‹æŒå¤§å°
                BEND_THRESHOLD: 0.5,       // å¼¯æ›²ï¼šæ‰‹æŒ‡ç›¸å¯¹é•¿åº¦ < 0.5
                SCISSORS_GAP: 0.3,         // å‰ªåˆ€ï¼šæ‰‹æŒ‡é—´è· > 0.3å€æ‰‹æŒå¤§å°
                POINT_DISTANCE: 0.8,       // æŒ‡é£ŸæŒ‡ï¼šé£ŸæŒ‡è·ç¦» > 0.8
                THUMB_DISTANCE: 0.9,       // å¤§æ‹‡æŒ‡ï¼šæ‹‡æŒ‡è·ç¦» > 0.9
                ANGLE_DIFF: 0.5,           // è§’åº¦å·®å¼‚é˜ˆå€¼ï¼ˆå¼§åº¦ï¼‰
                CONFIDENCE_THRESHOLD: 0.65 // ç½®ä¿¡åº¦é˜ˆå€¼ï¼ˆæé«˜ä»¥å‡å°‘è¯¯è¯†åˆ«ï¼‰
            };

            // ==================== æ‰‹åŠ¿ç‰¹å¾è®¡ç®—ï¼ˆå¤šç»´åº¦ï¼‰ ====================
            const features = {
                // 1. æ‰‹æŒ‡ä¼¸ç›´åº¦æ£€æµ‹
                thumbExtended: thumbDist > THRESHOLDS.THUMB_DISTANCE,
                indexExtended: indexDist > THRESHOLDS.POINT_DISTANCE,
                middleExtended: middleDist > 1.0,
                ringExtended: ringDist > 1.0,
                pinkyExtended: pinkyDist > 1.0,

                // 2. æ‰‹æŒ‡å¼¯æ›²åº¦æ£€æµ‹
                thumbBent: thumbBend < THRESHOLDS.BEND_THRESHOLD,
                indexBent: indexBend < THRESHOLDS.BEND_THRESHOLD,
                middleBent: middleBend < THRESHOLDS.BEND_THRESHOLD,
                ringBent: ringBend < THRESHOLDS.BEND_THRESHOLD,
                pinkyBent: pinkyBend < THRESHOLDS.BEND_THRESHOLD,

                // 3. æ‰‹æŒ‡é—´è·ç‰¹å¾
                scissorsGap: indexMiddleGap > THRESHOLDS.SCISSORS_GAP,
                closeFingers: indexMiddleGap < 0.2 && middleRingGap < 0.2 && ringPinkyGap < 0.2,

                // 4. è§’åº¦ç‰¹å¾ï¼ˆç”¨äºåŒºåˆ†å‰ªåˆ€å’ŒæŒ‡é£ŸæŒ‡ï¼‰
                similarAngles: angleDiff < THRESHOLDS.ANGLE_DIFF,

                // 5. æ‰‹æŒå½¢çŠ¶ç‰¹å¾
                widePalm: palmWidth > palmHeight * 1.2,
                squarePalm: Math.abs(palmWidth - palmHeight) < 0.3,

                // 6. ä¸€è‡´æ€§æ£€æŸ¥
                allFingersBent: thumbBend < 0.5 && indexBend < 0.5 && middleBend < 0.5 && ringBend < 0.5 && pinkyBend < 0.5,
                allFingersExtended: thumbDist > 1.0 && indexDist > 1.0 && middleDist > 1.0 && ringDist > 1.0 && pinkyDist > 1.0
            };

            // ==================== æ‰‹åŠ¿ç½®ä¿¡åº¦è¯„åˆ†ç³»ç»Ÿ ====================
            const gestureScores = {
                fist: 0,
                open: 0,
                scissors: 0,
                point: 0,
                thumbsUp: 0
            };

            // 1. æ¡æ‹³ (fist) - æ‰€æœ‰æ‰‹æŒ‡å¼¯æ›²ï¼Œæ‰‹æŒç´§å‡‘
            if (features.allFingersBent) {
                gestureScores.fist += 0.7;
                if (!features.widePalm) gestureScores.fist += 0.2;
                if (thumbDist < 0.5) gestureScores.fist += 0.1;
            }

            // 2. å¼ æ‰‹ (open) - æ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´ï¼Œæ‰‹æŒå±•å¼€
            if (features.allFingersExtended) {
                gestureScores.open += 0.7;
                if (features.widePalm) gestureScores.open += 0.2;
                if (features.closeFingers) gestureScores.open += 0.1;
            }

            // 3. å‰ªåˆ€æ‰‹ (scissors) - é£ŸæŒ‡ä¸­æŒ‡åˆ†å¼€ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²
            if (features.indexExtended && features.middleExtended && features.ringBent && features.pinkyBent && features.scissorsGap) {
                gestureScores.scissors += 0.6;
                if (!features.similarAngles) gestureScores.scissors += 0.2; // è§’åº¦ä¸åŒ
                if (thumbBend < 0.6) gestureScores.scissors += 0.1; // æ‹‡æŒ‡ç¨å¾®å¼¯æ›²
                if (indexDist > 1.3) gestureScores.scissors += 0.1; // é£ŸæŒ‡æ˜æ˜¾ä¼¸ç›´
            }

            // 4. æŒ‡é£ŸæŒ‡ (point) - ä»…é£ŸæŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²
            if (features.indexExtended && !features.middleExtended && features.indexBent && features.middleBent && features.ringBent && features.pinkyBent) {
                gestureScores.point += 0.6;
                if (indexDist > 1.4) gestureScores.point += 0.2;
                if (features.similarAngles) gestureScores.point += 0.1; // è§’åº¦ä¸€è‡´
                if (thumbBend && thumbDist < 0.8) gestureScores.point += 0.1;
            }

            // 5. å¤§æ‹‡æŒ‡ (thumbsUp) - ä»…æ‹‡æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²
            if (features.thumbExtended && !features.indexExtended && !features.middleExtended && features.indexBent && features.middleBent && features.ringBent && features.pinkyBent) {
                gestureScores.thumbsUp += 0.6;
                if (thumbDist > 1.3) gestureScores.thumbsUp += 0.2;
                if (features.widePalm) gestureScores.thumbsUp += 0.1;
                if (features.closeFingers) gestureScores.thumbsUp += 0.1;
            }

            // ==================== æœ€é«˜åˆ†é€‰æ‹© ====================
            let detectedGesture = null;
            let maxScore = THRESHOLDS.CONFIDENCE_THRESHOLD;
            let allScoresZero = true;

            for (const [gesture, score] of Object.entries(gestureScores)) {
                if (score > 0) allScoresZero = false;
                if (score > maxScore) {
                    maxScore = score;
                    detectedGesture = gesture;
                }
            }

            // å¦‚æœæ‰€æœ‰åˆ†æ•°éƒ½å¾ˆä½ï¼Œå¯èƒ½è¡¨ç¤ºæ‰‹åŠ¿ä¸æ˜ç¡®
            if (allScoresZero || maxScore < THRESHOLDS.CONFIDENCE_THRESHOLD * 0.7) {
                gestureBuffer = []; // æ¸…ç©ºç¼“å†²åŒºï¼Œé¿å…è¯¯è¯†åˆ«
                updateGestureDisplay(null);
                return;
            }

            // ==================== æ‰‹åŠ¿å¹³æ»‘å’Œé˜²æŠ–æœºåˆ¶ ====================
            if (detectedGesture) {
                // æ·»åŠ åˆ°å†å²ç¼“å†²åŒº
                gestureBuffer.push(detectedGesture);
                
                // é™åˆ¶ç¼“å†²åŒºå¤§å°
                if (gestureBuffer.length > GESTURE_BUFFER_SIZE) {
                    gestureBuffer.shift();
                }

                // åªæœ‰å½“ç¼“å†²åŒºè¶³å¤Ÿå¤§æ—¶æ‰è¿›è¡Œç¨³å®šæ€§åˆ¤æ–­
                if (gestureBuffer.length >= GESTURE_BUFFER_SIZE / 2) {
                    // ç»Ÿè®¡æœ€é¢‘ç¹çš„æ‰‹åŠ¿
                    const gestureCounts = {};
                    gestureBuffer.forEach(gesture => {
                        gestureCounts[gesture] = (gestureCounts[gesture] || 0) + 1;
                    });

                    // æ‰¾å‡ºæœ€é¢‘ç¹çš„æ‰‹åŠ¿åŠå…¶é¢‘ç‡
                    let mostFrequentGesture = null;
                    let maxCount = 0;
                    for (const [gesture, count] of Object.entries(gestureCounts)) {
                        if (count > maxCount) {
                            maxCount = count;
                            mostFrequentGesture = gesture;
                        }
                    }

                    // è®¡ç®—ç¨³å®šæ€§æ¯”ç‡
                    const stabilityRatio = maxCount / gestureBuffer.length;

                    // ç¨³å®šæ€§æ£€æŸ¥ï¼šéœ€è¦è¶…è¿‡é˜ˆå€¼ä¸”ä¸ä¸Šæ¬¡ä¸åŒ
                    if (stabilityRatio >= 0.6 && mostFrequentGesture !== lastConfirmedGesture) {
                        const now = Date.now();
                        
                        // æ—¶é—´é˜²æŠ–ï¼šé˜²æ­¢å¿«é€Ÿåˆ‡æ¢
                        if (now - lastGestureChange > 300) {
                            lastConfirmedGesture = mostFrequentGesture;
                            currentGesture = mostFrequentGesture;
                            lastGestureChange = now;
                            triggerExplosion();
                            
                            // è¯¦ç»†è°ƒè¯•ä¿¡æ¯ï¼ˆä»…åœ¨æ§åˆ¶å°æ˜¾ç¤ºï¼‰
                            console.log(`âœ… æ‰‹åŠ¿åˆ‡æ¢: ${mostFrequentGesture} | ç½®ä¿¡åº¦: ${maxScore.toFixed(2)} | ç¨³å®šæ€§: ${(stabilityRatio * 100).toFixed(0)}% | ç¼“å†²åŒº: ${gestureBuffer.length}/${GESTURE_BUFFER_SIZE}`);
                        }
                    } else if (stabilityRatio >= 0.8 && mostFrequentGesture === lastConfirmedGesture) {
                        // é«˜ç¨³å®šæ€§ç¡®è®¤ï¼Œå¯ä»¥æ˜¾ç¤ºç½®ä¿¡åº¦ä¿¡æ¯
                        updateGestureConfidence(gestureScores, mostFrequentGesture, maxScore, stabilityRatio);
                    }
                }
            } else {
                // æ²¡æœ‰æ£€æµ‹åˆ°æœ‰æ•ˆæ‰‹åŠ¿ï¼Œæ¸è¿›å¼æ¸…ç©ºç¼“å†²åŒº
                if (gestureBuffer.length > 0) {
                    gestureBuffer.shift();
                }
            }

            // æ›´æ–°UIæ˜¾ç¤º
            updateGestureDisplay(lastConfirmedGesture);
        }

        // å¢å¼ºçš„æ‰‹åŠ¿ç½®ä¿¡åº¦å¯è§†åŒ–å‡½æ•°
        function updateGestureConfidence(gestureScores, detectedGesture, confidence, stability) {
            // å¯é€‰ï¼šåœ¨è°ƒè¯•ä¿¡æ¯ä¸­æ˜¾ç¤ºè¯¦ç»†ç½®ä¿¡åº¦
            if (detectedGesture && document.getElementById('debug-info').classList.contains('loading-center') === false) {
                const sortedScores = Object.entries(gestureScores)
                    .filter(([_, score]) => score > 0)
                    .sort((a, b) => b[1] - a[1])
                    .map(([g, s]) => {
                        const bar = 'â–ˆ'.repeat(Math.floor(s * 10));
                        return `${g.padEnd(8)}: ${bar} ${(s * 100).toFixed(0)}%`;
                    })
                    .join('\n');
                
                if (sortedScores) {
                    console.log(`å½“å‰æ‰‹åŠ¿: ${detectedGesture} | ç½®ä¿¡åº¦: ${(confidence * 100).toFixed(0)}% | ç¨³å®šæ€§: ${(stability * 100).toFixed(0)}%\n${sortedScores}`);
                }
            }
        }

        // å¢å¼ºçš„æ‰‹åŠ¿è¯†åˆ«å‚æ•°ä¼˜åŒ–
        function optimizeGestureParameters() {
            // æ ¹æ®è¿è¡Œæ—¶æ€§èƒ½å’Œç¯å¢ƒè°ƒæ•´å‚æ•°
            const params = {
                // åŠ¨æ€é˜ˆå€¼ç³»ç»Ÿ
                DYNAMIC_THRESHOLDS: {
                    FIST_DISTANCE: 0.6,
                    OPEN_DISTANCE: 1.2,
                    BEND_THRESHOLD: 0.5,
                    SCISSORS_GAP: 0.3,
                    POINT_DISTANCE: 0.8,
                    THUMB_DISTANCE: 0.9,
                    CONFIDENCE_THRESHOLD: 0.65
                },
                
                // é˜²æŠ–å’Œç¨³å®šæ€§å‚æ•°
                DEBOUNCE: {
                    GESTURE_DEBOUNCE_TIME: 300,  // æ¯«ç§’
                    BUFFER_SIZE: 6,
                    STABILITY_THRESHOLD: 0.6,    // 60%ç¨³å®šæ€§
                    MIN_BUFFER_FOR_CONFIRMATION: 3
                },
                
                // æ‰‹åŠ¿æƒé‡ç³»ç»Ÿ
                WEIGHTS: {
                    DISTANCE_WEIGHT: 0.4,       // è·ç¦»ç‰¹å¾æƒé‡
                    BEND_WEIGHT: 0.3,           // å¼¯æ›²åº¦æƒé‡
                    SPACING_WEIGHT: 0.2,        // é—´è·ç‰¹å¾æƒé‡
                    ANGLE_WEIGHT: 0.1           // è§’åº¦ç‰¹å¾æƒé‡
                }
            };
            
            return params;
        }

        // æ–°å¢ï¼šå®æ—¶æ‰‹åŠ¿åé¦ˆç³»ç»Ÿ
        function showGestureFeedback(debugInfo) {
            const feedback = document.getElementById('gesture-hint');
            if (feedback && debugInfo) {
                feedback.textContent = debugInfo;
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 2000);
            }
        }

        // ==================== è‡ªåŠ¨æ¨¡å¼å¢å¼º ====================
        function startAutoMode(reason) {
            console.log('å¯åŠ¨è‡ªåŠ¨æ¨¡å¼:', reason);
            updateStatus('è‡ªåŠ¨æ¨¡å¼ - ' + reason, false);
            progressManager.complete();
            updateDebugInfo('è‡ªåŠ¨æ¨¡å¼å·²å¯åŠ¨', false);

            // æ˜¾ç¤ºè‡ªåŠ¨æ¨¡å¼æç¤º
            showToast('è‡ªåŠ¨æ¨¡å¼ï¼š' + reason, true);

            const autoCycle = () => {
                if (handLandmarks) {
                    // å¦‚æœæ‘„åƒå¤´å·²å¯åŠ¨ï¼Œåœæ­¢è‡ªåŠ¨æ¨¡å¼
                    updateStatus('æ‘„åƒå¤´æ¨¡å¼å·²æ¢å¤', true);
                    return;
                }
                
                const gestures = ['open', 'scissors', 'fist', 'point', 'thumbsUp'];
                const currentIndex = gestures.indexOf(currentGesture);
                const nextIndex = (currentIndex + 1) % gestures.length;
                
                currentGesture = gestures[nextIndex];
                lastConfirmedGesture = currentGesture;
                updateStatus('è‡ªåŠ¨æ¨¡å¼: ' + getGestureName(currentGesture), false);
                updateGestureDisplay(currentGesture);
                triggerExplosion();
                
                // åœ¨è‡ªåŠ¨æ¨¡å¼ä¸‹æ˜¾ç¤ºæç¤º
                const hint = document.getElementById('gesture-hint');
                if (hint) {
                    hint.textContent = `è‡ªåŠ¨æ¨¡å¼: ${getGestureName(currentGesture)} (æŒ‰ä»»æ„æ‰‹åŠ¿é”®åˆ‡æ¢å›æ‰‹åŠ¨)`;
                    hint.classList.add('show');
                    setTimeout(() => hint.classList.remove('show'), 2000);
                }
            };

            // å¯åŠ¨å¾ªç¯
            const intervalId = setInterval(autoCycle, 6000);
            setTimeout(autoCycle, 1500);

            // ç›‘å¬æ‘„åƒå¤´æ¢å¤
            const checkCamera = setInterval(() => {
                if (handLandmarks) {
                    clearInterval(intervalId);
                    clearInterval(checkCamera);
                    updateStatus('æ‘„åƒå¤´æ¨¡å¼å·²æ¢å¤', true);
                    showToast('æ‘„åƒå¤´æ¨¡å¼å·²æ¢å¤');
                }
            }, 1000);
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            if (particles) {
                updatePhysics(deltaTime);
            }
            
            renderer.render(scene, camera);
            updateFPS(now);
        }

        // ==================== UI æ›´æ–° ====================
        function updateStatus(text, active) {
            const statusEl = document.getElementById('gestureStatus');
            const indicator = document.getElementById('statusIndicator');

            if (statusEl) {
                statusEl.textContent = text;
                statusEl.style.color = active ? '#00ffff' : '#ffaa00';
            }

            if (indicator) {
                indicator.className = active ? 'status-indicator active' : 'status-indicator';
            }
        }

        function updateGestureDisplay(gesture) {
            const iconEl = document.getElementById('gestureIcon');
            const nameEl = document.getElementById('gestureName');

            if (!gesture) {
                iconEl.textContent = 'âœ‹';
                nameEl.textContent = 'ç­‰å¾…æ‰‹åŠ¿...';
                return;
            }

            const gestureInfo = {
                'open': { icon: 'âœ‹', name: 'å¼ æ‰‹' },
                'scissors': { icon: 'âœŒï¸', name: 'å‰ªåˆ€' },
                'fist': { icon: 'âœŠ', name: 'æ¡æ‹³' },
                'point': { icon: 'â˜ï¸', name: 'é£ŸæŒ‡' },
                'thumbsUp': { icon: 'ğŸ‘', name: 'å¤§æ‹‡æŒ‡' }
            };

            const info = gestureInfo[gesture];
            if (info) {
                iconEl.textContent = info.icon;
                nameEl.textContent = info.name;
            }
        }

        function updateShapeStatus(shape) {
            const el = document.getElementById('shapeStatus');
            if (el) el.textContent = shape;
        }

        function updateFPS(now) {
            frameCount++;
            
            if (now - fpsUpdateTimer >= 1000) {
                fps = Math.round((frameCount * 1000) / (now - fpsUpdateTimer));
                const fpsEl = document.getElementById('fpsCounter');
                if (fpsEl) {
                    fpsEl.textContent = `${fps} FPS`;
                    fpsEl.style.color = fps >= 50 ? '#00ff00' : fps >= 30 ? '#ffff00' : '#ff0000';
                }
                frameCount = 0;
                fpsUpdateTimer = now;
            }
        }

        function updateDebugInfo(text, showLoader) {
            const debug = document.getElementById('debug-info');
            if (debug) {
                debug.textContent = text;
                if (showLoader) {
                    debug.classList.add('loading-center');
                    debug.classList.remove('debug-hidden');
                } else {
                    debug.classList.remove('loading-center');
                    setTimeout(() => {
                        debug.classList.add('debug-hidden');
                    }, 2000);
                }
            }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('stateToast');
            toast.textContent = message;
            toast.className = isError ? 'error show' : 'show';
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        function getGestureName(gesture) {
            const names = {
                'open': 'å¼ æ‰‹',
                'scissors': 'å‰ªåˆ€æ‰‹',
                'fist': 'æ¡æ‹³',
                'point': 'é£ŸæŒ‡',
                'thumbsUp': 'ç«–å¤§æ‹‡æŒ‡'
            };
            return names[gesture] || gesture;
        }

        // ==================== çª—å£è°ƒæ•´ ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== UI æ§åˆ¶å‡½æ•° ====================
        window.toggleFullScreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    showToast('è¿›å…¥å…¨å±æ¨¡å¼');
                }).catch(() => {
                    showToast('å…¨å±è¯·æ±‚å¤±è´¥', true);
                });
            } else {
                document.exitFullscreen().then(() => {
                    showToast('é€€å‡ºå…¨å±æ¨¡å¼');
                });
            }
        };

        window.toggleUI = function() {
            uiVisible = !uiVisible;
            const elements = [
                'infoPanel', 'gestureIndicator', 'topButtons', 
                'controlPanel', 'infoTooltip', 'mainTitle'
            ];
            
            elements.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    if (!uiVisible) {
                        el.classList.add('panel-hidden');
                    } else {
                        el.classList.remove('panel-hidden');
                    }
                }
            });
            
            showToast(uiVisible ? 'UIæ˜¾ç¤º' : 'UIéšè—');
        };

        window.manualSetGesture = function(mode) {
            if (isCameraActive) {
                showToast('æ‘„åƒå¤´æ¨¡å¼ä¸‹è‡ªåŠ¨è¯†åˆ«', true);
                return;
            }
            currentGesture = mode;
            updateStatus(getGestureName(mode), true);
            triggerExplosion();
            showToast(getGestureName(mode));
        };

        window.triggerExplosion = function() {
            const count = CONFIG.PARTICLE_COUNT;
            const force = CONFIG.PHYSICS.EXPLOSION_FORCE;
            
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                velocity[i3] += force * Math.sin(phi) * Math.cos(theta);
                velocity[i3 + 1] += force * Math.sin(phi) * Math.sin(theta);
                velocity[i3 + 2] += force * Math.cos(phi);
            }
            
            showToast('ğŸ’¥ çˆ†ç‚¸ç‰¹æ•ˆå·²è§¦å‘');
        };

        window.toggleStorm = function() {
            stormActive = !stormActive;
            const btn = document.getElementById('stormBtn');
            if (stormActive) {
                btn.classList.add('active');
                showToast('ğŸŒªï¸ é£æš´æ¨¡å¼å·²å¼€å¯');
            } else {
                btn.classList.remove('active');
                showToast('ğŸŒªï¸ é£æš´æ¨¡å¼å·²å…³é—­');
            }
        };

        // ==================== æ‹–æ‹½æ ‡é¢˜åŠŸèƒ½ ====================
        function initDraggableTitle() {
            const title = document.getElementById('mainTitle');
            let isDragging = false;
            let offset = { x: 0, y: 0 };

            title.addEventListener('mousedown', (e) => {
                isDragging = true;
                const rect = title.getBoundingClientRect();
                offset.x = e.clientX - rect.left;
                offset.y = e.clientY - rect.top;
                title.style.cursor = 'grabbing';
                title.style.transform = 'none';
                title.style.left = rect.left + 'px';
                title.style.top = rect.top + 'px';
                e.preventDefault();
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const x = e.clientX - offset.x;
                const y = e.clientY - offset.y;
                title.style.left = x + 'px';
                title.style.top = y + 'px';
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                title.style.cursor = 'move';
            });

            // ç§»åŠ¨ç«¯æ”¯æŒ
            title.addEventListener('touchstart', (e) => {
                isDragging = true;
                const touch = e.touches[0];
                const rect = title.getBoundingClientRect();
                offset.x = touch.clientX - rect.left;
                offset.y = touch.clientY - rect.top;
                title.style.transform = 'none';
                title.style.left = rect.left + 'px';
                title.style.top = rect.top + 'px';
                e.preventDefault();
            });

            window.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const x = touch.clientX - offset.x;
                const y = touch.clientY - offset.y;
                title.style.left = x + 'px';
                title.style.top = y + 'px';
            });

            window.addEventListener('touchend', () => {
                isDragging = false;
            });
        }

        // ==================== é”®ç›˜å¿«æ·é”® ====================
        function initKeyboardShortcuts() {
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch(e.key.toLowerCase()) {
                    case 'f':
                        e.preventDefault();
                        toggleFullScreen();
                        break;
                    case 'h':
                        e.preventDefault();
                        toggleUI();
                        break;
                    case '1':
                        manualSetGesture('open');
                        break;
                    case '2':
                        manualSetGesture('scissors');
                        break;
                    case '3':
                        manualSetGesture('fist');
                        break;
                    case '4':
                        manualSetGesture('point');
                        break;
                    case '5':
                        manualSetGesture('thumbsUp');
                        break;
                    case 'e':
                        triggerExplosion();
                        break;
                    case 't':
                        toggleStorm();
                        break;
                    case ' ':
                        e.preventDefault();
                        if (!isCameraActive) {
                            const gestures = ['open', 'scissors', 'fist', 'point', 'thumbsUp'];
                            const currentIndex = gestures.indexOf(currentGesture);
                            const nextIndex = (currentIndex + 1) % gestures.length;
                            manualSetGesture(gestures[nextIndex]);
                        }
                        break;
                }
            });
        }

        // ==================== æ‘„åƒå¤´é¢„è§ˆæ§åˆ¶å¢å¼º ====================
        window.toggleCameraPreview = function() {
            const preview = document.getElementById('cameraPreview');
            const status = document.getElementById('cameraStatus');
            
            if (!cameraVideo || !isCameraActive) {
                showToast('æ‘„åƒå¤´æœªå¯åŠ¨', true);
                return;
            }

            if (preview.classList.contains('show')) {
                preview.classList.remove('show');
                showToast('æ‘„åƒå¤´é¢„è§ˆå·²éšè—');
                updateDebugInfo('é¢„è§ˆçª—å£å·²å…³é—­', false);
            } else {
                preview.classList.add('show');
                // æ›´æ–°é¢„è§ˆçª—å£ä¸­çš„è§†é¢‘æº
                const previewVideo = document.getElementById('cameraVideo');
                if (previewVideo.srcObject !== cameraVideo.srcObject) {
                    previewVideo.srcObject = cameraVideo.srcObject;
                    previewVideo.play().catch(e => console.log('é¢„è§ˆæ’­æ”¾å¤±è´¥:', e));
                }
                status.textContent = 'æ‘„åƒå¤´è¿è¡Œä¸­';
                status.classList.add('active');
                showToast('æ‘„åƒå¤´é¢„è§ˆå·²æ˜¾ç¤º');
                updateDebugInfo('é¢„è§ˆçª—å£å·²æ‰“å¼€', false);
            }
        };

        window.toggleCameraMirror = function() {
            const previewVideo = document.getElementById('cameraVideo');
            const currentTransform = previewVideo.style.transform;
            
            if (currentTransform === 'scaleX(-1)') {
                previewVideo.style.transform = 'scaleX(1)';
                showToast('é•œåƒå…³é—­');
                updateDebugInfo('é¢„è§ˆé•œåƒå·²å…³é—­', false);
            } else {
                previewVideo.style.transform = 'scaleX(-1)';
                showToast('é•œåƒå¼€å¯');
                updateDebugInfo('é¢„è§ˆé•œåƒå·²å¼€å¯', false);
            }
        };

        // æ–°å¢ï¼šæ‘„åƒå¤´çŠ¶æ€æ£€æŸ¥
        function checkCameraHealth() {
            if (!cameraVideo || !isCameraActive) return false;
            
            // æ£€æŸ¥è§†é¢‘æµæ˜¯å¦æ­£å¸¸
            if (cameraVideo.readyState >= 2) {
                // è§†é¢‘æµæ­£å¸¸
                return true;
            } else {
                // è§†é¢‘æµæœ‰é—®é¢˜ï¼Œå°è¯•é‡æ–°å¯åŠ¨
                console.log('æ‘„åƒå¤´è§†é¢‘æµå¼‚å¸¸ï¼Œå°è¯•æ¢å¤...');
                return false;
            }
        }

        // æ–°å¢ï¼šæ‰‹åŠ¿è¯†åˆ«æ€§èƒ½ç›‘æ§
        let gesturePerformance = {
            lastUpdate: Date.now(),
            frameCount: 0,
            avgProcessingTime: 0,
            detectionRate: 0
        };

        function monitorGesturePerformance() {
            const now = Date.now();
            gesturePerformance.frameCount++;
            
            if (now - gesturePerformance.lastUpdate >= 1000) {
                gesturePerformance.detectionRate = gesturePerformance.frameCount;
                gesturePerformance.frameCount = 0;
                gesturePerformance.lastUpdate = now;
                
                // æ¯ç§’è¾“å‡ºæ€§èƒ½ä¿¡æ¯
                if (gesturePerformance.detectionRate > 0) {
                    console.log(`æ‰‹åŠ¿è¯†åˆ«æ€§èƒ½: ${gesturePerformance.detectionRate} FPS`);
                }
            }
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        window.addEventListener('load', () => {
            init();
            initKeyboardShortcuts();
            
            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            setTimeout(() => {
                animate();
            }, 100);

            // æ˜¾ç¤ºæ¬¢è¿æç¤º
            setTimeout(() => {
                const hint = document.getElementById('gesture-hint');
                if (hint) {
                    hint.textContent = 'ğŸ’¡ æç¤ºï¼šå¼ æ‰‹/å‰ªåˆ€/æ¡æ‹³/é£ŸæŒ‡/å¤§æ‹‡æŒ‡ | ç‚¹å‡»æ‘„åƒå¤´æŒ‰é’®é¢„è§ˆ';
                    hint.classList.add('show');
                    setTimeout(() => hint.classList.remove('show'), 5000);
                }
            }, 3000);
        });
    </script>
</body>
</html>
