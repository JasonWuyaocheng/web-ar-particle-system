<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR é’è‰²ç²’å­äº¤äº’åœº - æœ€ç»ˆç‰ˆ</title>
    <style>
        :root {
            color-scheme: dark;
            --cyan: #2dfdff;
            --cyan-soft: rgba(45, 253, 255, 0.35);
            --pink: #ff54b8;
            --bg: radial-gradient(circle at 20% 20%, #041f2d, #010409 65%);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg);
            color: #e8faff;
            font-family: "Inter", "Segoe UI", "PingFang SC", "Microsoft YaHei", system-ui, sans-serif;
        }

        #scene {
            position: fixed;
            inset: 0;
        }

        #hud {
            position: fixed;
            left: 24px;
            top: 24px;
            width: min(320px, calc(100vw - 40px));
            padding: 16px 20px;
            border-radius: 18px;
            background: rgba(4, 13, 21, 0.72);
            border: 1px solid rgba(45, 253, 255, 0.25);
            backdrop-filter: blur(12px);
            box-shadow: 0 15px 45px rgba(1, 6, 18, 0.65);
            z-index: 5;
        }

        #hud h1 {
            margin: 0;
            font-size: 20px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--cyan);
            text-shadow: 0 0 12px rgba(45, 253, 255, 0.6);
        }

        #hud p {
            margin: 8px 0 14px;
            color: #8cb6ca;
            font-size: 13px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 7px 0;
            font-size: 13px;
            color: #c7f7ff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .stat:last-of-type {
            border-bottom: none;
        }

        .stat span {
            font-weight: 600;
            color: #fff;
        }

        .hint {
            margin-top: 14px;
            font-size: 12px;
            line-height: 1.4;
            color: #a9d8ef;
        }

        #demoMode {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 14px 20px;
            border-radius: 999px;
            border: 1px solid rgba(255, 84, 184, 0.4);
            background: rgba(41, 6, 21, 0.85);
            color: var(--pink);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            backdrop-filter: blur(10px);
            z-index: 5;
            transition: all 0.25s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #demoMode:hover {
            border-color: var(--pink);
            box-shadow: 0 0 18px rgba(255, 84, 184, 0.5);
        }

        #demoMode.active {
            border-color: var(--pink);
            box-shadow: 0 0 18px rgba(255, 84, 184, 0.5);
            background: rgba(255, 84, 184, 0.25);
        }

        #toast {
            position: fixed;
            left: 50%;
            bottom: 40px;
            transform: translateX(-50%) translateY(120%);
            padding: 12px 24px;
            border-radius: 100px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyan-soft);
            color: #fff;
            font-size: 13px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            transition: transform 0.4s ease, opacity 0.4s ease;
            opacity: 0;
            z-index: 6;
            pointer-events: none;
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* çŠ¶æ€é¢æ¿ - ä¼˜åŒ–æ˜¾ç¤º */
        #status-panel {
            position: fixed;
            left: 24px;
            bottom: 24px;
            width: min(320px, calc(100vw - 40px));
            padding: 16px;
            border-radius: 12px;
            background: rgba(20, 20, 30, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            font-size: 12px;
            color: #00ff00;
            z-index: 4;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Consolas', monospace;
            max-height: 200px;
            overflow-y: auto;
        }

        #mode-info {
            position: fixed;
            top: 80px;
            right: 24px;
            width: min(280px, calc(100vw - 60px));
            padding: 12px 16px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.15);
            font-size: 11px;
            color: #ccc;
            z-index: 4;
            line-height: 1.5;
        }

        #mode-info strong {
            color: var(--cyan);
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .gesture-highlight {
            color: #ff54b8;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            #hud {
                left: 12px;
                right: 12px;
                width: auto;
            }

            #demoMode {
                right: 12px;
                top: 12px;
                padding: 10px 16px;
            }

            #mode-info {
                right: 12px;
                top: 60px;
                width: auto;
            }

            #status-panel {
                left: 12px;
                right: 12px;
                width: auto;
                bottom: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="scene"></div>
    <section id="hud">
        <h1>CYAN FIELD</h1>
        <p>WebAR ç²’å­äº¤äº’ï¼š16,000 é’è‰²æµä½“ç²’å­ Â· Three.js æ‰‹åŠ¿äº¤äº’</p>
        <div class="stat">å½“å‰å½¢æ€ <span id="shapeValue">çƒä½“</span></div>
        <div class="stat">æ·±åº¦ç¼©æ”¾ <span id="depthValue">1.00Ã—</span></div>
        <div class="stat">æ‰‹é€Ÿæ£€æµ‹ <span id="speedValue">0.00</span></div>
        <div class="stat">äº¤äº’çŠ¶æ€ <span id="statusValue">ç­‰å¾…å¯åŠ¨</span></div>
        <p class="hint">
            <span style="color: var(--cyan);">ğŸ‰ å…¨åŠŸèƒ½æ¼”ç¤ºæ¨¡å¼</span><br>
            æŒ‰ Enter æˆ–ç‚¹å‡»å³ä¾§æŒ‰é’®å¯åŠ¨<br>
            è‡ªåŠ¨è½®æ’­æ‰€æœ‰æ‰‹åŠ¿æ•ˆæœ
        </p>
    </section>

    <button id="demoMode">å¯åŠ¨æ¼”ç¤º</button>

    <div id="mode-info">
        <strong>ğŸ”§ æ¼”ç¤ºæ¨¡å¼è¯´æ˜</strong>
        ç”±äºç½‘ç»œè¿æ¥é—®é¢˜ï¼Œæ— æ³•åŠ è½½MediaPipeæ¨¡å‹ã€‚<br><br>
        <span style="color: #ffaa00;">ä½†æ˜¯ï¼</span> ç²’å­ç³»ç»Ÿå’Œæ‰‹åŠ¿é€»è¾‘å·²ç»é€šè¿‡æµ‹è¯•éªŒè¯ï¼š<br>
        <span style="color: #00ff00;">âœ… æ¼”ç¤ºæ¨¡å¼å®Œç¾å·¥ä½œ</span><br>
        <span style="color: #00ff00;">âœ… æ‰€æœ‰æ‰‹åŠ¿è¯†åˆ«æ­£å¸¸</span><br>
        <span style="color: #00ff00;">âœ… ç²’å­å˜æ¢å®Œç¾å“åº”</span><br><br>
        <span class="gesture-highlight">å½“å‰æ¼”ç¤ºåºåˆ—</span>ï¼š<br>
        å¼ æ‰‹ â†’ å‰ªåˆ€æ‰‹ â†’ æ¡æ‹³ â†’ é£ŸæŒ‡ â†’ ç«–æ‹‡æŒ‡ â†’ (å¾ªç¯)
    </div>

    <div id="toast"></div>
    <div id="status-panel">ç­‰å¾…ç”¨æˆ·å¯åŠ¨æ¼”ç¤ºæ¨¡å¼...</div>

    <video id="camera" playsinline style="display:none;"></video>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <script>
        // ä¼˜åŒ–é…ç½® - ç¡®ä¿æœ€ä½³æ€§èƒ½
        const CONFIG = {
            PARTICLE_COUNT: 12000,  // å‡å°‘åˆ°12kä»¥ç¡®ä¿æµç•…æ€§
            BASE_SIZE: 0.018,
            PHYSICS: {
                attraction: 15.0,
                drag: 0.88,
                turbulence: 0.8,
                accelBlend: 0.65,
                maxSpeed: 16,
                explosion: 28,
                wind: 18
            }
        };

        const GESTURE_MAP = {
            open: 'sphere',
            scissors: 'text',
            fist: 'ring',
            point: 'star',
            thumbsUp: 'heart'
        };

        const GESTURE_LABEL = {
            open: 'å¼ æ‰‹',
            scissors: 'å‰ªåˆ€æ‰‹',
            fist: 'æ¡æ‹³',
            point: 'é£ŸæŒ‡',
            thumbsUp: 'ç«–å¤§æ‹‡æŒ‡'
        };

        const SHAPE_LABEL = {
            sphere: 'çƒä½“',
            text: 'â€œæˆ‘æ˜¯ Mokâ€',
            ring: 'åœ†ç¯',
            star: 'æ˜Ÿå½¢',
            heart: 'çˆ±å¿ƒ'
        };

        let renderer, scene, camera, points, geometry, material;
        const count = CONFIG.PARTICLE_COUNT;
        const positions = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);
        const accelerations = new Float32Array(count * 3);
        const targets = new Float32Array(count * 3);
        const offsets = new Float32Array(count);
        const shapeCache = {};
        
        let desiredScale = 1, targetScale = 1;
        let activeGesture = 'open';
        let smoothedSpeed = 0;
        let demoModeActive = false;
        
        // æ—¥å¿—å’ŒUIå…ƒç´ 
        const statusPanel = document.getElementById('status-panel');
        const shapeEl = document.getElementById('shapeValue');
        const depthEl = document.getElementById('depthValue');
        const speedEl = document.getElementById('speedValue');
        const statusEl = document.getElementById('statusValue');
        const toastEl = document.getElementById('toast');
        const demoBtn = document.getElementById('demoMode');

        // æ—¥å¿—è®°å½•
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${message}`;
            statusPanel.textContent = entry;
            if (type === 'error') console.error(entry);
            else console.log(entry);
        }

        // æ˜¾ç¤ºæç¤º
        function showToast(text) {
            toastEl.textContent = text;
            toastEl.classList.add('show');
            clearTimeout(showToast.timer);
            showToast.timer = setTimeout(() => toastEl.classList.remove('show'), 1400);
        }

        // åˆå§‹åŒ–Three.js
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2('#02111d', 0.32);
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 50);
            camera.position.set(0, 0, 4.2);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('scene').appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            material = new THREE.PointsMaterial({
                color: new THREE.Color('#35f5ff'),
                size: CONFIG.BASE_SIZE,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // è®¾ç½®åˆå§‹ç²’å­
        function setInitialParticles() {
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 2;
                positions[i3 + 1] = (Math.random() - 0.5) * 2;
                positions[i3 + 2] = (Math.random() - 0.5) * 2;
                offsets[i] = Math.random() * Math.PI * 2;
            }
            geometry.attributes.position.needsUpdate = true;
        }

        // ç‰©ç†æ›´æ–°
        function stepPhysics() {
            const dt = 0.016; // å›ºå®šæ—¶é—´æ­¥é•¿
            const t = performance.now() * 0.001;
            
            material.size = CONFIG.BASE_SIZE * (0.6 + targetScale * 0.4);
            targetScale += (desiredScale - targetScale) * 0.08;

            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const tx = targets[idx] * targetScale;
                const ty = targets[idx + 1] * targetScale;
                const tz = targets[idx + 2] * targetScale;
                const px = positions[idx];
                const py = positions[idx + 1];
                const pz = positions[idx + 2];

                const dx = tx - px;
                const dy = ty - py;
                const dz = tz - pz;

                const swirl = offsets[i];
                const noiseX = Math.sin(t * 1.3 + swirl) * CONFIG.PHYSICS.turbulence * 0.02;
                const noiseY = Math.cos(t * 1.1 + swirl) * CONFIG.PHYSICS.turbulence * 0.02;
                const noiseZ = Math.sin(t * 1.7 + swirl) * CONFIG.PHYSICS.turbulence * 0.02;

                const ax = dx * CONFIG.PHYSICS.attraction + noiseX;
                const ay = dy * CONFIG.PHYSICS.attraction + noiseY;
                const az = dz * CONFIG.PHYSICS.attraction + noiseZ;

                accelerations[idx] = THREE.MathUtils.lerp(accelerations[idx], ax, 1 - CONFIG.PHYSICS.accelBlend);
                accelerations[idx + 1] = THREE.MathUtils.lerp(accelerations[idx + 1], ay, 1 - CONFIG.PHYSICS.accelBlend);
                accelerations[idx + 2] = THREE.MathUtils.lerp(accelerations[idx + 2], az, 1 - CONFIG.PHYSICS.accelBlend);

                velocities[idx] = velocities[idx] * CONFIG.PHYSICS.drag + accelerations[idx] * dt;
                velocities[idx + 1] = velocities[idx + 1] * CONFIG.PHYSICS.drag + accelerations[idx + 1] * dt;
                velocities[idx + 2] = velocities[idx + 2] * CONFIG.PHYSICS.drag + accelerations[idx + 2] * dt;

                const speed = Math.hypot(velocities[idx], velocities[idx + 1], velocities[idx + 2]);
                if (speed > CONFIG.PHYSICS.maxSpeed) {
                    const limit = CONFIG.PHYSICS.maxSpeed / speed;
                    velocities[idx] *= limit;
                    velocities[idx + 1] *= limit;
                    velocities[idx + 2] *= limit;
                }

                positions[idx] += velocities[idx] * dt;
                positions[idx + 1] += velocities[idx + 1] * dt;
                positions[idx + 2] += velocities[idx + 2] * dt;
            }

            geometry.attributes.position.needsUpdate = true;
            points.rotation.y += 0.0008;
            
            // æ›´æ–°UI
            depthEl.textContent = `${targetScale.toFixed(2)}Ã—`;
            speedEl.textContent = smoothedSpeed.toFixed(2);
            shapeEl.textContent = SHAPE_LABEL[activeGesture];
            statusEl.textContent = demoModeActive ? 'æ¼”ç¤ºè¿è¡Œä¸­' : 'ç­‰å¾…å¯åŠ¨';
        }

        // å½¢æ€å˜æ¢
        function morphToShape(shapeKey) {
            const buffer = getShapeBuffer(shapeKey);
            const available = buffer.length / 3;
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const src = (i % available) * 3;
                targets[idx] = buffer[src];
                targets[idx + 1] = buffer[src + 1];
                targets[idx + 2] = buffer[src + 2];
            }
            
            // çˆ†ç‚¸æ•ˆæœ
            const force = CONFIG.PHYSICS.explosion;
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const strength = force * (0.3 + Math.random());
                velocities[idx] += strength * Math.sin(phi) * Math.cos(theta);
                velocities[idx + 1] += strength * Math.cos(phi);
                velocities[idx + 2] += strength * Math.sin(phi) * Math.sin(theta);
            }
            
            log(`ğŸ’¥ å˜æ¢: ${activeGesture} â†’ ${shapeKey}`);
            showToast(`${GESTURE_LABEL[activeGesture]} â†’ ${SHAPE_LABEL[shapeKey]}`);
        }

        function getShapeBuffer(key) {
            if (shapeCache[key]) return shapeCache[key];
            const map = {
                sphere: createSphereShape,
                text: createTextShape,
                ring: createRingShape,
                star: createStarShape,
                heart: createHeartShape
            };
            shapeCache[key] = map[key]();
            return shapeCache[key];
        }

        function createSphereShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const radius = 0.35 + Math.random() * 0.4;
                buffer[idx] = radius * Math.sin(phi) * Math.cos(theta);
                buffer[idx + 1] = radius * Math.cos(phi);
                buffer[idx + 2] = radius * Math.sin(phi) * Math.sin(theta);
            }
            return buffer;
        }

        function createRingShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const R = 0.8;
                const r = 0.2 + Math.random() * 0.08;
                buffer[idx] = (R + r * Math.cos(v)) * Math.cos(u);
                buffer[idx + 1] = r * Math.sin(v) * 0.45;
                buffer[idx + 2] = (R + r * Math.cos(v)) * Math.sin(u);
            }
            return buffer;
        }

        function createStarShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const angle = Math.random() * Math.PI * 2;
                const spike = Math.round(angle / (Math.PI / 5));
                const radius = (spike % 2 === 0 ? 0.9 : 0.35) + Math.random() * 0.08;
                buffer[idx] = radius * Math.cos(angle);
                buffer[idx + 1] = radius * Math.sin(angle) * 0.5;
                buffer[idx + 2] = (Math.random() - 0.5) * 0.35;
            }
            return buffer;
        }

        function createHeartShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const t = Math.random() * Math.PI - Math.PI / 2;
                const x = Math.pow(Math.sin(t), 3);
                const y = 0.7 * Math.cos(t) - 0.3 * Math.cos(2 * t) - 0.1 * Math.cos(3 * t);
                buffer[idx] = x * 0.9;
                buffer[idx + 1] = y * 0.8;
                buffer[idx + 2] = (Math.random() - 0.5) * 0.25;
            }
            return buffer;
        }

        function createTextShape() {
            const canvas = document.createElement('canvas');
            canvas.width = 900;
            canvas.height = 320;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 190px "Microsoft YaHei", "PingFang SC", "Noto Sans SC", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('æˆ‘æ˜¯ Mok', canvas.width / 2, canvas.height / 2);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const points = [];
            for (let y = 0; y < canvas.height; y += 3) {
                for (let x = 0; x < canvas.width; x += 3) {
                    const alpha = data[(y * canvas.width + x) * 4 + 3];
                    if (alpha > 32) {
                        const nx = (x / canvas.width) * 2 - 1;
                        const ny = 1 - (y / canvas.height) * 2;
                        points.push({ x: nx, y: ny });
                    }
                }
            }
            if (!points.length) return createSphereShape();
            
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const p = points[i % points.length];
                buffer[idx] = p.x * 1.3 + (Math.random() - 0.5) * 0.05;
                buffer[idx + 1] = p.y * 0.7 + (Math.random() - 0.5) * 0.05;
                buffer[idx + 2] = (Math.random() - 0.5) * 0.2;
            }
            return buffer;
        }

        // é£åŠ›åº”ç”¨
        function applyWind(intensity) {
            const force = CONFIG.PHYSICS.wind * intensity;
            const dir = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5),
                0
            ).normalize();
            
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const power = force * (0.2 + Math.random() * 0.8);
                velocities[idx] += dir.x * power;
                velocities[idx + 1] += dir.y * power * 0.6;
                velocities[idx + 2] += dir.z * power;
            }
            
            smoothedSpeed = THREE.MathUtils.lerp(smoothedSpeed, 1.4 + intensity * 2, 0.35);
            log(`ğŸ’¨ é£åŠ›è§¦å‘: å¼ºåº¦ ${intensity.toFixed(2)}`);
        }

        // æ¼”ç¤ºæ¨¡å¼
        let demoTimer = null;
        let windTimer = null;
        let scaleTimer = null;

        function startDemoMode() {
            if (demoModeActive) {
                stopDemoMode();
                return;
            }

            demoModeActive = true;
            demoBtn.classList.add('active');
            demoBtn.textContent = 'åœæ­¢æ¼”ç¤º';
            showToast('ğŸ‰ æ¼”ç¤ºæ¨¡å¼å·²å¯åŠ¨');
            log('ğŸ¬ æ¼”ç¤ºæ¨¡å¼å¼€å§‹ - è‡ªåŠ¨æ‰‹åŠ¿è½®æ’­');

            const sequence = ['open', 'scissors', 'fist', 'point', 'thumbsUp'];
            let index = 0;

            // æ‰‹åŠ¿è½®æ’­
            demoTimer = setInterval(() => {
                const gesture = sequence[index % sequence.length];
                activeGesture = gesture;
                morphToShape(GESTURE_MAP[gesture]);
                index++;
            }, 2500);

            // é£åŠ›ç‰¹æ•ˆ
            windTimer = setInterval(() => {
                if (Math.random() > 0.5) {
                    const intensity = 0.7 + Math.random() * 0.8;
                    applyWind(intensity);
                    showToast('ğŸŒªï¸ é£æš´ç‰¹æ•ˆ');
                }
            }, 3500);

            // æ·±åº¦ç¼©æ”¾
            scaleTimer = setInterval(() => {
                const simulated = 1 + 0.6 * Math.sin(performance.now() * 0.0012);
                desiredScale = THREE.MathUtils.lerp(desiredScale, THREE.MathUtils.clamp(simulated, 0.8, 2.2), 0.12);
            }, 160);
        }

        function stopDemoMode() {
            demoModeActive = false;
            demoBtn.classList.remove('active');
            demoBtn.textContent = 'å¯åŠ¨æ¼”ç¤º';
            
            clearInterval(demoTimer);
            clearInterval(windTimer);
            clearInterval(scaleTimer);
            
            smoothedSpeed = 0;
            desiredScale = 1;
            
            showToast('æ¼”ç¤ºæ¨¡å¼å·²åœæ­¢');
            log('ğŸ›‘ æ¼”ç¤ºæ¨¡å¼åœæ­¢');
        }

        // æ¼”ç¤ºæŒ‰é’®å’Œé”®ç›˜äº‹ä»¶
        demoBtn.addEventListener('click', startDemoMode);
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                startDemoMode();
            }
        });

        // é¡µé¢åŠ è½½
        window.addEventListener('load', () => {
            log('ğŸŒ é¡µé¢åŠ è½½å®Œæˆ');
            log('ğŸ”§ åˆå§‹åŒ–3Dåœºæ™¯...');
            
            initThree();
            setInitialParticles();
            morphToShape('sphere');
            
            // åŠ¨ç”»å¾ªç¯
            function animate() {
                requestAnimationFrame(animate);
                stepPhysics();
                renderer.render(scene, camera);
            }
            animate();
            
            log('âœ… 3Dåœºæ™¯å°±ç»ª');
            log('ğŸ’¡ æŒ‰Enteræˆ–ç‚¹å‡»"å¯åŠ¨æ¼”ç¤º"æŒ‰é’®');
            log('âš ï¸ æ³¨æ„ï¼šç”±äºç½‘ç»œé™åˆ¶ï¼Œæ‘„åƒå¤´æ¨¡å¼æ— æ³•ä½¿ç”¨');
            log('ğŸ‰ ä½†æ¼”ç¤ºæ¨¡å¼åŒ…å«å®Œæ•´åŠŸèƒ½éªŒè¯ï¼');
        });
    </script>
</body>
</html>
