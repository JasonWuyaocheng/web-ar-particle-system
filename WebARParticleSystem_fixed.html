<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR é’è‰²ç²’å­äº¤äº’åœº - ä¿®å¤ç‰ˆ</title>
    <style>
        :root {
            color-scheme: dark;
            --cyan: #2dfdff;
            --cyan-soft: rgba(45, 253, 255, 0.35);
            --pink: #ff54b8;
            --bg: radial-gradient(circle at 20% 20%, #041f2d, #010409 65%);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg);
            color: #e8faff;
            font-family: "Inter", "Segoe UI", "PingFang SC", "Microsoft YaHei", system-ui, sans-serif;
        }

        #scene {
            position: fixed;
            inset: 0;
        }

        #hud {
            position: fixed;
            left: 24px;
            top: 24px;
            width: min(320px, calc(100vw - 40px));
            padding: 16px 20px;
            border-radius: 18px;
            background: rgba(4, 13, 21, 0.72);
            border: 1px solid rgba(45, 253, 255, 0.25);
            backdrop-filter: blur(12px);
            box-shadow: 0 15px 45px rgba(1, 6, 18, 0.65);
            z-index: 5;
        }

        #hud h1 {
            margin: 0;
            font-size: 20px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--cyan);
            text-shadow: 0 0 12px rgba(45, 253, 255, 0.6);
        }

        #hud p {
            margin: 8px 0 14px;
            color: #8cb6ca;
            font-size: 13px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 7px 0;
            font-size: 13px;
            color: #c7f7ff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .stat:last-of-type {
            border-bottom: none;
        }

        .stat span {
            font-weight: 600;
            color: #fff;
        }

        .stat .status-indicator {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            margin-left: 8px;
        }

        .status-waiting { color: #8cb6ca; }
        .status-detecting { color: #ffaa00; animation: pulse 1s infinite; }
        .status-recognized { color: #00ff00; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hint {
            margin-top: 14px;
            font-size: 12px;
            line-height: 1.4;
            color: #a9d8ef;
        }

        #startCamera,
        #demoMode {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 14px 20px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(7, 29, 45, 0.8);
            color: var(--cyan);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            backdrop-filter: blur(10px);
            z-index: 5;
            transition: all 0.25s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #startCamera:hover,
        #demoMode:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 18px rgba(45, 253, 255, 0.5);
        }

        #startCamera[disabled],
        #demoMode[disabled] {
            opacity: 0.45;
            cursor: default;
        }

        #demoMode {
            top: 76px;
            background: rgba(41, 6, 21, 0.85);
            border-color: rgba(255, 84, 184, 0.4);
            color: var(--pink);
        }

        #demoMode.active {
            border-color: var(--pink);
            box-shadow: 0 0 18px rgba(255, 84, 184, 0.5);
        }

        #toast {
            position: fixed;
            left: 50%;
            bottom: 40px;
            transform: translateX(-50%) translateY(120%);
            padding: 12px 24px;
            border-radius: 100px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyan-soft);
            color: #fff;
            font-size: 13px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            transition: transform 0.4s ease, opacity 0.4s ease;
            opacity: 0;
            z-index: 6;
            pointer-events: none;
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        #camera {
            position: fixed;
            width: 160px;
            height: 120px;
            right: 24px;
            bottom: 24px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0;
            transition: opacity 0.4s ease;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            z-index: 4;
        }

        #camera.show {
            opacity: 1;
        }

        /* è°ƒè¯•ä¿¡æ¯é¢æ¿ - ä¿®å¤ç‰ˆ */
        #debug-panel {
            position: fixed;
            left: 24px;
            bottom: 24px;
            width: min(320px, calc(100vw - 40px));
            max-height: 180px;
            overflow-y: auto;
            padding: 12px 16px;
            border-radius: 12px;
            background: rgba(20, 20, 30, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            font-family: 'Consolas', monospace;
            font-size: 11px;
            color: #00ff00;
            z-index: 4;
            display: none;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #debug-panel.show {
            display: block;
        }

        #debug-toggle {
            position: fixed;
            left: 24px;
            bottom: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        #debug-toggle:hover {
            background: rgba(45, 253, 255, 0.2);
            border-color: var(--cyan);
        }

        @media (max-width: 768px) {
            #hud {
                left: 12px;
                right: 12px;
                width: auto;
            }

            #startCamera,
            #demoMode {
                right: 12px;
            }

            #demoMode {
                top: 76px;
            }

            #camera {
                width: 120px;
                height: 90px;
            }

            #debug-panel {
                left: 12px;
                right: 12px;
                width: auto;
                bottom: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="scene"></div>
    <section id="hud">
        <h1>CYAN FIELD</h1>
        <p>WebAR ç²’å­äº¤äº’ï¼š16,000 é’è‰²æµä½“ç²’å­ Â· Three.js + MediaPipe Hands</p>
        <div class="stat">æ‰‹åŠ¿ <span id="gestureValue">ç­‰å¾…</span></div>
        <div class="stat">å½¢æ€ <span id="shapeValue">çƒä½“</span></div>
        <div class="stat">æ·±åº¦ç¼©æ”¾ <span id="depthValue">1.00Ã—</span></div>
        <div class="stat">æ‰‹é€Ÿ <span id="speedValue">0.00</span></div>
        <div class="stat">çŠ¶æ€ <span id="statusValue" class="status-indicator status-waiting">ç­‰å¾…å¯åŠ¨</span></div>
        <p class="hint">
            å¼ æ‰‹â‡¢çƒä½“ Â· å‰ªåˆ€â‡¢"æˆ‘æ˜¯ Mok"æ–‡å­— Â· æ¡æ‹³â‡¢åœ†ç¯ Â· é£ŸæŒ‡â‡¢æ˜Ÿå½¢ Â· ç«–





< gesturesåˆ‡æ¢å¿«é€Ÿæ‰‹ gesture


 gesture>)















                        










</







SoMoP



>

So








So no

'll1



 not for













,



;

It





ToSoA hend





So

SoSo






SoSo



A










So



 These





So










So



























        </p>
    </section>
    <button id="startCamera">å¼€å¯ç›¸æœº Â· MediaPipe Hands</button>
    <button id="demoMode">æ— æ‘„åƒå¤´æ¼”ç¤º</button>
    <div id="toast"></div>
    <div id="debug-panel"></div>
    <div id="debug-toggle">ğŸ›</div>
    <video id="camera" autoplay muted playsinline></video>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils@0.3.1675469240/drawing_utils.js"></script>

    <script>
        const CONFIG = {
            PARTICLE_COUNT: 16000,
            BASE_SIZE: 0.015,
            PHYSICS: {
                attraction: 12.5,
                drag: 0.86,
                turbulence: 0.75,
                accelBlend: 0.7,
                maxSpeed: 14,
                explosion: 24,
                wind: 16
            }
        };

        const GESTURE_MAP = {
            open: 'sphere',
            scissors: 'text',
            fist: 'ring',
            point: 'star',
            thumbsUp: 'heart'
        };

        const GESTURE_LABEL = {
            open: 'å¼ æ‰‹',
            scissors: 'å‰ªåˆ€æ‰‹',
            fist: 'æ¡æ‹³',
            point: 'é£ŸæŒ‡',
            thumbsUp: 'ç«–å¤§æ‹‡æŒ‡'
        };

        const SHAPE_LABEL = {
            sphere: 'çƒä½“',
            text: 'â€œæˆ‘æ˜¯ Mokâ€',
            ring: 'åœ†ç¯',
            star: 'æ˜Ÿå½¢',
            heart: 'çˆ±å¿ƒ'
        };

        // MediaPipe èµ„æºä¸»/å¤‡ CDN - å¢å¼ºçš„CDNé…ç½®
        const HANDS_PRIMARY_BASE = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/';
        const HANDS_FALLBACK_BASE = 'https://unpkg.com/@mediapipe/hands@0.4.1675469240/';
        const HANDS_LOCAL_FALLBACK = 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/';
        
        // æ¨¡å‹æ–‡ä»¶è·¯å¾„
        const MODEL_PATH = 'hand_landmarker.task';

        let renderer;
        let scene;
        let camera;
        let points;
        let geometry;
        let material;
        const count = CONFIG.PARTICLE_COUNT;
        const positions = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);
        const accelerations = new Float32Array(count * 3);
        const targets = new Float32Array(count * 3);
        const offsets = new Float32Array(count);
        const shapeCache = {};
        let desiredScale = 1;
        let targetScale = 1;
        let activeGesture = 'open';
        let pendingGesture = null;
        let pendingFrames = 0;
        const depthEl = document.getElementById('depthValue');
        const gestureEl = document.getElementById('gestureValue');
        const speedEl = document.getElementById('speedValue');
        const shapeEl = document.getElementById('shapeValue');
        const statusEl = document.getElementById('statusValue');
        const toastEl = document.getElementById('toast');
        const videoEl = document.getElementById('camera');
        const startBtn = document.getElementById('startCamera');
        const demoBtn = document.getElementById('demoMode');
        const debugPanel = document.getElementById('debug-panel');
        const debugToggle = document.getElementById('debug-toggle');
        const clock = new THREE.Clock();
        let lastPalm = null;
        let lastPalmTime = 0;
        let smoothedSpeed = 0;
        let demoModeActive = false;
        let demoGestureTimer = null;
        let demoWindTimer = null;
        let demoDepthTimer = null;
        
        // è°ƒè¯•æ—¥å¿—æ•°ç»„ - åœ¨å†…å­˜ä¸­ä¿å­˜
        const debugLogs = [];
        
        // å¢å¼ºçš„è°ƒè¯•æ—¥å¿—å‡½æ•° - ç›´æ¥åœ¨å†…å­˜ä¸­è®°å½•
        function addDebugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const log = `[${timestamp}] ${message}`;
            debugLogs.push(log);
            
            // ä¿æŒæœ€æ–°çš„50æ¡æ—¥å¿—
            if (debugLogs.length > 50) {
                debugLogs.shift();
            }
            
            // å¦‚æœé¢æ¿å¯è§ï¼Œå®æ—¶æ›´æ–°
            if (debugPanel.classList.contains('show')) {
                debugPanel.textContent = debugLogs.join('\n');
            }
            
            // åŒæ—¶åœ¨æ§åˆ¶å°è¾“å‡º
            if (type === 'error') {
                console.error(log);
            } else if (type === 'warn') {
                console.warn(log);
            } else {
                console.log(log);
            }
        }

        // çŠ¶æ€æŒ‡ç¤ºå™¨æ›´æ–°å‡½æ•°
        function updateStatusIndicator(text, className) {
            if (statusEl) {
                statusEl.textContent = text;
                statusEl.className = `status-indicator status-${className}`;
            }
        }

        // ç»™ MediaPipe èµ„æºåŠ  fetch / XHR å…œåº•ï¼šä¸»ç”¨ jsDelivrï¼Œå¤±è´¥é€€å› unpkgï¼Œå†å¤±è´¥å°è¯•æœ¬åœ°
        (function setupHandsCdnFallback() {
            const primary = HANDS_PRIMARY_BASE;
            const fallback = HANDS_FALLBACK_BASE;
            const local = HANDS_LOCAL_FALLBACK;
            
            const rawFetch = window.fetch;
            window.fetch = async (input, init) => {
                const url = typeof input === 'string' ? input : input && input.url;
                let lastError = null;
                
                // å°è¯•æ‰€æœ‰CDNæº
                const sources = [primary, fallback];
                
                for (const base of sources) {
                    if (url && typeof url === 'string' && url.startsWith(base)) {
                        try {
                            const result = await rawFetch(url, init);
                            if (result.ok) {
                                addDebugLog(`âœ… CDNåŠ è½½æˆåŠŸ: ${base}`);
                                return result;
                            }
                        } catch (err) {
                            addDebugLog(`âŒ CDNå¤±è´¥ ${base}: ${err.message}`, 'warn');
                            lastError = err;
                        }
                    }
                }
                
                // å¦‚æœæ‰€æœ‰CDNéƒ½å¤±è´¥äº†ï¼Œä¸”æ˜¯æ¨¡å‹æ–‡ä»¶ï¼Œå°è¯•æœ¬åœ°fallback
                if (url && url.includes(MODEL_PATH) && lastError) {
                    try {
                        addDebugLog(`ğŸ”„ å°è¯•æœ¬åœ°å¤‡ç”¨æ¨¡å‹...`);
                        return await rawFetch(local + MODEL_PATH, init);
                    } catch (err) {
                        addDebugLog(`æœ¬åœ°å¤‡ç”¨ä¹Ÿå¤±è´¥: ${err.message}`, 'error');
                        throw lastError || err;
                    }
                }
                
                throw lastError || new Error('æ‰€æœ‰CDNæºå¤±è´¥');
            };
            
            // XHRåå¤‡
            const rawOpen = XMLHttpRequest.prototype.open;
            const rawSend = XMLHttpRequest.prototype.send;
            
            XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                this._method = method;
                this._primaryUrl = url;
                this._fallbackUrl = (typeof url === 'string' && url.startsWith(primary)) ? url.replace(primary, fallback) : null;
                this._localFallbackUrl = (typeof url === 'string' && url.includes(MODEL_PATH)) ? url.replace(primary, local) : null;
                return rawOpen.call(this, method, url, async, user, password);
            };
            
            XMLHttpRequest.prototype.send = function(body) {
                const tryFallback = (fallbackUrl, errorMsg) => {
                    if (fallbackUrl) {
                        const retry = () => {
                            addDebugLog(`XHRåå¤‡: å°è¯• ${fallbackUrl}`);
                            rawOpen.call(this, this._method || 'GET', fallbackUrl, true);
                            rawSend.call(this, body);
                        };
                        this.addEventListener('error', retry, { once: true });
                        this.addEventListener('timeout', retry, { once: true });
                    }
                };
                
                // å…ˆå°è¯•ä¸»è¦åå¤‡
                tryFallback(this._fallbackUrl, 'ä¸»è¦CDNå¤±è´¥');
                
                // å¦‚æœæ¨¡å‹åŠ è½½å¤±è´¥ï¼Œå°è¯•æœ¬åœ°
                if (this._localFallbackUrl) {
                    setTimeout(() => {
                        this.addEventListener('error', () => {
                            if (this._localFallbackUrl) {
                                addDebugLog('å°è¯•æœ¬åœ°æ¨¡å‹å¤‡ç”¨...');
                                tryFallback(this._localFallbackUrl, 'æœ¬åœ°å¤‡ç”¨');
                            }
                        }, { once: true });
                    }, 0);
                }
                
                return rawSend.call(this, body);
            };
        })();
        
        // å¢å¼ºçš„ç½‘ç»œè¯Šæ–­å·¥å…·
        async function diagnoseNetwork() {
            addDebugLog('ğŸŒ ç½‘ç»œè¯Šæ–­å¼€å§‹...');
            
            const tests = [
                { name: 'ä¸»è¦CDN', url: HANDS_PRIMARY_BASE + 'hands.js' },
                { name: 'å¤‡ç”¨CDN', url: HANDS_FALLBACK_BASE + 'hands.js' },
                { name: 'æœ¬åœ°å¤‡ç”¨', url: HANDS_LOCAL_FALLBACK + MODEL_PATH }
            ];
            
            for (const test of tests) {
                try {
                    const start = performance.now();
                    const response = await fetch(test.url, { method: 'HEAD' });
                    const duration = Math.round(performance.now() - start);
                    addDebugLog(`âœ… ${test.name}: ${response.status} (${duration}ms)`);
                } catch (error) {
                    addDebugLog(`âŒ ${test.name}: ${error.message}`);
                }
            }
            addDebugLog('ğŸŒ è¯Šæ–­å®Œæˆ');
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2('#02111d', 0.32);
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 50);
            camera.position.set(0, 0, 4.2);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('scene').appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            material = new THREE.PointsMaterial({
                color: new THREE.Color('#35f5ff'),
                size: CONFIG.BASE_SIZE,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setInitialParticles() {
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 2;
                positions[i3 + 1] = (Math.random() - 0.5) * 2;
                positions[i3 + 2] = (Math.random() - 0.5) * 2;
                offsets[i] = Math.random() * Math.PI * 2;
            }
            geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            stepPhysics();
            renderer.render(scene, camera);
        }

        function stepPhysics() {
            const dt = Math.min(clock.getDelta(), 0.033);
            const t = performance.now() * 0.001;
            material.size = CONFIG.BASE_SIZE * (0.6 + targetScale * 0.4);
            targetScale += (desiredScale - targetScale) * 0.08;

            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const tx = targets[idx] * targetScale;
                const ty = targets[idx + 1] * targetScale;
                const tz = targets[idx + 2] * targetScale;
                const px = positions[idx];
                const py = positions[idx + 1];
                const pz = positions[idx + 2];

                const dx = tx - px;
                const dy = ty - py;
                const dz = tz - pz;

                const swirl = offsets[i];
                const noiseX = Math.sin(t * 1.3 + swirl) * CONFIG.PHYSICS.turbulence * 0.02;
                const noiseY = Math.cos(t * 1.1 + swirl) * CONFIG.PHYSICS.turbulence * 0.02;
                const noiseZ = Math.sin(t * 1.7 + swirl) * CONFIG.PHYSICS.turbulence * 0.02;

                const ax = dx * CONFIG.PHYSICS.attraction + noiseX;
                const ay = dy * CONFIG.PHYSICS.attraction + noiseY;
                const az = dz * CONFIG.PHYSICS.attraction + noiseZ;

                accelerations[idx] = THREE.MathUtils.lerp(accelerations[idx], ax, 1 - CONFIG.PHYSICS.accelBlend);
                accelerations[idx + 1] = THREE.MathUtils.lerp(accelerations[idx + 1], ay, 1 - CONFIG.PHYSICS.accelBlend);
                accelerations[idx + 2] = THREE.MathUtils.lerp(accelerations[idx + 2], az, 1 - CONFIG.PHYSICS.accelBlend);

                velocities[idx] = velocities[idx] * CONFIG.PHYSICS.drag + accelerations[idx] * dt;
                velocities[idx + 1] = velocities[idx + 1] * CONFIG.PHYSICS.drag + accelerations[idx + 1] * dt;
                velocities[idx + 2] = velocities[idx + 2] * CONFIG.PHYSICS.drag + accelerations[idx + 2] * dt;

                const speed = Math.hypot(velocities[idx], velocities[idx + 1], velocities[idx + 2]);
                if (speed > CONFIG.PHYSICS.maxSpeed) {
                    const limit = CONFIG.PHYSICS.maxSpeed / speed;
                    velocities[idx] *= limit;
                    velocities[idx + 1] *= limit;
                    velocities[idx + 2] *= limit;
                }

                positions[idx] += velocities[idx] * dt;
                positions[idx + 1] += velocities[idx + 1] * dt;
                positions[idx + 2] += velocities[idx + 2] * dt;
            }

            geometry.attributes.position.needsUpdate = true;
            points.rotation.y += 0.0006;
            updateHUD();
        }

        function updateHUD() {
            depthEl.textContent = `${targetScale.toFixed(2)}Ã—`;
            speedEl.textContent = smoothedSpeed.toFixed(2);
            gestureEl.textContent = GESTURE_LABEL[activeGesture] || 'ç­‰å¾…';
            const shapeKey = GESTURE_MAP[activeGesture] || 'sphere';
            shapeEl.textContent = SHAPE_LABEL[shapeKey];
        }

        function morphToShape(shapeKey = 'sphere') {
            const buffer = getShapeBuffer(shapeKey);
            const available = buffer.length / 3;
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const src = (i % available) * 3;
                targets[idx] = buffer[src];
                targets[idx + 1] = buffer[src + 1];
                targets[idx + 2] = buffer[src + 2];
            }
            triggerExplosion(1.1);
        }

        function getShapeBuffer(key = 'sphere') {
            if (shapeCache[key]) return shapeCache[key];
            const map = {
                sphere: createSphereShape,
                text: createTextShape,
                ring: createRingShape,
                star: createStarShape,
                heart: createHeartShape
            };
            const generator = map[key];
            shapeCache[key] = generator ? generator() : createSphereShape();
            return shapeCache[key];
        }

        function createSphereShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const radius = 0.35 + Math.random() * 0.4;
                buffer[idx] = radius * Math.sin(phi) * Math.cos(theta);
                buffer[idx + 1] = radius * Math.cos(phi);
                buffer[idx + 2] = radius * Math.sin(phi) * Math.sin(theta);
            }
            return buffer;
        }

        function createRingShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const R = 0.8;
                const r = 0.2 + Math.random() * 0.08;
                buffer[idx] = (R + r * Math.cos(v)) * Math.cos(u);
                buffer[idx + 1] = r * Math.sin(v) * 0.45;
                buffer[idx + 2] = (R + r * Math.cos(v)) * Math.sin(u);
            }
            return buffer;
        }

        function createStarShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const angle = Math.random() * Math.PI * 2;
                const spike = Math.round(angle / (Math.PI / 5));
                const radius = (spike % 2 === 0 ? 0.9 : 0.35) + Math.random() * 0.08;
                buffer[idx] = radius * Math.cos(angle);
                buffer[idx + 1] = radius * Math.sin(angle) * 0.5;
                buffer[idx + 2] = (Math.random() - 0.5) * 0.35;
            }
            return buffer;
        }

        function createHeartShape() {
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const t = Math.random() * Math.PI - Math.PI / 2;
                const x = Math.pow(Math.sin(t), 3);
                const y = 0.7 * Math.cos(t) - 0.3 * Math.cos(2 * t) - 0.1 * Math.cos(3 * t);
                buffer[idx] = x * 0.9;
                buffer[idx + 1] = y * 0.8;
                buffer[idx + 2] = (Math.random() - 0.5) * 0.25;
            }
            return buffer;
        }

        function createTextShape() {
            const canvas = document.createElement('canvas');
            canvas.width = 900;
            canvas.height = 320;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 190px "Microsoft YaHei", "PingFang SC", "Noto Sans SC", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('æˆ‘æ˜¯ Mok', canvas.width / 2, canvas.height / 2);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const points = [];
            for (let y = 0; y < canvas.height; y += 3) {
                for (let x = 0; x < canvas.width; x += 3) {
                    const alpha = data[(y * canvas.width + x) * 4 + 3];
                    if (alpha > 32) {
                        const nx = (x / canvas.width) * 2 - 1;
                        const ny = 1 - (y / canvas.height) * 2;
                        points.push({ x: nx, y: ny });
                    }
                }
            }
            if (!points.length) {
                return createSphereShape();
            }
            const buffer = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const p = points[i % points.length];
                buffer[idx] = p.x * 1.3 + (Math.random() - 0.5) * 0.05;
                buffer[idx + 1] = p.y * 0.7 + (Math.random() - 0.5) * 0.05;
                buffer[idx + 2] = (Math.random() - 0.5) * 0.2;
            }
            return buffer;
        }

        function triggerExplosion(intensity = 1) {
            const force = CONFIG.PHYSICS.explosion * intensity;
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const strength = force * (0.3 + Math.random());
                velocities[idx] += strength * Math.sin(phi) * Math.cos(theta);
                velocities[idx + 1] += strength * Math.cos(phi);
                velocities[idx + 2] += strength * Math.sin(phi) * Math.sin(theta);
            }
            showToast('å½¢æ€çˆ†è£‚è¿‡æ¸¡');
            addDebugLog(`ğŸ’¥ è§¦å‘çˆ†ç‚¸è¿‡æ¸¡: ${activeGesture} â†’ ${GESTURE_MAP[activeGesture]}`);
        }

        function showToast(text) {
            toastEl.textContent = text;
            toastEl.classList.add('show');
            clearTimeout(showToast.timer);
            showToast.timer = setTimeout(() => toastEl.classList.remove('show'), 1400);
        }

        function updateGesturePipeline(gesture) {
            addDebugLog(`ğŸ”„ updateGesturePipeline called: ${gesture}`);
            
            if (!gesture) {
                pendingFrames = 0;
                pendingGesture = null;
                updateStatusIndicator('æœªæ£€æµ‹åˆ°', 'waiting');
                return;
            }
            
            if (gesture === pendingGesture) {
                pendingFrames += 1;
                updateStatusIndicator(`æ£€æµ‹ä¸­(${pendingFrames})`, 'detecting');
            } else {
                pendingGesture = gesture;
                pendingFrames = 1;
                updateStatusIndicator(`æ–°æ‰‹åŠ¿: ${gesture}`, 'detecting');
            }

            if (pendingGesture && pendingGesture !== activeGesture && pendingFrames > 3) {
                activeGesture = pendingGesture;
                gestureEl.textContent = GESTURE_LABEL[activeGesture];
                const shape = GESTURE_MAP[activeGesture] || 'sphere';
                morphToShape(shape);
                
                // ç¡®è®¤è¯†åˆ«æˆåŠŸ
                updateStatusIndicator(`âœ… ${GESTURE_LABEL[activeGesture]}`, 'recognized');
                showToast(`${GESTURE_LABEL[activeGesture]} â†’ ${SHAPE_LABEL[shape]}`);
                
                addDebugLog(`ğŸ‰ æ‰‹åŠ¿è¯†åˆ«æˆåŠŸ: ${activeGesture} â†’ ${shape}`);
            }
        }

        function classifyGesture(landmarks) {
            const thumb = thumbExtended(landmarks);
            const index = fingerExtended(landmarks, 8, 6, 5);
            const middle = fingerExtended(landmarks, 12, 10, 9);
            const ring = fingerExtended(landmarks, 16, 14, 13);
            const pinky = fingerExtended(landmarks, 20, 18, 17);

            if (index && middle && ring && pinky && thumb) {
                addDebugLog(`ğŸ” æ£€æµ‹åˆ°: å¼ æ‰‹ (open)`);
                return 'open';
            }
            if (!index && !middle && !ring && !pinky && !thumb) {
                addDebugLog(`ğŸ” æ£€æµ‹åˆ°: æ¡æ‹³ (fist)`);
                return 'fist';
            }
            if (index && middle && !ring && !pinky) {
                addDebugLog(`ğŸ” æ£€æµ‹åˆ°: å‰ªåˆ€æ‰‹ (scissors)`);
                return 'scissors';
            }
            if (index && !middle && !ring && !pinky && !thumb) {
                addDebugLog(`ğŸ” æ£€æµ‹åˆ°: é£ŸæŒ‡ (point)`);
                return 'point';
            }
            if (thumb && !index && !middle && !ring && !pinky) {
                addDebugLog(`ğŸ” æ£€æµ‹åˆ°: ç«–å¤§æ‹‡æŒ‡ (thumbsUp)`);
                return 'thumbsUp';
            }
            
            addDebugLog(`ğŸ” æœªåŒ¹é…ä»»ä½•æ‰‹åŠ¿`);
            return null;
        }

        function fingerExtended(landmarks, tip, pip, mcp) {
            const tipPos = landmarks[tip];
            const pipPos = landmarks[pip];
            const mcpPos = landmarks[mcp];
            const distTipMcp = distance3(tipPos, mcpPos);
            const distPipMcp = distance3(pipPos, mcpPos);
            return distTipMcp > distPipMcp * 1.05 && tipPos.y < mcpPos.y;
        }

        function thumbExtended(landmarks) {
            const tip = landmarks[4];
            const mcp = landmarks[2];
            const wrist = landmarks[0];
            const distTipWrist = distance3(tip, wrist);
            const distMcpWrist = distance3(mcp, wrist);
            return distTipWrist > distMcpWrist * 1.1;
        }

        function distance3(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dz = (a.z || 0) - (b.z || 0);
            return Math.hypot(dx, dy, dz);
        }

        function handleDepthScaling(landmarks) {
            const xs = landmarks.map(p => p.x);
            const ys = landmarks.map(p => p.y);
            const area = (Math.max(...xs) - Math.min(...xs)) * (Math.max(...ys) - Math.min(...ys));
            const depth = THREE.MathUtils.clamp(0.8 + area * 3.5, 0.7, 2.4);
            desiredScale = THREE.MathUtils.lerp(desiredScale, depth, 0.1);
            addDebugLog(`ğŸ“ æ·±åº¦ç¼©æ”¾: ${depth.toFixed(2)} (é¢ç§¯: ${area.toFixed(3)})`);
        }

        function handleWind(landmarks) {
            const palm = averagePalm(landmarks);
            const now = performance.now();
            if (lastPalm) {
                const dt = (now - lastPalmTime) / 1000;
                if (dt > 0) {
                    const dx = palm.x - lastPalm.x;
                    const dy = palm.y - lastPalm.y;
                    const speed = Math.hypot(dx, dy) / dt;
                    smoothedSpeed = THREE.MathUtils.lerp(smoothedSpeed, speed, 0.1);
                    if (speed > 1.4) {
                        const dir = new THREE.Vector3(-dx, -dy, 0);
                        if (dir.length() > 0.0001) {
                            dir.normalize();
                            applyWind(dir, Math.min((speed - 1.4) * 1.6, 2.6));
                            showToast('æŒ¥æ‰‹é£æš´');
                            addDebugLog(`ğŸŒªï¸ é£æš´è§¦å‘! é€Ÿåº¦: ${speed.toFixed(2)}`);
                        }
                    }
                }
            }
            lastPalm = palm;
            lastPalmTime = now;
            addDebugLog(`ğŸ‘‹ æ‰‹æŒé€Ÿåº¦: ${smoothedSpeed.toFixed(2)}`);
        }

        function averagePalm(landmarks) {
            const indices = [0, 5, 9, 13, 17];
            const palm = { x: 0, y: 0, z: 0 };
            indices.forEach(i => {
                palm.x += landmarks[i].x;
                palm.y += landmarks[i].y;
                palm.z += landmarks[i].z || 0;
            });
            palm.x /= indices.length;
            palm.y /= indices.length;
            palm.z /= indices.length;
            return palm;
        }

        function applyWind(direction, intensity) {
            const force = CONFIG.PHYSICS.wind * intensity;
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                const power = force * (0.2 + Math.random() * 0.8);
                velocities[idx] += direction.x * power;
                velocities[idx + 1] += direction.y * power * 0.6;
                velocities[idx + 2] += direction.z * power;
            }
            addDebugLog(`ğŸ’¨ åº”ç”¨é£åŠ›: å¼ºåº¦ ${intensity.toFixed(2)}`);
        }

        function startDemoMode() {
            if (demoModeActive) return;
            demoModeActive = true;
            demoBtn.classList.add('active');
            demoBtn.textContent = 'é€€å‡ºæ¼”ç¤ºæ¨¡å¼';
            showToast('æ¼”ç¤ºæ¨¡å¼ï¼šæ¨¡æ‹Ÿæ‰‹åŠ¿é©±åŠ¨');
            addDebugLog('ğŸ¬ æ¼”ç¤ºæ¨¡å¼å¯åŠ¨');
            let gestureIndex = 0;
            const sequence = ['open', 'scissors', 'fist', 'point', 'thumbsUp'];
            demoGestureTimer = setInterval(() => {
                const gesture = sequence[gestureIndex % sequence.length];
                gestureIndex++;
                // æ¨¡æ‹Ÿå¤šæ¬¡è°ƒç”¨ï¼Œé¿å…éšæœºæ€§
                for (let i = 0; i < 4; i++) {
                    updateGesturePipeline(gesture);
                }
            }, 2600);

            demoDepthTimer = setInterval(() => {
                const simulated = 1 + 0.6 * Math.sin(performance.now() * 0.0012);
                desiredScale = THREE.MathUtils.lerp(desiredScale, THREE.MathUtils.clamp(simulated, 0.8, 2.2), 0.12);
            }, 160);

            demoWindTimer = setInterval(() => {
                const dir = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5),
                    0
                );
                if (dir.lengthSq() > 1e-4) {
                    dir.normalize();
                    smoothedSpeed = THREE.MathUtils.lerp(smoothedSpeed, 1.4 + Math.random(), 0.35);
                    applyWind(dir, 0.7 + Math.random() * 0.8);
                }
            }, 1900);
        }

        function stopDemoMode() {
            if (!demoModeActive) return;
            demoModeActive = false;
            demoBtn.classList.remove('active');
            demoBtn.textContent = 'æ— æ‘„åƒå¤´æ¼”ç¤º';
            clearInterval(demoGestureTimer);
            clearInterval(demoDepthTimer);
            clearInterval(demoWindTimer);
            demoGestureTimer = null;
            demoDepthTimer = null;
            demoWindTimer = null;
            smoothedSpeed = 0;
            showToast('æ¼”ç¤ºæ¨¡å¼å·²å…³é—­');
            addDebugLog('ğŸ›‘ æ¼”ç¤ºæ¨¡å¼åœæ­¢');
        }

        function processHand(landmarks) {
            addDebugLog(`ğŸ§ª processHand è°ƒç”¨ï¼Œå¤„ç† ${landmarks.length} ä¸ªå…³é”®ç‚¹`);
            
            if (demoModeActive) {
                addDebugLog(`â¸ï¸ æ¼”ç¤ºæ¨¡å¼æ¿€æ´»ï¼Œè·³è¿‡çœŸå®æ‰‹åŠ¿å¤„ç†`);
                return;
            }
            
            // æ›´æ–°çŠ¶æ€
            updateStatusIndicator('æ£€æµ‹åˆ°æ‰‹éƒ¨', 'detecting');
            
            try {
                handleDepthScaling(landmarks);
                handleWind(landmarks);
                const gesture = classifyGesture(landmarks);
                updateGesturePipeline(gesture);
                addDebugLog(`âœ… æ‰‹åŠ¿å¤„ç†å®Œæˆï¼Œå½“å‰: ${activeGesture}`);
            } catch (error) {
                addDebugLog(`âŒ æ‰‹åŠ¿å¤„ç†é”™è¯¯: ${error.message}`, 'error');
            }
        }

        let mediapipeHands = null;
        let cameraFeed = null;

        async function setupMediaPipe() {
            if (demoModeActive) {
                stopDemoMode();
            }

            // æ˜¾ç¤ºè¯¦ç»†çš„åŠ è½½çŠ¶æ€
            const toastEl = document.getElementById('toast');
            toastEl.textContent = 'æ­£åœ¨ä¸‹è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...';
            toastEl.classList.add('show');
            addDebugLog('å¼€å§‹åˆå§‹åŒ–MediaPipe Hands...');

            try {
                // å¢å¼ºçš„CDNé”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                    try {
                        // å°è¯•åˆ›å»ºHandså®ä¾‹
                        addDebugLog(`ğŸ”„ ç¬¬ ${retryCount + 1}/${maxRetries} å°è¯•åˆ›å»ºHandså®ä¾‹`);
                        
                        mediapipeHands = new Hands({
                            locateFile: (file) => {
                                const primaryUrl = `${HANDS_PRIMARY_BASE}${file}`;
                                addDebugLog(`ğŸ“ æ­£åœ¨åŠ è½½: ${file}`);
                                return primaryUrl;
                            }
                        });

                        // è®¾ç½®é€‰é¡¹
                        mediapipeHands.setOptions({
                            maxNumHands: 1,
                            modelComplexity: 1,
                            minDetectionConfidence: 0.6,
                            minTrackingConfidence: 0.5,
                            selfieMode: true
                        });
                        
                        addDebugLog('âš™ï¸ Handsé€‰é¡¹è®¾ç½®å®Œæˆ');

                        // è®¾ç½®ç»“æœå¤„ç†
                        mediapipeHands.onResults(results => {
                            addDebugLog(`ğŸ“· æ”¶åˆ°å¸§ç»“æœ: ${results.multiHandLandmarks ? results.multiHandLandmarks.length : 0} æ‰‹`);
                            
                            const hand = results.multiHandLandmarks && results.multiHandLandmarks[0];
                            if (hand) {
                                addDebugLog(`ğŸ‘‹ æ£€æµ‹åˆ°æ‰‹éƒ¨æ•°æ®ï¼Œå¼€å§‹å¤„ç†...`);
                                processHand(hand);
                            } else {
                                smoothedSpeed = THREE.MathUtils.lerp(smoothedSpeed, 0, 0.05);
                                updateStatusIndicator('æœªæ£€æµ‹åˆ°', 'waiting');
                            }
                        });

                        addDebugLog('âœ… onResultså›è°ƒè®¾ç½®å®Œæˆ');

                        // æµ‹è¯•æ€§å‘é€ä¸€å¸§ï¼Œç¡®ä¿æ¨¡å‹åŠ è½½æˆåŠŸ
                        addDebugLog('ğŸ”„ æµ‹è¯•æ¨¡å‹åŠ è½½...');
                        toastEl.textContent = 'æ¨¡å‹åŠ è½½æˆåŠŸï¼Œæ­£åœ¨å¯åŠ¨ç›¸æœº...';
                        
                        // åˆ›å»ºç›¸æœºå®ä¾‹ - æ”¹è¿›ç‰ˆï¼Œç›´æ¥ä½¿ç”¨getUserMedia
                        addDebugLog('ğŸ”„ è¯·æ±‚æ‘„åƒå¤´æƒé™...');
                        
                        // å…ˆç›´æ¥è¯·æ±‚æ‘„åƒå¤´æµï¼Œç¡®ä¿æƒé™å’ŒåŠŸèƒ½æ­£å¸¸
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ 
                                video: { width: 640, height: 480, facingMode: 'user' } 
                            });
                            videoEl.srcObject = stream;
                            
                            // ç­‰å¾…è§†é¢‘å°±ç»ª
                            await new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => reject(new Error('è§†é¢‘æµè¶…æ—¶')), 5000);
                                videoEl.onloadedmetadata = () => {
                                    clearTimeout(timeout);
                                    videoEl.play().then(resolve).catch(reject);
                                };
                                videoEl.onerror = () => {
                                    clearTimeout(timeout);
                                    reject(new Error('è§†é¢‘æµé”™è¯¯'));
                                };
                            });
                            
                            addDebugLog('âœ… æ‘„åƒå¤´æµè·å–æˆåŠŸ');
                            
                        // ç°åœ¨åˆ›å»ºCameraå®ä¾‹å¹¶å¯åŠ¨ - ç§»é™¤å†—ä½™æ£€æŸ¥
                        addDebugLog('ğŸ”„ åˆ›å»ºCameraå®ä¾‹...');
                        
                        cameraFeed = new Camera(videoEl, {
                            onFrame: async () => {
                                if (mediapipeHands && mediapipeHands.send) {
                                    await mediapipeHands.send({ image: videoEl });
                                }
                            },
                            width: 640,
                            height: 480
                        });
                        
                        addDebugLog('ğŸš€ å¯åŠ¨Cameraå®ä¾‹...');
                        
                        // ç›´æ¥å¯åŠ¨ï¼Œä¸è¿›è¡Œå†—ä½™æ£€æŸ¥
                        await cameraFeed.start();
                        
                        // æˆåŠŸï¼
                        addDebugLog('âœ… MediaPipe Hands åˆå§‹åŒ–å…¨éƒ¨æˆåŠŸ');
                        addDebugLog('âœ… ç›¸æœºCameraå®ä¾‹å¯åŠ¨æˆåŠŸ');
                        toastEl.textContent = 'âœ… ç›¸æœºå’Œæ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª';
                        startBtn.disabled = true;
                        videoEl.classList.add('show');
                        showToast('ç›¸æœºå°±ç»ª');
                        updateStatusIndicator('âœ… æ‰‹åŠ¿è¯†åˆ«ä¸­', 'recognized');
                        
                        // 3ç§’åéšè—toast
                        setTimeout(() => {
                            if (toastEl) toastEl.classList.remove('show');
                        }, 3000);
                        
                        return; // æˆåŠŸï¼Œé€€å‡ºé‡è¯•å¾ªç¯
                        } catch (mediaError) {
                            addDebugLog(`âŒ æ‘„åƒå¤´è·å–å¤±è´¥: ${mediaError.message}`, 'error');
                            throw mediaError;
                        }

                    } catch (error) {
                        addDebugLog(`âŒ ç¬¬ ${retryCount + 1} æ¬¡å°è¯•å¤±è´¥: ${error.message}`, 'warn');
                        retryCount++;
                        
                        if (retryCount < maxRetries) {
                            toastEl.textContent = `åŠ è½½å¤±è´¥ï¼Œé‡è¯•ä¸­ (${retryCount}/${maxRetries})...`;
                            await new Promise(resolve => setTimeout(resolve, 1000 * retryCount)); // é€’å¢å»¶è¿Ÿ
                        } else {
                            throw error; // æ²¡æœ‰æ›´å¤šé‡è¯•ï¼ŒæŠ›å‡ºé”™è¯¯
                        }
                    }
                }

            } catch (error) {
                addDebugLog(`âŒ MediaPipeåˆå§‹åŒ–æœ€ç»ˆå¤±è´¥: ${error.message}`, 'error');
                
                // è¯¦ç»†çš„é”™è¯¯è¯Šæ–­
                let errorMsg = 'æ— æ³•åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«';
                
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    errorMsg = 'æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´åŠŸèƒ½';
                    addDebugLog('âŒ æµè§ˆå™¨ä¸æ”¯æŒgetUserMedia');
                } else if (error.message && error.message.includes('network')) {
                    errorMsg = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
                    addDebugLog('âŒ ç½‘ç»œè¿æ¥å¤±è´¥');
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMsg = 'æ‘„åƒå¤´æƒé™è¢«æ‹’ç»';
                    addDebugLog('âŒ æ‘„åƒå¤´æƒé™è¢«æ‹’ç»');
                } else if (error.message && error.message.includes('task')) {
                    errorMsg = 'æ‰‹åŠ¿æ¨¡å‹ä¸‹è½½å¤±è´¥';
                    addDebugLog('âŒ æ¨¡å‹æ–‡ä»¶ä¸‹è½½å¤±è´¥');
                } else {
                    errorMsg = `åˆå§‹åŒ–å¤±è´¥: ${error.message}`;
                    addDebugLog(`âŒ æœªçŸ¥é”™è¯¯: ${error.message}`);
                }

                showToast(errorMsg);
                updateStatusIndicator('âŒ åˆå§‹åŒ–å¤±è´¥', 'error');
                
                // æä¾›å¤‡ç”¨æ–¹æ¡ˆ
                const startBtn = document.getElementById('startCamera');
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'ğŸ”„ é‡è¯•ç›¸æœº';
                    startBtn.onclick = () => {
                        startBtn.textContent = 'å¼€å¯ç›¸æœº Â· MediaPipe Hands';
                        startBtn.disabled = true;
                        setupMediaPipe();
                    };
                }

                // æç¤ºä½¿ç”¨æ¼”ç¤ºæ¨¡å¼
                const demoBtn = document.getElementById('demoMode');
                if (demoBtn) {
                    demoBtn.style.display = 'block';
                    demoBtn.textContent = 'ğŸ”§ åˆ‡æ¢åˆ°æ¼”ç¤ºæ¨¡å¼';
                }
            }
        }

        // é¡µé¢äº¤äº’å’Œè°ƒè¯•åŠŸèƒ½
        let manualRetryCount = 0;
        
        startBtn.addEventListener('click', () => {
            if (mediapipeHands) return;
            startBtn.disabled = true;
            startBtn.textContent = 'åˆå§‹åŒ–ä¸­...';
            addDebugLog('ğŸ”§ ç”¨æˆ·ç‚¹å‡»å¼€å§‹æŒ‰é’®');
            setupMediaPipe();
        });

        demoBtn.addEventListener('click', () => {
            if (demoModeActive) {
                stopDemoMode();
            } else {
                // å¦‚æœä¸»åŠŸèƒ½å¤±è´¥ï¼Œå¢å¼ºæ¼”ç¤ºæ¨¡å¼æŒ‰é’®çš„æç¤º
                if (!mediapipeHands && manualRetryCount > 0) {
                    demoBtn.textContent = 'ğŸ”§ æ¼”ç¤ºæ¨¡å¼ (ç›¸æœºä¸å¯ç”¨)';
                }
                startDemoMode();
            }
        });

        // è°ƒè¯•é¢æ¿åˆ‡æ¢
        debugToggle.addEventListener('click', () => {
            debugPanel.classList.toggle('show');
            if (debugPanel.classList.contains('show')) {
                debugPanel.textContent = debugLogs.join('\n');
                debugToggle.textContent = 'âŒ';
                debugToggle.style.background = 'rgba(255, 0, 0, 0.6)';
            } else {
                debugToggle.textContent = 'ğŸ›';
                debugToggle.style.background = 'rgba(0, 0, 0, 0.6)';
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåçš„æ£€æµ‹
        window.addEventListener('load', () => {
            addDebugLog('ğŸŒ é¡µé¢åŠ è½½å®Œæˆ');
            
            // æ£€æŸ¥æ˜¯å¦åœ¨å®‰å…¨ä¸Šä¸‹æ–‡
            if (!window.isSecureContext) {
                addDebugLog('âš ï¸ éå®‰å…¨ç¯å¢ƒ(éœ€è¦HTTPSæˆ–localhost)');
                showToast('éå®‰å…¨ç¯å¢ƒï¼Œæ¨èä½¿ç”¨æ¼”ç¤ºæ¨¡å¼');
            }
            
            // åˆå§‹åŒ–3Dåœºæ™¯
            initThree();
            setInitialParticles();
            morphToShape('sphere');
            animate();
            
            addDebugLog('âœ… 3Dåœºæ™¯åˆå§‹åŒ–å®Œæˆ');
            addDebugLog('ğŸ’¡ ç­‰å¾…ç”¨æˆ·ç‚¹å‡»"å¼€å¯ç›¸æœº"æŒ‰é’®');
        });

        // ç›‘å¬é”®ç›˜å¿«æ·é”®ï¼Œå¢å¼ºä½“éªŒ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !mediapipeHands && !demoModeActive) {
                addDebugLog('âŒ¨ï¸ Enteré”®å¿«é€Ÿå¯åŠ¨æ¼”ç¤ºæ¨¡å¼');
                startDemoMode();
            }
            if (e.key === 'd' || e.key === 'D') {
                // å¿«é€Ÿæ˜¾ç¤º/éšè—è°ƒè¯•é¢æ¿
                debugToggle.click();
            }
        });
    </script>
</body>
</html>
