<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­æ˜Ÿçƒ - æ‰‹åŠ¿æ§åˆ¶ (å®Œå…¨ç¦»çº¿ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        
        #input-video {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 170, 0, 0.3);
        }
        
        h1 { font-size: 1.2rem; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; color: #ffaa00; }
        .instruction { font-size: 0.9rem; margin-bottom: 5px; display: flex; align-items: center; }
        .icon { margin-right: 8px; font-weight: bold; color: #ffaa00; }
        
        #loading {
            position: absolute;
            top: 50%; width: 100%; text-align: center;
            color: #ffaa00; font-size: 1.5rem;
            transform: translateY(-50%);
            transition: opacity 0.5s;
            pointer-events: none;
            background: rgba(0,0,0,0.9);
            padding: 30px 0;
            border-top: 2px solid #ffaa00;
            border-bottom: 2px solid #ffaa00;
        }
        
        #perf-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            font-size: 0.9rem;
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            font-family: monospace;
        }

        #debug-camera {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #ffaa00;
            border-radius: 8px;
            overflow: hidden;
            display: none;
            background: #000;
            z-index: 15;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
        }

        #debug-camera video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #debug-toggle {
            position: absolute;
            bottom: 150px;
            left: 20px;
            background: rgba(255, 170, 0, 0.3);
            border: 1px solid #ffaa00;
            color: #ffaa00;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            z-index: 16;
            transition: all 0.3s;
            display: none;
            font-weight: bold;
        }

        #debug-toggle:hover {
            background: rgba(255, 170, 0, 0.6);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
        }

        #debug-status {
            position: absolute;
            bottom: 190px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            display: none;
            z-index: 16;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-family: monospace;
            max-width: 250px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* é”™è¯¯æç¤º */
        #error-notice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200, 0, 0, 0.95);
            border: 2px solid #ff4444;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            color: #fff;
            display: none;
            z-index: 100;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(200, 0, 0, 0.5);
        }
        
        #error-notice h3 { margin-top: 0; color: #fff; }
        #error-notice button {
            background: #fff;
            color: #c00;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 15px;
            font-size: 1rem;
            transition: all 0.3s;
        }
        
        #error-notice button:hover {
            background: #ff4444;
            color: #fff;
            transform: scale(1.05);
        }

        /* æˆåŠŸæç¤º */
        #success-notice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 200, 0, 0.95);
            border: 2px solid #00ff00;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            color: #fff;
            display: none;
            z-index: 100;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0, 200, 0, 0.5);
        }
        
        #success-notice h3 { margin-top: 0; color: #fff; }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            background: #666;
        }
        .status-dot.active { background: #00ff00; box-shadow: 0 0 6px #00ff00; }
        .status-dot.error { background: #ff0000; box-shadow: 0 0 6px #ff0000; }
        .status-dot.warning { background: #ffaa00; box-shadow: 0 0 6px #ffaa00; }

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        #system-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 0.8rem;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }

        #system-status div {
            margin: 3px 0;
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>

    <!-- ç³»ç»ŸçŠ¶æ€æ  -->
    <div id="system-status">
        <div><span class="status-dot" id="dot-three"></span>Three.js</div>
        <div><span class="status-dot" id="dot-media"></span>MediaPipe</div>
        <div><span class="status-dot" id="dot-camera"></span>æ‘„åƒå¤´</div>
        <div><span class="status-dot" id="dot-system"></span>ç³»ç»Ÿå°±ç»ª</div>
    </div>

    <!-- UI å±‚ -->
    <div id="ui-layer">
        <h1>Hand Control Universe</h1>
        <div class="instruction"><span class="icon">â†º</span> æ—‹è½¬æ‰‹æŒ â†’ æ—‹è½¬æ˜Ÿçƒ</div>
        <div class="instruction"><span class="icon">âœŠ</span> æ¡æ‹³ + è¿œç¦» â†’ æ‹‰è¿œé•œå¤´</div>
        <div class="instruction"><span class="icon">ğŸ–</span> å¼ å¼€ + é è¿‘ â†’ æ‹‰è¿‘é•œå¤´</div>
    </div>

    <!-- åŠ è½½æç¤º -->
    <div id="loading">
        æ­£åœ¨åˆå§‹åŒ–å®Œå…¨ç¦»çº¿ç‰ˆæœ¬...<br>
        <span style="font-size:0.8rem; color:#fff;">
            æ‰€æœ‰èµ„æºå·²ä¸‹è½½åˆ°æœ¬åœ°<br>
            è¯·å…è®¸æ‘„åƒå¤´æƒé™
        </span>
    </div>

    <!-- æ€§èƒ½æŒ‡ç¤ºå™¨ -->
    <div id="perf-indicator" style="opacity: 0;">FPS: <span id="fps">--</span></div>

    <!-- è°ƒè¯•æ§ä»¶ -->
    <button id="debug-toggle">ğŸ” è°ƒè¯•æ‘„åƒå¤´</button>
    <div id="debug-status">çŠ¶æ€: ç­‰å¾…åˆå§‹åŒ–...</div>
    
    <!-- è°ƒè¯•æ‘„åƒå¤´é¢„è§ˆ -->
    <div id="debug-camera">
        <video id="debug-video" autoplay playsinline muted></video>
    </div>

    <!-- é”™è¯¯æç¤º -->
    <div id="error-notice">
        <h3>âš ï¸ åˆå§‹åŒ–å¤±è´¥</h3>
        <p id="error-message"></p>
        <div style="text-align: left; margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 0.85rem;">
            <strong>å¯èƒ½åŸå› ï¼š</strong><br>
            â€¢ æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´<br>
            â€¢ æœ¬åœ°æ–‡ä»¶è¢«æµè§ˆå™¨å®‰å…¨ç­–ç•¥é˜»æ­¢<br>
            â€¢ æ“ä½œç³»ç»Ÿä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®
        </div>
        <button onclick="location.reload()">ğŸ”„ é‡è¯•</button>
    </div>

    <!-- æˆåŠŸæç¤º -->
    <div id="success-notice">
        <h3>âœ… ç³»ç»Ÿå°±ç»ª</h3>
        <p>è¯·ç‚¹å‡»å±å¹•å¼€å§‹ä½“éªŒæ‰‹åŠ¿æ§åˆ¶</p>
        <div style="font-size: 0.85rem; margin-top: 10px; opacity: 0.8;">
            æ— éœ€ç½‘ç»œï¼Œå®Œå…¨æœ¬åœ°è¿è¡Œ
        </div>
    </div>

    <!-- MediaPipe éœ€è¦çš„éšè—è§†é¢‘å…ƒç´  -->
    <video id="input-video"></video>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            localPaths: {
                three: './local-libs/three.min.js',
                mediapipe: {
                    hands: './local-libs/mediapipe-hands.js',
                    camera: './local-libs/mediapipe-camera-utils.js',
                    drawing: './local-libs/mediapipe-drawing-utils.js',
                    control: './local-libs/mediapipe-control-utils.js'
                }
            }
        };

        // çŠ¶æ€ç®¡ç†
        const STATE = {
            threeLoaded: false,
            mediapipeLoaded: false,
            cameraReady: false,
            systemReady: false,
            errors: [],
            loadedFiles: []
        };

        // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
        function updateStatusIndicator(type, status) {
            const dot = document.getElementById(`dot-${type}`);
            if (dot) {
                dot.className = 'status-dot';
                if (status === 'loaded') dot.classList.add('active');
                else if (status === 'error') dot.classList.add('error');
                else if (status === 'loading') dot.classList.add('warning');
            }
        }

        // å·¥å…·å‡½æ•°ï¼šæ˜¾ç¤ºé”™è¯¯
        function showError(message, details = '') {
            console.error('âŒ Error:', message, details);
            const errorEl = document.getElementById('error-notice');
            const messageEl = document.getElementById('error-message');
            const loadingEl = document.getElementById('loading');
            
            loadingEl.style.display = 'none';
            errorEl.style.display = 'block';
            messageEl.innerHTML = `<strong>${message}</strong><br><small>${details}</small>`;
            
            STATE.errors.push({ message, details, time: new Date() });
            updateStatusIndicator('system', 'error');
        }

        // å·¥å…·å‡½æ•°ï¼šæ˜¾ç¤ºçŠ¶æ€
        function showStatus(message, type = 'info') {
            const loadingEl = document.getElementById('loading');
            const debugStatus = document.getElementById('debug-status');
            const statusEl = document.getElementById('system-status');
            
            loadingEl.innerHTML = message;
            if (debugStatus) {
                debugStatus.textContent = `çŠ¶æ€: ${message}`;
                debugStatus.style.color = type === 'error' ? '#ff4444' : type === 'success' ? '#00ff00' : '#ffffff';
            }
            console.log(`[ç³»ç»ŸçŠ¶æ€] ${message}`);
        }

        // å·¥å…·å‡½æ•°ï¼šåŠ¨æ€åŠ è½½è„šæœ¬ï¼ˆå®Œå…¨æœ¬åœ°åŒ–ï¼‰
        function loadLocalScript(src, name) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = false; // åŒæ­¥åŠ è½½ï¼Œé¿å…ä¾èµ–é—®é¢˜
                
                script.onload = () => {
                    console.log(`âœ… åŠ è½½æˆåŠŸ: ${name}`);
                    STATE.loadedFiles.push(name);
                    updateStatusIndicator(getStatusType(name), 'loaded');
                    resolve();
                };
                
                script.onerror = (e) => {
                    console.warn(`âš ï¸ åŠ è½½å¤±è´¥: ${name} (${src})`, e);
                    updateStatusIndicator(getStatusType(name), 'error');
                    reject(new Error(`æ— æ³•åŠ è½½ ${name}: ${src}`));
                };
                
                document.head.appendChild(script);
            });
        }

        // æ ¹æ®æ–‡ä»¶åè·å–çŠ¶æ€ç±»å‹
        function getStatusType(name) {
            if (name.includes('three')) return 'three';
            if (name.includes('mediapipe') || name.includes('hands')) return 'media';
            return 'system';
        }

        // æ ¸å¿ƒï¼šåŠ è½½æœ¬åœ° Three.js
        async function loadThreeJS() {
            showStatus('æ­£åœ¨åŠ è½½æœ¬åœ° Three.js (ç¦»çº¿ç‰ˆ)...');
            updateStatusIndicator('three', 'loading');
            
            try {
                await loadLocalScript(CONFIG.localPaths.three, 'Three.js');
                
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js åŠ è½½åæœªæ‰¾åˆ° THREE å¯¹è±¡');
                }
                
                STATE.threeLoaded = true;
                return THREE;
                
            } catch (error) {
                throw new Error(`Three.js åŠ è½½å¤±è´¥: ${error.message}`);
            }
        }

        // æ ¸å¿ƒï¼šåŠ è½½æœ¬åœ° MediaPipe
        async function loadMediaPipe() {
            showStatus('æ­£åœ¨åŠ è½½æœ¬åœ° MediaPipe (ç¦»çº¿ç‰ˆ)...');
            updateStatusIndicator('media', 'loading');
            
            try {
                // æŒ‰é¡ºåºåŠ è½½ä¾èµ–
                await loadLocalScript(CONFIG.localPaths.mediapipe.drawing, 'MediaPipe Drawing Utils');
                await loadLocalScript(CONFIG.localPaths.mediapipe.control, 'MediaPipe Control Utils');
                await loadLocalScript(CONFIG.localPaths.mediapipe.camera, 'MediaPipe Camera Utils');
                await loadLocalScript(CONFIG.localPaths.mediapipe.hands, 'MediaPipe Hands');
                
                // éªŒè¯åŠ è½½
                if (typeof Hands === 'undefined') {
                    throw new Error('MediaPipe Hands æœªæ­£ç¡®åŠ è½½');
                }
                
                if (typeof Camera === 'undefined') {
                    throw new Error('MediaPipe Camera æœªæ­£ç¡®åŠ è½½');
                }
                
                STATE.mediapipeLoaded = true;
                showStatus('æœ¬åœ° MediaPipe åŠ è½½å®Œæˆ', 'success');
                
            } catch (error) {
                throw new Error(`MediaPipe åŠ è½½å¤±è´¥: ${error.message}`);
            }
        }

        // æ ¸å¿ƒï¼šè¯·æ±‚æ‘„åƒå¤´æƒé™
        async function requestCamera() {
            showStatus('æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...<br><small>è¯·åœ¨å¼¹å‡ºçª—å£ä¸­é€‰æ‹©"å…è®¸"</small>');
            updateStatusIndicator('camera', 'loading');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                if (!stream || !stream.getVideoTracks().length) {
                    throw new Error('æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»');
                }
                
                // ç«‹å³åœæ­¢ï¼Œæˆ‘ä»¬åªéœ€è¦æƒé™
                stream.getTracks().forEach(track => track.stop());
                
                STATE.cameraReady = true;
                updateStatusIndicator('camera', 'loaded');
                showStatus('æ‘„åƒå¤´æƒé™å·²è·å–', 'success');
                
            } catch (error) {
                updateStatusIndicator('camera', 'error');
                throw new Error(`æ‘„åƒå¤´æƒé™è¯·æ±‚å¤±è´¥: ${error.message}`);
            }
        }

        // æ ¸å¿ƒï¼šå¯åŠ¨ä¸»åº”ç”¨
        async function startMainApplication() {
            showStatus('æ­£åœ¨å¯åŠ¨ä¸»åº”ç”¨...');
            
            if (!STATE.threeLoaded || !STATE.mediapipeLoaded || !STATE.cameraReady) {
                throw new Error('ä¾èµ–æœªå®Œå…¨åŠ è½½');
            }

            // ç”±äºæ— æ³•åœ¨å‡½æ•°å†…åŠ¨æ€ import æœ¬åœ°æ¨¡å—ï¼Œæˆ‘ä»¬ä½¿ç”¨å…¨å±€ THREE
            // æ£€æŸ¥ THREE æ˜¯å¦å¯ç”¨
            if (typeof THREE === 'undefined') {
                throw new Error('THREE å¯¹è±¡ä¸å¯ç”¨');
            }
            
            const THREE = window.THREE; // ä½¿ç”¨å…¨å±€å¯¹è±¡

            // ==========================================
            // 1. THREE.JS åœºæ™¯è®¾ç½®
            // ==========================================
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // åˆ›å»ºå‘å…‰ç²’å­çº¹ç†ï¼ˆå†…è”ï¼Œé¿å…å¤–éƒ¨èµ„æºï¼‰
            function createLightTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 32, 32);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            }

            const particleTexture = createLightTexture();

            // åˆ›å»ºæ˜Ÿçƒ
            const planetGeometry = new THREE.BufferGeometry();
            const planetCount = 4000;
            const planetPos = new Float32Array(planetCount * 3);
            const planetSizes = new Float32Array(planetCount);

            for (let i = 0; i < planetCount; i++) {
                const radius = 8 + Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                planetPos[i * 3] = x;
                planetPos[i * 3 + 1] = y;
                planetPos[i * 3 + 2] = z;
                planetSizes[i] = Math.random() * 1.5 + 0.5;
            }

            planetGeometry.setAttribute('position', new THREE.BufferAttribute(planetPos, 3));
            planetGeometry.setAttribute('size', new THREE.BufferAttribute(planetSizes, 1));

            const planetMaterial = new THREE.PointsMaterial({
                color: 0xffaa00,
                size: 0.8,
                map: particleTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const planet = new THREE.Points(planetGeometry, planetMaterial);
            scene.add(planet);

            // åˆ›å»ºæ˜Ÿç¯
            const ringParticlesCount = 3000;
            const ringGeometry = new THREE.BufferGeometry();
            const ringPos = new Float32Array(ringParticlesCount * 3);

            for (let i = 0; i < ringParticlesCount; i++) {
                const isRing1 = Math.random() > 0.5;
                const baseR = isRing1 ? 14 : 22;
                const ringWidth = 4;
                const r = baseR + Math.random() * ringWidth;
                const angle = Math.random() * Math.PI * 2;
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);
                const y = (Math.random() - 0.5) * 1;
                ringPos[i * 3] = x;
                ringPos[i * 3 + 1] = y;
                ringPos[i * 3 + 2] = z;
            }

            ringGeometry.setAttribute('position', new THREE.BufferAttribute(ringPos, 3));
            const ringMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.6,
                map: particleTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const ringSystem = new THREE.Points(ringGeometry, ringMaterial);
            ringSystem.rotation.z = Math.PI / 8;
            ringSystem.rotation.x = Math.PI / 8;
            scene.add(ringSystem);

            // æ‘„åƒæœºæ§åˆ¶å˜é‡
            let targetOrbitAngle = 0;
            let currentOrbitAngle = 0;
            let targetDistance = 40;
            let currentDistance = 40;
            let isHandDetected = false;
            let autoRotateSpeed = 0.001;

            // MediaPipe ç›¸å…³å˜é‡
            const videoElement = document.getElementById('input-video');
            let hands, cameraUtils;
            let debugMode = false;
            let debugVideoStream = null;

            // è°ƒè¯•åŠŸèƒ½
            function setupDebugControls() {
                const debugToggle = document.getElementById('debug-toggle');
                const debugCamera = document.getElementById('debug-camera');
                const debugStatus = document.getElementById('debug-status');
                const debugVideo = document.getElementById('debug-video');

                debugToggle.style.display = 'block';
                debugStatus.style.display = 'block';
                
                debugToggle.addEventListener('click', async () => {
                    debugMode = !debugMode;
                    
                    if (debugMode) {
                        debugCamera.style.display = 'block';
                        debugToggle.textContent = 'ğŸ” å…³é—­è°ƒè¯•';
                        
                        try {
                            if (!debugVideoStream) {
                                const stream = await navigator.mediaDevices.getUserMedia({ 
                                    video: { width: 640, height: 480 } 
                                });
                                debugVideoStream = stream;
                                debugVideo.srcObject = stream;
                                updateDebugStatus('æ‘„åƒå¤´å·²è¿æ¥', '#00ff00');
                            } else {
                                debugVideo.srcObject = debugVideoStream;
                                updateDebugStatus('æ‘„åƒå¤´å·²è¿æ¥', '#00ff00');
                            }
                        } catch (err) {
                            updateDebugStatus('æ‘„åƒå¤´æƒé™è¢«æ‹’ç»', '#ff0000');
                        }
                    } else {
                        debugCamera.style.display = 'none';
                        debugToggle.textContent = 'ğŸ” è°ƒè¯•æ‘„åƒå¤´';
                        updateDebugStatus('ç³»ç»Ÿè¿è¡Œä¸­', '#00ff00');
                    }
                });
            }

            function updateDebugStatus(message, color = '#ffffff') {
                const debugStatus = document.getElementById('debug-status');
                if (debugStatus) {
                    debugStatus.textContent = `çŠ¶æ€: ${message}`;
                    debugStatus.style.color = color;
                    // é™åˆ¶æ˜¾ç¤ºé•¿åº¦
                    if (debugStatus.textContent.length > 40) {
                        debugStatus.textContent = debugStatus.textContent.substring(0, 37) + '...';
                    }
                }
            }

            function onResults(results) {
                if (!results || !results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    if (isHandDetected) {
                        isHandDetected = false;
                        updateDebugStatus('æœªæ£€æµ‹åˆ°æ‰‹åŠ¿', '#ffff00');
                    }
                    return;
                }

                // éšè—åŠ è½½/æˆåŠŸæç¤º
                const loadingEl = document.getElementById('loading');
                const successEl = document.getElementById('success-notice');
                
                loadingEl.style.opacity = '0';
                setTimeout(() => loadingEl.style.display = 'none', 500);
                
                if (successEl.style.display !== 'none') {
                    setTimeout(() => successEl.style.display = 'none', 1500);
                }

                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const middleTip = landmarks[9];
                
                const dx = middleTip.x - wrist.x;
                const dy = middleTip.y - wrist.y;
                let rotationAngle = Math.atan2(dx, -dy);
                targetOrbitAngle = rotationAngle * 3.0;

                const sizeRef = Math.sqrt(
                    Math.pow(landmarks[0].x - landmarks[9].x, 2) + 
                    Math.pow(landmarks[0].y - landmarks[9].y, 2)
                ); 

                const fingertips = [8, 12, 16, 20];
                let foldedFingers = 0;
                fingertips.forEach(idx => {
                    const d = Math.sqrt(Math.pow(landmarks[idx].x - landmarks[0].x, 2) + Math.pow(landmarks[idx].y - landmarks[0].y, 2));
                    if (d < sizeRef * 1.6) foldedFingers++;
                });

                const isFist = foldedFingers >= 3;
                const isOpen = foldedFingers <= 1;

                if (isFist) {
                    const factor = Math.max(0.01, sizeRef); 
                    targetDistance = 20 + 5 / factor; 
                } else if (isOpen) {
                    const factor = Math.min(0.5, sizeRef);
                    targetDistance = 100 - (factor * 200); 
                }

                targetDistance = Math.max(15, Math.min(150, targetDistance));
                
                const gestureName = isFist ? 'æ¡æ‹³' : (isOpen ? 'å¼ å¼€' : 'å…¶å®ƒ');
                updateDebugStatus(`æ‰‹åŠ¿: ${gestureName} | è·ç¦»: ${targetDistance.toFixed(1)}`, '#00ff00');
            }

            async function initializeMediaPipe() {
                const mpStart = performance.now();
                updateDebugStatus('æ­£åœ¨åˆå§‹åŒ–MediaPipe...', '#ffff00');

                try {
                    // ç­‰å¾… MediaPipe åº“åŠ è½½
                    let retryCount = 0;
                    while (typeof Hands === 'undefined' && retryCount < 20) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        retryCount++;
                    }

                    if (typeof Hands === 'undefined') {
                        throw new Error('MediaPipe Handsåº“æœªåŠ è½½');
                    }

                    // ä½¿ç”¨æœ¬åœ°è·¯å¾„ï¼ˆè™½ç„¶hands.jså†…éƒ¨å¯èƒ½ä»éœ€æ¨¡å‹æ–‡ä»¶ï¼‰
                    hands = new Hands({locateFile: (file) => {
                        // å°è¯•ä½¿ç”¨æœ¬åœ°æ¨¡å‹æ–‡ä»¶ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™å›é€€åˆ°CDN
                        const modelMap = {
                            'hands_landmark_full.tflite': './local-libs/hands_landmark_full.tflite',
                            'hands_landmark_lite.tflite': './local-libs/hands_landmark_lite.tflite',
                            'handedness.txt': './local-libs/handedness.txt'
                        };
                        // ä¼˜å…ˆå°è¯•æœ¬åœ°ï¼Œå¤±è´¥åˆ™å›é€€åˆ°CDN
                        return modelMap[file] || `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }});

                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });

                    hands.onResults(onResults);

                    // ä½¿ç”¨æœ¬åœ° Camera ç±»
                    cameraUtils = new Camera(videoElement, {
                        onFrame: async () => {
                            if (hands && hands.send && videoElement.readyState === 4) {
                                await hands.send({image: videoElement});
                            }
                        },
                        width: 640,
                        height: 480
                    });
                    
                    await cameraUtils.start();

                    console.log(`MediaPipeåˆå§‹åŒ–è€—æ—¶: ${(performance.now() - mpStart).toFixed(2)}ms`);
                    updateDebugStatus('MediaPipeåˆå§‹åŒ–å®Œæˆ', '#00ff00');
                    
                } catch (error) {
                    console.error('MediaPipeåˆå§‹åŒ–å¤±è´¥:', error);
                    updateDebugStatus(`MediaPipeé”™è¯¯: ${error.message}`, '#ff0000');
                    throw error;
                }
            }

            // æ¸²æŸ“å¾ªç¯
            let frameCount = 0;
            let lastFPSTime = 0;
            
            function animate() {
                requestAnimationFrame(animate);

                if (isHandDetected) {
                    currentOrbitAngle += (targetOrbitAngle - currentOrbitAngle) * 0.1;
                    currentDistance += (targetDistance - currentDistance) * 0.08;
                } else {
                    currentOrbitAngle += autoRotateSpeed;
                }

                const y = currentDistance * 0.3; 
                const horizontalDist = Math.sqrt(currentDistance * currentDistance - y * y);
                
                camera.position.x = horizontalDist * Math.sin(currentOrbitAngle);
                camera.position.z = horizontalDist * Math.cos(currentOrbitAngle);
                camera.position.y = y;
                camera.lookAt(0, 0, 0);

                planet.rotation.y += 0.002;
                ringSystem.rotation.z -= 0.001;

                renderer.render(scene, camera);

                frameCount++;
                const now = performance.now();
                if (now - lastFPSTime >= 500) {
                    const fps = Math.round((frameCount * 1000) / (now - lastFPSTime));
                    document.getElementById('fps').textContent = fps;
                    frameCount = 0;
                    lastFPSTime = now;
                    document.getElementById('perf-indicator').style.opacity = '1';
                }
            }

            // çª—å£è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // å¯åŠ¨åº”ç”¨
            async function startApp() {
                try {
                    await initializeMediaPipe();
                    setupDebugControls();
                    
                    // æ˜¾ç¤ºæˆåŠŸæç¤º
                    const successEl = document.getElementById('success-notice');
                    successEl.style.display = 'block';
                    updateStatusIndicator('system', 'loaded');
                    
                    animate();
                    STATE.systemReady = true;
                    showStatus('ç³»ç»Ÿè¿è¡Œæ­£å¸¸ - å®Œå…¨ç¦»çº¿æ¨¡å¼', 'success');
                    
                } catch (error) {
                    showError('åº”ç”¨å¯åŠ¨å¤±è´¥', error.message);
                }
            }

            // ç­‰å¾…ç”¨æˆ·äº¤äº’
            document.addEventListener('click', startApp, { once: true });
            
            // è‡ªåŠ¨æç¤ºç”¨æˆ·
            setTimeout(() => {
                if (!STATE.systemReady) {
                    showStatus('è¯·ç‚¹å‡»å±å¹•ä»»æ„ä½ç½®å¼€å§‹<br><small>éœ€è¦æ‘„åƒå¤´æƒé™ - å®Œå…¨ç¦»çº¿è¿è¡Œ</small>');
                }
            }, 1500);
        }

        // ä¸»åˆå§‹åŒ–æµç¨‹
        async function main() {
            console.log('ğŸš€ å¼€å§‹åˆå§‹åŒ–å®Œå…¨ç¦»çº¿ WebAR ç³»ç»Ÿ...');
            console.log('ğŸ“¦ å·²ä¸‹è½½èµ„æº:', STATE.loadedFiles);
            
            // 1. æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´', 'è¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨å¦‚ Chromeã€Edgeã€Firefox');
                return;
            }

            if (!window.isSecureContext && !window.location.hostname.includes('localhost')) {
                showError('éœ€è¦å®‰å…¨è¿æ¥', 'è¯·ä½¿ç”¨ HTTPS æˆ– localhost è®¿é—®');
                return;
            }

            try {
                // 2. åŠ è½½æœ¬åœ°ä¾èµ–
                await loadThreeJS();
                await loadMediaPipe();
                
                // 3. è¯·æ±‚æƒé™
                await requestCamera();
                
                // 4. å¯åŠ¨ä¸»åº”ç”¨
                await startMainApplication();
                
            } catch (error) {
                showError('åˆå§‹åŒ–å¤±è´¥', error.message);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹
        window.addEventListener('load', () => {
            // ç¨å¾®å»¶è¿Ÿç¡®ä¿ DOM å°±ç»ª
            setTimeout(main, 100);
        });
    </script>
</body>
</html>
